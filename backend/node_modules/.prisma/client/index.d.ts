
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model VoiceModel
 * 
 */
export type VoiceModel = $Result.DefaultSelection<Prisma.$VoiceModelPayload>
/**
 * Model TrainingSample
 * 
 */
export type TrainingSample = $Result.DefaultSelection<Prisma.$TrainingSamplePayload>
/**
 * Model CallSession
 * 
 */
export type CallSession = $Result.DefaultSelection<Prisma.$CallSessionPayload>
/**
 * Model TranscriptMessage
 * 
 */
export type TranscriptMessage = $Result.DefaultSelection<Prisma.$TranscriptMessagePayload>
/**
 * Model CallSummary
 * 
 */
export type CallSummary = $Result.DefaultSelection<Prisma.$CallSummaryPayload>
/**
 * Model DailyAnalytics
 * 
 */
export type DailyAnalytics = $Result.DefaultSelection<Prisma.$DailyAnalyticsPayload>
/**
 * Model Business
 * 
 */
export type Business = $Result.DefaultSelection<Prisma.$BusinessPayload>
/**
 * Model InboundCall
 * 
 */
export type InboundCall = $Result.DefaultSelection<Prisma.$InboundCallPayload>
/**
 * Model OutboundCall
 * 
 */
export type OutboundCall = $Result.DefaultSelection<Prisma.$OutboundCallPayload>
/**
 * Model CallRoutingRule
 * 
 */
export type CallRoutingRule = $Result.DefaultSelection<Prisma.$CallRoutingRulePayload>
/**
 * Model OutboundCampaign
 * 
 */
export type OutboundCampaign = $Result.DefaultSelection<Prisma.$OutboundCampaignPayload>
/**
 * Model CallQueue
 * 
 */
export type CallQueue = $Result.DefaultSelection<Prisma.$CallQueuePayload>
/**
 * Model CallbackRequest
 * 
 */
export type CallbackRequest = $Result.DefaultSelection<Prisma.$CallbackRequestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Plan: {
  STARTER: 'STARTER',
  PROFESSIONAL: 'PROFESSIONAL',
  ENTERPRISE: 'ENTERPRISE'
};

export type Plan = (typeof Plan)[keyof typeof Plan]


export const ApiKeyType: {
  PRODUCTION: 'PRODUCTION',
  DEVELOPMENT: 'DEVELOPMENT'
};

export type ApiKeyType = (typeof ApiKeyType)[keyof typeof ApiKeyType]


export const VoiceModelStatus: {
  PENDING: 'PENDING',
  TRAINING: 'TRAINING',
  READY: 'READY',
  FAILED: 'FAILED'
};

export type VoiceModelStatus = (typeof VoiceModelStatus)[keyof typeof VoiceModelStatus]


export const CallDirection: {
  INBOUND: 'INBOUND',
  OUTBOUND: 'OUTBOUND'
};

export type CallDirection = (typeof CallDirection)[keyof typeof CallDirection]


export const CallStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  MISSED: 'MISSED',
  FAILED: 'FAILED'
};

export type CallStatus = (typeof CallStatus)[keyof typeof CallStatus]


export const Sentiment: {
  POSITIVE: 'POSITIVE',
  NEUTRAL: 'NEUTRAL',
  NEGATIVE: 'NEGATIVE'
};

export type Sentiment = (typeof Sentiment)[keyof typeof Sentiment]


export const Speaker: {
  AI: 'AI',
  CALLER: 'CALLER'
};

export type Speaker = (typeof Speaker)[keyof typeof Speaker]


export const InboundCallStatus: {
  RINGING: 'RINGING',
  QUEUED: 'QUEUED',
  IN_PROGRESS: 'IN_PROGRESS',
  ON_HOLD: 'ON_HOLD',
  TRANSFERRED: 'TRANSFERRED',
  COMPLETED: 'COMPLETED',
  MISSED: 'MISSED',
  VOICEMAIL: 'VOICEMAIL',
  FAILED: 'FAILED'
};

export type InboundCallStatus = (typeof InboundCallStatus)[keyof typeof InboundCallStatus]


export const OutboundCallStatus: {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  DIALING: 'DIALING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type OutboundCallStatus = (typeof OutboundCallStatus)[keyof typeof OutboundCallStatus]


export const CallResult: {
  ANSWERED: 'ANSWERED',
  VOICEMAIL: 'VOICEMAIL',
  BUSY: 'BUSY',
  NO_ANSWER: 'NO_ANSWER',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  CALLBACK_REQUESTED: 'CALLBACK_REQUESTED'
};

export type CallResult = (typeof CallResult)[keyof typeof CallResult]


export const ConditionType: {
  TIME_BASED: 'TIME_BASED',
  CALLER_ID: 'CALLER_ID',
  KEYWORD: 'KEYWORD',
  QUEUE_LENGTH: 'QUEUE_LENGTH',
  CALLER_HISTORY: 'CALLER_HISTORY'
};

export type ConditionType = (typeof ConditionType)[keyof typeof ConditionType]


export const ActionType: {
  AI_AGENT: 'AI_AGENT',
  VOICEMAIL: 'VOICEMAIL',
  TRANSFER: 'TRANSFER',
  PLAY_MESSAGE: 'PLAY_MESSAGE',
  QUEUE: 'QUEUE',
  CALLBACK: 'CALLBACK'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  RUNNING: 'RUNNING',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const QueueStatus: {
  WAITING: 'WAITING',
  BEING_SERVED: 'BEING_SERVED',
  SERVED: 'SERVED',
  ABANDONED: 'ABANDONED',
  TRANSFERRED: 'TRANSFERRED'
};

export type QueueStatus = (typeof QueueStatus)[keyof typeof QueueStatus]


export const CallbackStatus: {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type CallbackStatus = (typeof CallbackStatus)[keyof typeof CallbackStatus]

}

export type Plan = $Enums.Plan

export const Plan: typeof $Enums.Plan

export type ApiKeyType = $Enums.ApiKeyType

export const ApiKeyType: typeof $Enums.ApiKeyType

export type VoiceModelStatus = $Enums.VoiceModelStatus

export const VoiceModelStatus: typeof $Enums.VoiceModelStatus

export type CallDirection = $Enums.CallDirection

export const CallDirection: typeof $Enums.CallDirection

export type CallStatus = $Enums.CallStatus

export const CallStatus: typeof $Enums.CallStatus

export type Sentiment = $Enums.Sentiment

export const Sentiment: typeof $Enums.Sentiment

export type Speaker = $Enums.Speaker

export const Speaker: typeof $Enums.Speaker

export type InboundCallStatus = $Enums.InboundCallStatus

export const InboundCallStatus: typeof $Enums.InboundCallStatus

export type OutboundCallStatus = $Enums.OutboundCallStatus

export const OutboundCallStatus: typeof $Enums.OutboundCallStatus

export type CallResult = $Enums.CallResult

export const CallResult: typeof $Enums.CallResult

export type ConditionType = $Enums.ConditionType

export const ConditionType: typeof $Enums.ConditionType

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type QueueStatus = $Enums.QueueStatus

export const QueueStatus: typeof $Enums.QueueStatus

export type CallbackStatus = $Enums.CallbackStatus

export const CallbackStatus: typeof $Enums.CallbackStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.voiceModel`: Exposes CRUD operations for the **VoiceModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoiceModels
    * const voiceModels = await prisma.voiceModel.findMany()
    * ```
    */
  get voiceModel(): Prisma.VoiceModelDelegate<ExtArgs>;

  /**
   * `prisma.trainingSample`: Exposes CRUD operations for the **TrainingSample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingSamples
    * const trainingSamples = await prisma.trainingSample.findMany()
    * ```
    */
  get trainingSample(): Prisma.TrainingSampleDelegate<ExtArgs>;

  /**
   * `prisma.callSession`: Exposes CRUD operations for the **CallSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallSessions
    * const callSessions = await prisma.callSession.findMany()
    * ```
    */
  get callSession(): Prisma.CallSessionDelegate<ExtArgs>;

  /**
   * `prisma.transcriptMessage`: Exposes CRUD operations for the **TranscriptMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranscriptMessages
    * const transcriptMessages = await prisma.transcriptMessage.findMany()
    * ```
    */
  get transcriptMessage(): Prisma.TranscriptMessageDelegate<ExtArgs>;

  /**
   * `prisma.callSummary`: Exposes CRUD operations for the **CallSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallSummaries
    * const callSummaries = await prisma.callSummary.findMany()
    * ```
    */
  get callSummary(): Prisma.CallSummaryDelegate<ExtArgs>;

  /**
   * `prisma.dailyAnalytics`: Exposes CRUD operations for the **DailyAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyAnalytics
    * const dailyAnalytics = await prisma.dailyAnalytics.findMany()
    * ```
    */
  get dailyAnalytics(): Prisma.DailyAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<ExtArgs>;

  /**
   * `prisma.inboundCall`: Exposes CRUD operations for the **InboundCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InboundCalls
    * const inboundCalls = await prisma.inboundCall.findMany()
    * ```
    */
  get inboundCall(): Prisma.InboundCallDelegate<ExtArgs>;

  /**
   * `prisma.outboundCall`: Exposes CRUD operations for the **OutboundCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutboundCalls
    * const outboundCalls = await prisma.outboundCall.findMany()
    * ```
    */
  get outboundCall(): Prisma.OutboundCallDelegate<ExtArgs>;

  /**
   * `prisma.callRoutingRule`: Exposes CRUD operations for the **CallRoutingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallRoutingRules
    * const callRoutingRules = await prisma.callRoutingRule.findMany()
    * ```
    */
  get callRoutingRule(): Prisma.CallRoutingRuleDelegate<ExtArgs>;

  /**
   * `prisma.outboundCampaign`: Exposes CRUD operations for the **OutboundCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutboundCampaigns
    * const outboundCampaigns = await prisma.outboundCampaign.findMany()
    * ```
    */
  get outboundCampaign(): Prisma.OutboundCampaignDelegate<ExtArgs>;

  /**
   * `prisma.callQueue`: Exposes CRUD operations for the **CallQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallQueues
    * const callQueues = await prisma.callQueue.findMany()
    * ```
    */
  get callQueue(): Prisma.CallQueueDelegate<ExtArgs>;

  /**
   * `prisma.callbackRequest`: Exposes CRUD operations for the **CallbackRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallbackRequests
    * const callbackRequests = await prisma.callbackRequest.findMany()
    * ```
    */
  get callbackRequest(): Prisma.CallbackRequestDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSettings: 'UserSettings',
    ApiKey: 'ApiKey',
    VoiceModel: 'VoiceModel',
    TrainingSample: 'TrainingSample',
    CallSession: 'CallSession',
    TranscriptMessage: 'TranscriptMessage',
    CallSummary: 'CallSummary',
    DailyAnalytics: 'DailyAnalytics',
    Business: 'Business',
    InboundCall: 'InboundCall',
    OutboundCall: 'OutboundCall',
    CallRoutingRule: 'CallRoutingRule',
    OutboundCampaign: 'OutboundCampaign',
    CallQueue: 'CallQueue',
    CallbackRequest: 'CallbackRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "userSettings" | "apiKey" | "voiceModel" | "trainingSample" | "callSession" | "transcriptMessage" | "callSummary" | "dailyAnalytics" | "business" | "inboundCall" | "outboundCall" | "callRoutingRule" | "outboundCampaign" | "callQueue" | "callbackRequest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      VoiceModel: {
        payload: Prisma.$VoiceModelPayload<ExtArgs>
        fields: Prisma.VoiceModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoiceModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoiceModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload>
          }
          findFirst: {
            args: Prisma.VoiceModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoiceModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload>
          }
          findMany: {
            args: Prisma.VoiceModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload>[]
          }
          create: {
            args: Prisma.VoiceModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload>
          }
          createMany: {
            args: Prisma.VoiceModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoiceModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload>[]
          }
          delete: {
            args: Prisma.VoiceModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload>
          }
          update: {
            args: Prisma.VoiceModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload>
          }
          deleteMany: {
            args: Prisma.VoiceModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoiceModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VoiceModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceModelPayload>
          }
          aggregate: {
            args: Prisma.VoiceModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoiceModel>
          }
          groupBy: {
            args: Prisma.VoiceModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoiceModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoiceModelCountArgs<ExtArgs>
            result: $Utils.Optional<VoiceModelCountAggregateOutputType> | number
          }
        }
      }
      TrainingSample: {
        payload: Prisma.$TrainingSamplePayload<ExtArgs>
        fields: Prisma.TrainingSampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingSampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingSampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload>
          }
          findFirst: {
            args: Prisma.TrainingSampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingSampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload>
          }
          findMany: {
            args: Prisma.TrainingSampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload>[]
          }
          create: {
            args: Prisma.TrainingSampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload>
          }
          createMany: {
            args: Prisma.TrainingSampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingSampleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload>[]
          }
          delete: {
            args: Prisma.TrainingSampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload>
          }
          update: {
            args: Prisma.TrainingSampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload>
          }
          deleteMany: {
            args: Prisma.TrainingSampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingSampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingSampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSamplePayload>
          }
          aggregate: {
            args: Prisma.TrainingSampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingSample>
          }
          groupBy: {
            args: Prisma.TrainingSampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingSampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingSampleCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingSampleCountAggregateOutputType> | number
          }
        }
      }
      CallSession: {
        payload: Prisma.$CallSessionPayload<ExtArgs>
        fields: Prisma.CallSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          findFirst: {
            args: Prisma.CallSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          findMany: {
            args: Prisma.CallSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>[]
          }
          create: {
            args: Prisma.CallSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          createMany: {
            args: Prisma.CallSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>[]
          }
          delete: {
            args: Prisma.CallSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          update: {
            args: Prisma.CallSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          deleteMany: {
            args: Prisma.CallSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CallSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          aggregate: {
            args: Prisma.CallSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallSession>
          }
          groupBy: {
            args: Prisma.CallSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CallSessionCountAggregateOutputType> | number
          }
        }
      }
      TranscriptMessage: {
        payload: Prisma.$TranscriptMessagePayload<ExtArgs>
        fields: Prisma.TranscriptMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload>
          }
          findFirst: {
            args: Prisma.TranscriptMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload>
          }
          findMany: {
            args: Prisma.TranscriptMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload>[]
          }
          create: {
            args: Prisma.TranscriptMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload>
          }
          createMany: {
            args: Prisma.TranscriptMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranscriptMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload>[]
          }
          delete: {
            args: Prisma.TranscriptMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload>
          }
          update: {
            args: Prisma.TranscriptMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload>
          }
          deleteMany: {
            args: Prisma.TranscriptMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranscriptMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptMessagePayload>
          }
          aggregate: {
            args: Prisma.TranscriptMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscriptMessage>
          }
          groupBy: {
            args: Prisma.TranscriptMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptMessageCountAggregateOutputType> | number
          }
        }
      }
      CallSummary: {
        payload: Prisma.$CallSummaryPayload<ExtArgs>
        fields: Prisma.CallSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload>
          }
          findFirst: {
            args: Prisma.CallSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload>
          }
          findMany: {
            args: Prisma.CallSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload>[]
          }
          create: {
            args: Prisma.CallSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload>
          }
          createMany: {
            args: Prisma.CallSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload>[]
          }
          delete: {
            args: Prisma.CallSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload>
          }
          update: {
            args: Prisma.CallSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload>
          }
          deleteMany: {
            args: Prisma.CallSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CallSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSummaryPayload>
          }
          aggregate: {
            args: Prisma.CallSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallSummary>
          }
          groupBy: {
            args: Prisma.CallSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<CallSummaryCountAggregateOutputType> | number
          }
        }
      }
      DailyAnalytics: {
        payload: Prisma.$DailyAnalyticsPayload<ExtArgs>
        fields: Prisma.DailyAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.DailyAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload>
          }
          findMany: {
            args: Prisma.DailyAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload>[]
          }
          create: {
            args: Prisma.DailyAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload>
          }
          createMany: {
            args: Prisma.DailyAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.DailyAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload>
          }
          update: {
            args: Prisma.DailyAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.DailyAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.DailyAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyAnalytics>
          }
          groupBy: {
            args: Prisma.DailyAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<DailyAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      Business: {
        payload: Prisma.$BusinessPayload<ExtArgs>
        fields: Prisma.BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      InboundCall: {
        payload: Prisma.$InboundCallPayload<ExtArgs>
        fields: Prisma.InboundCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InboundCallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InboundCallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload>
          }
          findFirst: {
            args: Prisma.InboundCallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InboundCallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload>
          }
          findMany: {
            args: Prisma.InboundCallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload>[]
          }
          create: {
            args: Prisma.InboundCallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload>
          }
          createMany: {
            args: Prisma.InboundCallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InboundCallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload>[]
          }
          delete: {
            args: Prisma.InboundCallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload>
          }
          update: {
            args: Prisma.InboundCallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload>
          }
          deleteMany: {
            args: Prisma.InboundCallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InboundCallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InboundCallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InboundCallPayload>
          }
          aggregate: {
            args: Prisma.InboundCallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInboundCall>
          }
          groupBy: {
            args: Prisma.InboundCallGroupByArgs<ExtArgs>
            result: $Utils.Optional<InboundCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.InboundCallCountArgs<ExtArgs>
            result: $Utils.Optional<InboundCallCountAggregateOutputType> | number
          }
        }
      }
      OutboundCall: {
        payload: Prisma.$OutboundCallPayload<ExtArgs>
        fields: Prisma.OutboundCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutboundCallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutboundCallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload>
          }
          findFirst: {
            args: Prisma.OutboundCallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutboundCallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload>
          }
          findMany: {
            args: Prisma.OutboundCallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload>[]
          }
          create: {
            args: Prisma.OutboundCallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload>
          }
          createMany: {
            args: Prisma.OutboundCallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutboundCallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload>[]
          }
          delete: {
            args: Prisma.OutboundCallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload>
          }
          update: {
            args: Prisma.OutboundCallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload>
          }
          deleteMany: {
            args: Prisma.OutboundCallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutboundCallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutboundCallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCallPayload>
          }
          aggregate: {
            args: Prisma.OutboundCallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutboundCall>
          }
          groupBy: {
            args: Prisma.OutboundCallGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutboundCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutboundCallCountArgs<ExtArgs>
            result: $Utils.Optional<OutboundCallCountAggregateOutputType> | number
          }
        }
      }
      CallRoutingRule: {
        payload: Prisma.$CallRoutingRulePayload<ExtArgs>
        fields: Prisma.CallRoutingRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallRoutingRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallRoutingRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload>
          }
          findFirst: {
            args: Prisma.CallRoutingRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallRoutingRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload>
          }
          findMany: {
            args: Prisma.CallRoutingRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload>[]
          }
          create: {
            args: Prisma.CallRoutingRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload>
          }
          createMany: {
            args: Prisma.CallRoutingRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallRoutingRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload>[]
          }
          delete: {
            args: Prisma.CallRoutingRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload>
          }
          update: {
            args: Prisma.CallRoutingRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload>
          }
          deleteMany: {
            args: Prisma.CallRoutingRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallRoutingRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CallRoutingRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRoutingRulePayload>
          }
          aggregate: {
            args: Prisma.CallRoutingRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallRoutingRule>
          }
          groupBy: {
            args: Prisma.CallRoutingRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallRoutingRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallRoutingRuleCountArgs<ExtArgs>
            result: $Utils.Optional<CallRoutingRuleCountAggregateOutputType> | number
          }
        }
      }
      OutboundCampaign: {
        payload: Prisma.$OutboundCampaignPayload<ExtArgs>
        fields: Prisma.OutboundCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutboundCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutboundCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload>
          }
          findFirst: {
            args: Prisma.OutboundCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutboundCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload>
          }
          findMany: {
            args: Prisma.OutboundCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload>[]
          }
          create: {
            args: Prisma.OutboundCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload>
          }
          createMany: {
            args: Prisma.OutboundCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutboundCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload>[]
          }
          delete: {
            args: Prisma.OutboundCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload>
          }
          update: {
            args: Prisma.OutboundCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload>
          }
          deleteMany: {
            args: Prisma.OutboundCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutboundCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutboundCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboundCampaignPayload>
          }
          aggregate: {
            args: Prisma.OutboundCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutboundCampaign>
          }
          groupBy: {
            args: Prisma.OutboundCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutboundCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutboundCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<OutboundCampaignCountAggregateOutputType> | number
          }
        }
      }
      CallQueue: {
        payload: Prisma.$CallQueuePayload<ExtArgs>
        fields: Prisma.CallQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload>
          }
          findFirst: {
            args: Prisma.CallQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload>
          }
          findMany: {
            args: Prisma.CallQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload>[]
          }
          create: {
            args: Prisma.CallQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload>
          }
          createMany: {
            args: Prisma.CallQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload>[]
          }
          delete: {
            args: Prisma.CallQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload>
          }
          update: {
            args: Prisma.CallQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload>
          }
          deleteMany: {
            args: Prisma.CallQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CallQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallQueuePayload>
          }
          aggregate: {
            args: Prisma.CallQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallQueue>
          }
          groupBy: {
            args: Prisma.CallQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallQueueCountArgs<ExtArgs>
            result: $Utils.Optional<CallQueueCountAggregateOutputType> | number
          }
        }
      }
      CallbackRequest: {
        payload: Prisma.$CallbackRequestPayload<ExtArgs>
        fields: Prisma.CallbackRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallbackRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallbackRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload>
          }
          findFirst: {
            args: Prisma.CallbackRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallbackRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload>
          }
          findMany: {
            args: Prisma.CallbackRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload>[]
          }
          create: {
            args: Prisma.CallbackRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload>
          }
          createMany: {
            args: Prisma.CallbackRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallbackRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload>[]
          }
          delete: {
            args: Prisma.CallbackRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload>
          }
          update: {
            args: Prisma.CallbackRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload>
          }
          deleteMany: {
            args: Prisma.CallbackRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallbackRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CallbackRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallbackRequestPayload>
          }
          aggregate: {
            args: Prisma.CallbackRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallbackRequest>
          }
          groupBy: {
            args: Prisma.CallbackRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallbackRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallbackRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CallbackRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    voiceModels: number
    callSessions: number
    trainingSamples: number
    apiKeys: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voiceModels?: boolean | UserCountOutputTypeCountVoiceModelsArgs
    callSessions?: boolean | UserCountOutputTypeCountCallSessionsArgs
    trainingSamples?: boolean | UserCountOutputTypeCountTrainingSamplesArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoiceModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoiceModelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCallSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainingSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSampleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }


  /**
   * Count Type VoiceModelCountOutputType
   */

  export type VoiceModelCountOutputType = {
    samples: number
    callSessions: number
  }

  export type VoiceModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    samples?: boolean | VoiceModelCountOutputTypeCountSamplesArgs
    callSessions?: boolean | VoiceModelCountOutputTypeCountCallSessionsArgs
  }

  // Custom InputTypes
  /**
   * VoiceModelCountOutputType without action
   */
  export type VoiceModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModelCountOutputType
     */
    select?: VoiceModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoiceModelCountOutputType without action
   */
  export type VoiceModelCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSampleWhereInput
  }

  /**
   * VoiceModelCountOutputType without action
   */
  export type VoiceModelCountOutputTypeCountCallSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallSessionWhereInput
  }


  /**
   * Count Type CallSessionCountOutputType
   */

  export type CallSessionCountOutputType = {
    transcript: number
  }

  export type CallSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transcript?: boolean | CallSessionCountOutputTypeCountTranscriptArgs
  }

  // Custom InputTypes
  /**
   * CallSessionCountOutputType without action
   */
  export type CallSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSessionCountOutputType
     */
    select?: CallSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CallSessionCountOutputType without action
   */
  export type CallSessionCountOutputTypeCountTranscriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptMessageWhereInput
  }


  /**
   * Count Type BusinessCountOutputType
   */

  export type BusinessCountOutputType = {
    inboundCalls: number
    outboundCalls: number
    routingRules: number
    campaigns: number
    callQueue: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inboundCalls?: boolean | BusinessCountOutputTypeCountInboundCallsArgs
    outboundCalls?: boolean | BusinessCountOutputTypeCountOutboundCallsArgs
    routingRules?: boolean | BusinessCountOutputTypeCountRoutingRulesArgs
    campaigns?: boolean | BusinessCountOutputTypeCountCampaignsArgs
    callQueue?: boolean | BusinessCountOutputTypeCountCallQueueArgs
  }

  // Custom InputTypes
  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountInboundCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InboundCallWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountOutboundCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundCallWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountRoutingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallRoutingRuleWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundCampaignWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountCallQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallQueueWhereInput
  }


  /**
   * Count Type OutboundCampaignCountOutputType
   */

  export type OutboundCampaignCountOutputType = {
    calls: number
  }

  export type OutboundCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calls?: boolean | OutboundCampaignCountOutputTypeCountCallsArgs
  }

  // Custom InputTypes
  /**
   * OutboundCampaignCountOutputType without action
   */
  export type OutboundCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaignCountOutputType
     */
    select?: OutboundCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OutboundCampaignCountOutputType without action
   */
  export type OutboundCampaignCountOutputTypeCountCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundCallWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    company: string | null
    phone: string | null
    plan: $Enums.Plan | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    company: string | null
    phone: string | null
    plan: $Enums.Plan | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    company: number
    phone: number
    plan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    company?: true
    phone?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    company?: true
    phone?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    company?: true
    phone?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    company: string | null
    phone: string | null
    plan: $Enums.Plan
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    company?: boolean
    phone?: boolean
    plan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    voiceModels?: boolean | User$voiceModelsArgs<ExtArgs>
    callSessions?: boolean | User$callSessionsArgs<ExtArgs>
    trainingSamples?: boolean | User$trainingSamplesArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    company?: boolean
    phone?: boolean
    plan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    company?: boolean
    phone?: boolean
    plan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voiceModels?: boolean | User$voiceModelsArgs<ExtArgs>
    callSessions?: boolean | User$callSessionsArgs<ExtArgs>
    trainingSamples?: boolean | User$trainingSamplesArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      voiceModels: Prisma.$VoiceModelPayload<ExtArgs>[]
      callSessions: Prisma.$CallSessionPayload<ExtArgs>[]
      trainingSamples: Prisma.$TrainingSamplePayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      company: string | null
      phone: string | null
      plan: $Enums.Plan
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    voiceModels<T extends User$voiceModelsArgs<ExtArgs> = {}>(args?: Subset<T, User$voiceModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "findMany"> | Null>
    callSessions<T extends User$callSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$callSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findMany"> | Null>
    trainingSamples<T extends User$trainingSamplesArgs<ExtArgs> = {}>(args?: Subset<T, User$trainingSamplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly company: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly plan: FieldRef<"User", 'Plan'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.voiceModels
   */
  export type User$voiceModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    where?: VoiceModelWhereInput
    orderBy?: VoiceModelOrderByWithRelationInput | VoiceModelOrderByWithRelationInput[]
    cursor?: VoiceModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoiceModelScalarFieldEnum | VoiceModelScalarFieldEnum[]
  }

  /**
   * User.callSessions
   */
  export type User$callSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    where?: CallSessionWhereInput
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    cursor?: CallSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallSessionScalarFieldEnum | CallSessionScalarFieldEnum[]
  }

  /**
   * User.trainingSamples
   */
  export type User$trainingSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    where?: TrainingSampleWhereInput
    orderBy?: TrainingSampleOrderByWithRelationInput | TrainingSampleOrderByWithRelationInput[]
    cursor?: TrainingSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingSampleScalarFieldEnum | TrainingSampleScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    callSummaries: boolean | null
    weeklyReports: boolean | null
    marketingEmails: boolean | null
    companyName: string | null
    industry: string | null
    greeting: string | null
    fallbackMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    callSummaries: boolean | null
    weeklyReports: boolean | null
    marketingEmails: boolean | null
    companyName: string | null
    industry: string | null
    greeting: string | null
    fallbackMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    emailNotifications: number
    smsNotifications: number
    callSummaries: number
    weeklyReports: number
    marketingEmails: number
    companyName: number
    industry: number
    greeting: number
    fallbackMessage: number
    businessHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    smsNotifications?: true
    callSummaries?: true
    weeklyReports?: true
    marketingEmails?: true
    companyName?: true
    industry?: true
    greeting?: true
    fallbackMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    smsNotifications?: true
    callSummaries?: true
    weeklyReports?: true
    marketingEmails?: true
    companyName?: true
    industry?: true
    greeting?: true
    fallbackMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    smsNotifications?: true
    callSummaries?: true
    weeklyReports?: true
    marketingEmails?: true
    companyName?: true
    industry?: true
    greeting?: true
    fallbackMessage?: true
    businessHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    emailNotifications: boolean
    smsNotifications: boolean
    callSummaries: boolean
    weeklyReports: boolean
    marketingEmails: boolean
    companyName: string | null
    industry: string | null
    greeting: string | null
    fallbackMessage: string | null
    businessHours: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    callSummaries?: boolean
    weeklyReports?: boolean
    marketingEmails?: boolean
    companyName?: boolean
    industry?: boolean
    greeting?: boolean
    fallbackMessage?: boolean
    businessHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    callSummaries?: boolean
    weeklyReports?: boolean
    marketingEmails?: boolean
    companyName?: boolean
    industry?: boolean
    greeting?: boolean
    fallbackMessage?: boolean
    businessHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    callSummaries?: boolean
    weeklyReports?: boolean
    marketingEmails?: boolean
    companyName?: boolean
    industry?: boolean
    greeting?: boolean
    fallbackMessage?: boolean
    businessHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailNotifications: boolean
      smsNotifications: boolean
      callSummaries: boolean
      weeklyReports: boolean
      marketingEmails: boolean
      companyName: string | null
      industry: string | null
      greeting: string | null
      fallbackMessage: string | null
      businessHours: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */ 
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly emailNotifications: FieldRef<"UserSettings", 'Boolean'>
    readonly smsNotifications: FieldRef<"UserSettings", 'Boolean'>
    readonly callSummaries: FieldRef<"UserSettings", 'Boolean'>
    readonly weeklyReports: FieldRef<"UserSettings", 'Boolean'>
    readonly marketingEmails: FieldRef<"UserSettings", 'Boolean'>
    readonly companyName: FieldRef<"UserSettings", 'String'>
    readonly industry: FieldRef<"UserSettings", 'String'>
    readonly greeting: FieldRef<"UserSettings", 'String'>
    readonly fallbackMessage: FieldRef<"UserSettings", 'String'>
    readonly businessHours: FieldRef<"UserSettings", 'Json'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    key: string | null
    name: string | null
    type: $Enums.ApiKeyType | null
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    key: string | null
    name: string | null
    type: $Enums.ApiKeyType | null
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    key: number
    name: number
    type: number
    lastUsed: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    name?: true
    type?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    name?: true
    type?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    name?: true
    type?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    userId: string
    key: string
    name: string
    type: $Enums.ApiKeyType
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    key?: boolean
    name?: boolean
    type?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    key?: boolean
    name?: boolean
    type?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    key?: boolean
    name?: boolean
    type?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      key: string
      name: string
      type: $Enums.ApiKeyType
      lastUsed: Date | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly type: FieldRef<"ApiKey", 'ApiKeyType'>
    readonly lastUsed: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model VoiceModel
   */

  export type AggregateVoiceModel = {
    _count: VoiceModelCountAggregateOutputType | null
    _avg: VoiceModelAvgAggregateOutputType | null
    _sum: VoiceModelSumAggregateOutputType | null
    _min: VoiceModelMinAggregateOutputType | null
    _max: VoiceModelMaxAggregateOutputType | null
  }

  export type VoiceModelAvgAggregateOutputType = {
    friendliness: number | null
    professionalism: number | null
    energy: number | null
    formality: number | null
  }

  export type VoiceModelSumAggregateOutputType = {
    friendliness: number | null
    professionalism: number | null
    energy: number | null
    formality: number | null
  }

  export type VoiceModelMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    status: $Enums.VoiceModelStatus | null
    friendliness: number | null
    professionalism: number | null
    energy: number | null
    formality: number | null
    externalVoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoiceModelMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    status: $Enums.VoiceModelStatus | null
    friendliness: number | null
    professionalism: number | null
    energy: number | null
    formality: number | null
    externalVoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoiceModelCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    status: number
    friendliness: number
    professionalism: number
    energy: number
    formality: number
    externalVoiceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoiceModelAvgAggregateInputType = {
    friendliness?: true
    professionalism?: true
    energy?: true
    formality?: true
  }

  export type VoiceModelSumAggregateInputType = {
    friendliness?: true
    professionalism?: true
    energy?: true
    formality?: true
  }

  export type VoiceModelMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    status?: true
    friendliness?: true
    professionalism?: true
    energy?: true
    formality?: true
    externalVoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoiceModelMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    status?: true
    friendliness?: true
    professionalism?: true
    energy?: true
    formality?: true
    externalVoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoiceModelCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    status?: true
    friendliness?: true
    professionalism?: true
    energy?: true
    formality?: true
    externalVoiceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoiceModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoiceModel to aggregate.
     */
    where?: VoiceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceModels to fetch.
     */
    orderBy?: VoiceModelOrderByWithRelationInput | VoiceModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoiceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoiceModels
    **/
    _count?: true | VoiceModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoiceModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoiceModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoiceModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoiceModelMaxAggregateInputType
  }

  export type GetVoiceModelAggregateType<T extends VoiceModelAggregateArgs> = {
        [P in keyof T & keyof AggregateVoiceModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoiceModel[P]>
      : GetScalarType<T[P], AggregateVoiceModel[P]>
  }




  export type VoiceModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoiceModelWhereInput
    orderBy?: VoiceModelOrderByWithAggregationInput | VoiceModelOrderByWithAggregationInput[]
    by: VoiceModelScalarFieldEnum[] | VoiceModelScalarFieldEnum
    having?: VoiceModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoiceModelCountAggregateInputType | true
    _avg?: VoiceModelAvgAggregateInputType
    _sum?: VoiceModelSumAggregateInputType
    _min?: VoiceModelMinAggregateInputType
    _max?: VoiceModelMaxAggregateInputType
  }

  export type VoiceModelGroupByOutputType = {
    id: string
    userId: string
    name: string
    status: $Enums.VoiceModelStatus
    friendliness: number
    professionalism: number
    energy: number
    formality: number
    externalVoiceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: VoiceModelCountAggregateOutputType | null
    _avg: VoiceModelAvgAggregateOutputType | null
    _sum: VoiceModelSumAggregateOutputType | null
    _min: VoiceModelMinAggregateOutputType | null
    _max: VoiceModelMaxAggregateOutputType | null
  }

  type GetVoiceModelGroupByPayload<T extends VoiceModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoiceModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoiceModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoiceModelGroupByOutputType[P]>
            : GetScalarType<T[P], VoiceModelGroupByOutputType[P]>
        }
      >
    >


  export type VoiceModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    status?: boolean
    friendliness?: boolean
    professionalism?: boolean
    energy?: boolean
    formality?: boolean
    externalVoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    samples?: boolean | VoiceModel$samplesArgs<ExtArgs>
    callSessions?: boolean | VoiceModel$callSessionsArgs<ExtArgs>
    _count?: boolean | VoiceModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceModel"]>

  export type VoiceModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    status?: boolean
    friendliness?: boolean
    professionalism?: boolean
    energy?: boolean
    formality?: boolean
    externalVoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceModel"]>

  export type VoiceModelSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    status?: boolean
    friendliness?: boolean
    professionalism?: boolean
    energy?: boolean
    formality?: boolean
    externalVoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoiceModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    samples?: boolean | VoiceModel$samplesArgs<ExtArgs>
    callSessions?: boolean | VoiceModel$callSessionsArgs<ExtArgs>
    _count?: boolean | VoiceModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoiceModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VoiceModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoiceModel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      samples: Prisma.$TrainingSamplePayload<ExtArgs>[]
      callSessions: Prisma.$CallSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      status: $Enums.VoiceModelStatus
      friendliness: number
      professionalism: number
      energy: number
      formality: number
      externalVoiceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["voiceModel"]>
    composites: {}
  }

  type VoiceModelGetPayload<S extends boolean | null | undefined | VoiceModelDefaultArgs> = $Result.GetResult<Prisma.$VoiceModelPayload, S>

  type VoiceModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VoiceModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VoiceModelCountAggregateInputType | true
    }

  export interface VoiceModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoiceModel'], meta: { name: 'VoiceModel' } }
    /**
     * Find zero or one VoiceModel that matches the filter.
     * @param {VoiceModelFindUniqueArgs} args - Arguments to find a VoiceModel
     * @example
     * // Get one VoiceModel
     * const voiceModel = await prisma.voiceModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoiceModelFindUniqueArgs>(args: SelectSubset<T, VoiceModelFindUniqueArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VoiceModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VoiceModelFindUniqueOrThrowArgs} args - Arguments to find a VoiceModel
     * @example
     * // Get one VoiceModel
     * const voiceModel = await prisma.voiceModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoiceModelFindUniqueOrThrowArgs>(args: SelectSubset<T, VoiceModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VoiceModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceModelFindFirstArgs} args - Arguments to find a VoiceModel
     * @example
     * // Get one VoiceModel
     * const voiceModel = await prisma.voiceModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoiceModelFindFirstArgs>(args?: SelectSubset<T, VoiceModelFindFirstArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VoiceModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceModelFindFirstOrThrowArgs} args - Arguments to find a VoiceModel
     * @example
     * // Get one VoiceModel
     * const voiceModel = await prisma.voiceModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoiceModelFindFirstOrThrowArgs>(args?: SelectSubset<T, VoiceModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VoiceModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoiceModels
     * const voiceModels = await prisma.voiceModel.findMany()
     * 
     * // Get first 10 VoiceModels
     * const voiceModels = await prisma.voiceModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voiceModelWithIdOnly = await prisma.voiceModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoiceModelFindManyArgs>(args?: SelectSubset<T, VoiceModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VoiceModel.
     * @param {VoiceModelCreateArgs} args - Arguments to create a VoiceModel.
     * @example
     * // Create one VoiceModel
     * const VoiceModel = await prisma.voiceModel.create({
     *   data: {
     *     // ... data to create a VoiceModel
     *   }
     * })
     * 
     */
    create<T extends VoiceModelCreateArgs>(args: SelectSubset<T, VoiceModelCreateArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VoiceModels.
     * @param {VoiceModelCreateManyArgs} args - Arguments to create many VoiceModels.
     * @example
     * // Create many VoiceModels
     * const voiceModel = await prisma.voiceModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoiceModelCreateManyArgs>(args?: SelectSubset<T, VoiceModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoiceModels and returns the data saved in the database.
     * @param {VoiceModelCreateManyAndReturnArgs} args - Arguments to create many VoiceModels.
     * @example
     * // Create many VoiceModels
     * const voiceModel = await prisma.voiceModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoiceModels and only return the `id`
     * const voiceModelWithIdOnly = await prisma.voiceModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoiceModelCreateManyAndReturnArgs>(args?: SelectSubset<T, VoiceModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VoiceModel.
     * @param {VoiceModelDeleteArgs} args - Arguments to delete one VoiceModel.
     * @example
     * // Delete one VoiceModel
     * const VoiceModel = await prisma.voiceModel.delete({
     *   where: {
     *     // ... filter to delete one VoiceModel
     *   }
     * })
     * 
     */
    delete<T extends VoiceModelDeleteArgs>(args: SelectSubset<T, VoiceModelDeleteArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VoiceModel.
     * @param {VoiceModelUpdateArgs} args - Arguments to update one VoiceModel.
     * @example
     * // Update one VoiceModel
     * const voiceModel = await prisma.voiceModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoiceModelUpdateArgs>(args: SelectSubset<T, VoiceModelUpdateArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VoiceModels.
     * @param {VoiceModelDeleteManyArgs} args - Arguments to filter VoiceModels to delete.
     * @example
     * // Delete a few VoiceModels
     * const { count } = await prisma.voiceModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoiceModelDeleteManyArgs>(args?: SelectSubset<T, VoiceModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoiceModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoiceModels
     * const voiceModel = await prisma.voiceModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoiceModelUpdateManyArgs>(args: SelectSubset<T, VoiceModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VoiceModel.
     * @param {VoiceModelUpsertArgs} args - Arguments to update or create a VoiceModel.
     * @example
     * // Update or create a VoiceModel
     * const voiceModel = await prisma.voiceModel.upsert({
     *   create: {
     *     // ... data to create a VoiceModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoiceModel we want to update
     *   }
     * })
     */
    upsert<T extends VoiceModelUpsertArgs>(args: SelectSubset<T, VoiceModelUpsertArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VoiceModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceModelCountArgs} args - Arguments to filter VoiceModels to count.
     * @example
     * // Count the number of VoiceModels
     * const count = await prisma.voiceModel.count({
     *   where: {
     *     // ... the filter for the VoiceModels we want to count
     *   }
     * })
    **/
    count<T extends VoiceModelCountArgs>(
      args?: Subset<T, VoiceModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoiceModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoiceModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoiceModelAggregateArgs>(args: Subset<T, VoiceModelAggregateArgs>): Prisma.PrismaPromise<GetVoiceModelAggregateType<T>>

    /**
     * Group by VoiceModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoiceModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoiceModelGroupByArgs['orderBy'] }
        : { orderBy?: VoiceModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoiceModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoiceModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoiceModel model
   */
  readonly fields: VoiceModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoiceModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoiceModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    samples<T extends VoiceModel$samplesArgs<ExtArgs> = {}>(args?: Subset<T, VoiceModel$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "findMany"> | Null>
    callSessions<T extends VoiceModel$callSessionsArgs<ExtArgs> = {}>(args?: Subset<T, VoiceModel$callSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoiceModel model
   */ 
  interface VoiceModelFieldRefs {
    readonly id: FieldRef<"VoiceModel", 'String'>
    readonly userId: FieldRef<"VoiceModel", 'String'>
    readonly name: FieldRef<"VoiceModel", 'String'>
    readonly status: FieldRef<"VoiceModel", 'VoiceModelStatus'>
    readonly friendliness: FieldRef<"VoiceModel", 'Int'>
    readonly professionalism: FieldRef<"VoiceModel", 'Int'>
    readonly energy: FieldRef<"VoiceModel", 'Int'>
    readonly formality: FieldRef<"VoiceModel", 'Int'>
    readonly externalVoiceId: FieldRef<"VoiceModel", 'String'>
    readonly createdAt: FieldRef<"VoiceModel", 'DateTime'>
    readonly updatedAt: FieldRef<"VoiceModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoiceModel findUnique
   */
  export type VoiceModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * Filter, which VoiceModel to fetch.
     */
    where: VoiceModelWhereUniqueInput
  }

  /**
   * VoiceModel findUniqueOrThrow
   */
  export type VoiceModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * Filter, which VoiceModel to fetch.
     */
    where: VoiceModelWhereUniqueInput
  }

  /**
   * VoiceModel findFirst
   */
  export type VoiceModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * Filter, which VoiceModel to fetch.
     */
    where?: VoiceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceModels to fetch.
     */
    orderBy?: VoiceModelOrderByWithRelationInput | VoiceModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceModels.
     */
    cursor?: VoiceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceModels.
     */
    distinct?: VoiceModelScalarFieldEnum | VoiceModelScalarFieldEnum[]
  }

  /**
   * VoiceModel findFirstOrThrow
   */
  export type VoiceModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * Filter, which VoiceModel to fetch.
     */
    where?: VoiceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceModels to fetch.
     */
    orderBy?: VoiceModelOrderByWithRelationInput | VoiceModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceModels.
     */
    cursor?: VoiceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceModels.
     */
    distinct?: VoiceModelScalarFieldEnum | VoiceModelScalarFieldEnum[]
  }

  /**
   * VoiceModel findMany
   */
  export type VoiceModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * Filter, which VoiceModels to fetch.
     */
    where?: VoiceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceModels to fetch.
     */
    orderBy?: VoiceModelOrderByWithRelationInput | VoiceModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoiceModels.
     */
    cursor?: VoiceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceModels.
     */
    skip?: number
    distinct?: VoiceModelScalarFieldEnum | VoiceModelScalarFieldEnum[]
  }

  /**
   * VoiceModel create
   */
  export type VoiceModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * The data needed to create a VoiceModel.
     */
    data: XOR<VoiceModelCreateInput, VoiceModelUncheckedCreateInput>
  }

  /**
   * VoiceModel createMany
   */
  export type VoiceModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoiceModels.
     */
    data: VoiceModelCreateManyInput | VoiceModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoiceModel createManyAndReturn
   */
  export type VoiceModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VoiceModels.
     */
    data: VoiceModelCreateManyInput | VoiceModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoiceModel update
   */
  export type VoiceModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * The data needed to update a VoiceModel.
     */
    data: XOR<VoiceModelUpdateInput, VoiceModelUncheckedUpdateInput>
    /**
     * Choose, which VoiceModel to update.
     */
    where: VoiceModelWhereUniqueInput
  }

  /**
   * VoiceModel updateMany
   */
  export type VoiceModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoiceModels.
     */
    data: XOR<VoiceModelUpdateManyMutationInput, VoiceModelUncheckedUpdateManyInput>
    /**
     * Filter which VoiceModels to update
     */
    where?: VoiceModelWhereInput
  }

  /**
   * VoiceModel upsert
   */
  export type VoiceModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * The filter to search for the VoiceModel to update in case it exists.
     */
    where: VoiceModelWhereUniqueInput
    /**
     * In case the VoiceModel found by the `where` argument doesn't exist, create a new VoiceModel with this data.
     */
    create: XOR<VoiceModelCreateInput, VoiceModelUncheckedCreateInput>
    /**
     * In case the VoiceModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoiceModelUpdateInput, VoiceModelUncheckedUpdateInput>
  }

  /**
   * VoiceModel delete
   */
  export type VoiceModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    /**
     * Filter which VoiceModel to delete.
     */
    where: VoiceModelWhereUniqueInput
  }

  /**
   * VoiceModel deleteMany
   */
  export type VoiceModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoiceModels to delete
     */
    where?: VoiceModelWhereInput
  }

  /**
   * VoiceModel.samples
   */
  export type VoiceModel$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    where?: TrainingSampleWhereInput
    orderBy?: TrainingSampleOrderByWithRelationInput | TrainingSampleOrderByWithRelationInput[]
    cursor?: TrainingSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingSampleScalarFieldEnum | TrainingSampleScalarFieldEnum[]
  }

  /**
   * VoiceModel.callSessions
   */
  export type VoiceModel$callSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    where?: CallSessionWhereInput
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    cursor?: CallSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallSessionScalarFieldEnum | CallSessionScalarFieldEnum[]
  }

  /**
   * VoiceModel without action
   */
  export type VoiceModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
  }


  /**
   * Model TrainingSample
   */

  export type AggregateTrainingSample = {
    _count: TrainingSampleCountAggregateOutputType | null
    _avg: TrainingSampleAvgAggregateOutputType | null
    _sum: TrainingSampleSumAggregateOutputType | null
    _min: TrainingSampleMinAggregateOutputType | null
    _max: TrainingSampleMaxAggregateOutputType | null
  }

  export type TrainingSampleAvgAggregateOutputType = {
    fileSize: number | null
    duration: number | null
  }

  export type TrainingSampleSumAggregateOutputType = {
    fileSize: number | null
    duration: number | null
  }

  export type TrainingSampleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    voiceModelId: string | null
    filename: string | null
    originalName: string | null
    fileSize: number | null
    duration: number | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type TrainingSampleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    voiceModelId: string | null
    filename: string | null
    originalName: string | null
    fileSize: number | null
    duration: number | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type TrainingSampleCountAggregateOutputType = {
    id: number
    userId: number
    voiceModelId: number
    filename: number
    originalName: number
    fileSize: number
    duration: number
    mimeType: number
    createdAt: number
    _all: number
  }


  export type TrainingSampleAvgAggregateInputType = {
    fileSize?: true
    duration?: true
  }

  export type TrainingSampleSumAggregateInputType = {
    fileSize?: true
    duration?: true
  }

  export type TrainingSampleMinAggregateInputType = {
    id?: true
    userId?: true
    voiceModelId?: true
    filename?: true
    originalName?: true
    fileSize?: true
    duration?: true
    mimeType?: true
    createdAt?: true
  }

  export type TrainingSampleMaxAggregateInputType = {
    id?: true
    userId?: true
    voiceModelId?: true
    filename?: true
    originalName?: true
    fileSize?: true
    duration?: true
    mimeType?: true
    createdAt?: true
  }

  export type TrainingSampleCountAggregateInputType = {
    id?: true
    userId?: true
    voiceModelId?: true
    filename?: true
    originalName?: true
    fileSize?: true
    duration?: true
    mimeType?: true
    createdAt?: true
    _all?: true
  }

  export type TrainingSampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSample to aggregate.
     */
    where?: TrainingSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSamples to fetch.
     */
    orderBy?: TrainingSampleOrderByWithRelationInput | TrainingSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingSamples
    **/
    _count?: true | TrainingSampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingSampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingSampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingSampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingSampleMaxAggregateInputType
  }

  export type GetTrainingSampleAggregateType<T extends TrainingSampleAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingSample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingSample[P]>
      : GetScalarType<T[P], AggregateTrainingSample[P]>
  }




  export type TrainingSampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSampleWhereInput
    orderBy?: TrainingSampleOrderByWithAggregationInput | TrainingSampleOrderByWithAggregationInput[]
    by: TrainingSampleScalarFieldEnum[] | TrainingSampleScalarFieldEnum
    having?: TrainingSampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingSampleCountAggregateInputType | true
    _avg?: TrainingSampleAvgAggregateInputType
    _sum?: TrainingSampleSumAggregateInputType
    _min?: TrainingSampleMinAggregateInputType
    _max?: TrainingSampleMaxAggregateInputType
  }

  export type TrainingSampleGroupByOutputType = {
    id: string
    userId: string
    voiceModelId: string | null
    filename: string
    originalName: string
    fileSize: number
    duration: number | null
    mimeType: string
    createdAt: Date
    _count: TrainingSampleCountAggregateOutputType | null
    _avg: TrainingSampleAvgAggregateOutputType | null
    _sum: TrainingSampleSumAggregateOutputType | null
    _min: TrainingSampleMinAggregateOutputType | null
    _max: TrainingSampleMaxAggregateOutputType | null
  }

  type GetTrainingSampleGroupByPayload<T extends TrainingSampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingSampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingSampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingSampleGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingSampleGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    voiceModelId?: boolean
    filename?: boolean
    originalName?: boolean
    fileSize?: boolean
    duration?: boolean
    mimeType?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    voiceModel?: boolean | TrainingSample$voiceModelArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSample"]>

  export type TrainingSampleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    voiceModelId?: boolean
    filename?: boolean
    originalName?: boolean
    fileSize?: boolean
    duration?: boolean
    mimeType?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    voiceModel?: boolean | TrainingSample$voiceModelArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSample"]>

  export type TrainingSampleSelectScalar = {
    id?: boolean
    userId?: boolean
    voiceModelId?: boolean
    filename?: boolean
    originalName?: boolean
    fileSize?: boolean
    duration?: boolean
    mimeType?: boolean
    createdAt?: boolean
  }

  export type TrainingSampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    voiceModel?: boolean | TrainingSample$voiceModelArgs<ExtArgs>
  }
  export type TrainingSampleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    voiceModel?: boolean | TrainingSample$voiceModelArgs<ExtArgs>
  }

  export type $TrainingSamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingSample"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      voiceModel: Prisma.$VoiceModelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      voiceModelId: string | null
      filename: string
      originalName: string
      fileSize: number
      duration: number | null
      mimeType: string
      createdAt: Date
    }, ExtArgs["result"]["trainingSample"]>
    composites: {}
  }

  type TrainingSampleGetPayload<S extends boolean | null | undefined | TrainingSampleDefaultArgs> = $Result.GetResult<Prisma.$TrainingSamplePayload, S>

  type TrainingSampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingSampleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingSampleCountAggregateInputType | true
    }

  export interface TrainingSampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingSample'], meta: { name: 'TrainingSample' } }
    /**
     * Find zero or one TrainingSample that matches the filter.
     * @param {TrainingSampleFindUniqueArgs} args - Arguments to find a TrainingSample
     * @example
     * // Get one TrainingSample
     * const trainingSample = await prisma.trainingSample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingSampleFindUniqueArgs>(args: SelectSubset<T, TrainingSampleFindUniqueArgs<ExtArgs>>): Prisma__TrainingSampleClient<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingSample that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingSampleFindUniqueOrThrowArgs} args - Arguments to find a TrainingSample
     * @example
     * // Get one TrainingSample
     * const trainingSample = await prisma.trainingSample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingSampleFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingSampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingSampleClient<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingSample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSampleFindFirstArgs} args - Arguments to find a TrainingSample
     * @example
     * // Get one TrainingSample
     * const trainingSample = await prisma.trainingSample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingSampleFindFirstArgs>(args?: SelectSubset<T, TrainingSampleFindFirstArgs<ExtArgs>>): Prisma__TrainingSampleClient<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingSample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSampleFindFirstOrThrowArgs} args - Arguments to find a TrainingSample
     * @example
     * // Get one TrainingSample
     * const trainingSample = await prisma.trainingSample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingSampleFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingSampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingSampleClient<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingSamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingSamples
     * const trainingSamples = await prisma.trainingSample.findMany()
     * 
     * // Get first 10 TrainingSamples
     * const trainingSamples = await prisma.trainingSample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingSampleWithIdOnly = await prisma.trainingSample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingSampleFindManyArgs>(args?: SelectSubset<T, TrainingSampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingSample.
     * @param {TrainingSampleCreateArgs} args - Arguments to create a TrainingSample.
     * @example
     * // Create one TrainingSample
     * const TrainingSample = await prisma.trainingSample.create({
     *   data: {
     *     // ... data to create a TrainingSample
     *   }
     * })
     * 
     */
    create<T extends TrainingSampleCreateArgs>(args: SelectSubset<T, TrainingSampleCreateArgs<ExtArgs>>): Prisma__TrainingSampleClient<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingSamples.
     * @param {TrainingSampleCreateManyArgs} args - Arguments to create many TrainingSamples.
     * @example
     * // Create many TrainingSamples
     * const trainingSample = await prisma.trainingSample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingSampleCreateManyArgs>(args?: SelectSubset<T, TrainingSampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingSamples and returns the data saved in the database.
     * @param {TrainingSampleCreateManyAndReturnArgs} args - Arguments to create many TrainingSamples.
     * @example
     * // Create many TrainingSamples
     * const trainingSample = await prisma.trainingSample.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingSamples and only return the `id`
     * const trainingSampleWithIdOnly = await prisma.trainingSample.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingSampleCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingSampleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainingSample.
     * @param {TrainingSampleDeleteArgs} args - Arguments to delete one TrainingSample.
     * @example
     * // Delete one TrainingSample
     * const TrainingSample = await prisma.trainingSample.delete({
     *   where: {
     *     // ... filter to delete one TrainingSample
     *   }
     * })
     * 
     */
    delete<T extends TrainingSampleDeleteArgs>(args: SelectSubset<T, TrainingSampleDeleteArgs<ExtArgs>>): Prisma__TrainingSampleClient<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingSample.
     * @param {TrainingSampleUpdateArgs} args - Arguments to update one TrainingSample.
     * @example
     * // Update one TrainingSample
     * const trainingSample = await prisma.trainingSample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingSampleUpdateArgs>(args: SelectSubset<T, TrainingSampleUpdateArgs<ExtArgs>>): Prisma__TrainingSampleClient<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingSamples.
     * @param {TrainingSampleDeleteManyArgs} args - Arguments to filter TrainingSamples to delete.
     * @example
     * // Delete a few TrainingSamples
     * const { count } = await prisma.trainingSample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingSampleDeleteManyArgs>(args?: SelectSubset<T, TrainingSampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingSamples
     * const trainingSample = await prisma.trainingSample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingSampleUpdateManyArgs>(args: SelectSubset<T, TrainingSampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingSample.
     * @param {TrainingSampleUpsertArgs} args - Arguments to update or create a TrainingSample.
     * @example
     * // Update or create a TrainingSample
     * const trainingSample = await prisma.trainingSample.upsert({
     *   create: {
     *     // ... data to create a TrainingSample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingSample we want to update
     *   }
     * })
     */
    upsert<T extends TrainingSampleUpsertArgs>(args: SelectSubset<T, TrainingSampleUpsertArgs<ExtArgs>>): Prisma__TrainingSampleClient<$Result.GetResult<Prisma.$TrainingSamplePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainingSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSampleCountArgs} args - Arguments to filter TrainingSamples to count.
     * @example
     * // Count the number of TrainingSamples
     * const count = await prisma.trainingSample.count({
     *   where: {
     *     // ... the filter for the TrainingSamples we want to count
     *   }
     * })
    **/
    count<T extends TrainingSampleCountArgs>(
      args?: Subset<T, TrainingSampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingSampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingSampleAggregateArgs>(args: Subset<T, TrainingSampleAggregateArgs>): Prisma.PrismaPromise<GetTrainingSampleAggregateType<T>>

    /**
     * Group by TrainingSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingSampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingSampleGroupByArgs['orderBy'] }
        : { orderBy?: TrainingSampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingSampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingSampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingSample model
   */
  readonly fields: TrainingSampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingSample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingSampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    voiceModel<T extends TrainingSample$voiceModelArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSample$voiceModelArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingSample model
   */ 
  interface TrainingSampleFieldRefs {
    readonly id: FieldRef<"TrainingSample", 'String'>
    readonly userId: FieldRef<"TrainingSample", 'String'>
    readonly voiceModelId: FieldRef<"TrainingSample", 'String'>
    readonly filename: FieldRef<"TrainingSample", 'String'>
    readonly originalName: FieldRef<"TrainingSample", 'String'>
    readonly fileSize: FieldRef<"TrainingSample", 'Int'>
    readonly duration: FieldRef<"TrainingSample", 'Float'>
    readonly mimeType: FieldRef<"TrainingSample", 'String'>
    readonly createdAt: FieldRef<"TrainingSample", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingSample findUnique
   */
  export type TrainingSampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSample to fetch.
     */
    where: TrainingSampleWhereUniqueInput
  }

  /**
   * TrainingSample findUniqueOrThrow
   */
  export type TrainingSampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSample to fetch.
     */
    where: TrainingSampleWhereUniqueInput
  }

  /**
   * TrainingSample findFirst
   */
  export type TrainingSampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSample to fetch.
     */
    where?: TrainingSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSamples to fetch.
     */
    orderBy?: TrainingSampleOrderByWithRelationInput | TrainingSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSamples.
     */
    cursor?: TrainingSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSamples.
     */
    distinct?: TrainingSampleScalarFieldEnum | TrainingSampleScalarFieldEnum[]
  }

  /**
   * TrainingSample findFirstOrThrow
   */
  export type TrainingSampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSample to fetch.
     */
    where?: TrainingSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSamples to fetch.
     */
    orderBy?: TrainingSampleOrderByWithRelationInput | TrainingSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSamples.
     */
    cursor?: TrainingSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSamples.
     */
    distinct?: TrainingSampleScalarFieldEnum | TrainingSampleScalarFieldEnum[]
  }

  /**
   * TrainingSample findMany
   */
  export type TrainingSampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSamples to fetch.
     */
    where?: TrainingSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSamples to fetch.
     */
    orderBy?: TrainingSampleOrderByWithRelationInput | TrainingSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingSamples.
     */
    cursor?: TrainingSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSamples.
     */
    skip?: number
    distinct?: TrainingSampleScalarFieldEnum | TrainingSampleScalarFieldEnum[]
  }

  /**
   * TrainingSample create
   */
  export type TrainingSampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingSample.
     */
    data: XOR<TrainingSampleCreateInput, TrainingSampleUncheckedCreateInput>
  }

  /**
   * TrainingSample createMany
   */
  export type TrainingSampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingSamples.
     */
    data: TrainingSampleCreateManyInput | TrainingSampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingSample createManyAndReturn
   */
  export type TrainingSampleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainingSamples.
     */
    data: TrainingSampleCreateManyInput | TrainingSampleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingSample update
   */
  export type TrainingSampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingSample.
     */
    data: XOR<TrainingSampleUpdateInput, TrainingSampleUncheckedUpdateInput>
    /**
     * Choose, which TrainingSample to update.
     */
    where: TrainingSampleWhereUniqueInput
  }

  /**
   * TrainingSample updateMany
   */
  export type TrainingSampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingSamples.
     */
    data: XOR<TrainingSampleUpdateManyMutationInput, TrainingSampleUncheckedUpdateManyInput>
    /**
     * Filter which TrainingSamples to update
     */
    where?: TrainingSampleWhereInput
  }

  /**
   * TrainingSample upsert
   */
  export type TrainingSampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingSample to update in case it exists.
     */
    where: TrainingSampleWhereUniqueInput
    /**
     * In case the TrainingSample found by the `where` argument doesn't exist, create a new TrainingSample with this data.
     */
    create: XOR<TrainingSampleCreateInput, TrainingSampleUncheckedCreateInput>
    /**
     * In case the TrainingSample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingSampleUpdateInput, TrainingSampleUncheckedUpdateInput>
  }

  /**
   * TrainingSample delete
   */
  export type TrainingSampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
    /**
     * Filter which TrainingSample to delete.
     */
    where: TrainingSampleWhereUniqueInput
  }

  /**
   * TrainingSample deleteMany
   */
  export type TrainingSampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSamples to delete
     */
    where?: TrainingSampleWhereInput
  }

  /**
   * TrainingSample.voiceModel
   */
  export type TrainingSample$voiceModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    where?: VoiceModelWhereInput
  }

  /**
   * TrainingSample without action
   */
  export type TrainingSampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSample
     */
    select?: TrainingSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSampleInclude<ExtArgs> | null
  }


  /**
   * Model CallSession
   */

  export type AggregateCallSession = {
    _count: CallSessionCountAggregateOutputType | null
    _avg: CallSessionAvgAggregateOutputType | null
    _sum: CallSessionSumAggregateOutputType | null
    _min: CallSessionMinAggregateOutputType | null
    _max: CallSessionMaxAggregateOutputType | null
  }

  export type CallSessionAvgAggregateOutputType = {
    duration: number | null
  }

  export type CallSessionSumAggregateOutputType = {
    duration: number | null
  }

  export type CallSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    voiceModelId: string | null
    phoneNumber: string | null
    direction: $Enums.CallDirection | null
    status: $Enums.CallStatus | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    sentiment: $Enums.Sentiment | null
    externalCallId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    voiceModelId: string | null
    phoneNumber: string | null
    direction: $Enums.CallDirection | null
    status: $Enums.CallStatus | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    sentiment: $Enums.Sentiment | null
    externalCallId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallSessionCountAggregateOutputType = {
    id: number
    userId: number
    voiceModelId: number
    phoneNumber: number
    direction: number
    status: number
    startTime: number
    endTime: number
    duration: number
    sentiment: number
    topics: number
    externalCallId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CallSessionAvgAggregateInputType = {
    duration?: true
  }

  export type CallSessionSumAggregateInputType = {
    duration?: true
  }

  export type CallSessionMinAggregateInputType = {
    id?: true
    userId?: true
    voiceModelId?: true
    phoneNumber?: true
    direction?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    sentiment?: true
    externalCallId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    voiceModelId?: true
    phoneNumber?: true
    direction?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    sentiment?: true
    externalCallId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallSessionCountAggregateInputType = {
    id?: true
    userId?: true
    voiceModelId?: true
    phoneNumber?: true
    direction?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    sentiment?: true
    topics?: true
    externalCallId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CallSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallSession to aggregate.
     */
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     */
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallSessions
    **/
    _count?: true | CallSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallSessionMaxAggregateInputType
  }

  export type GetCallSessionAggregateType<T extends CallSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCallSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallSession[P]>
      : GetScalarType<T[P], AggregateCallSession[P]>
  }




  export type CallSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallSessionWhereInput
    orderBy?: CallSessionOrderByWithAggregationInput | CallSessionOrderByWithAggregationInput[]
    by: CallSessionScalarFieldEnum[] | CallSessionScalarFieldEnum
    having?: CallSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallSessionCountAggregateInputType | true
    _avg?: CallSessionAvgAggregateInputType
    _sum?: CallSessionSumAggregateInputType
    _min?: CallSessionMinAggregateInputType
    _max?: CallSessionMaxAggregateInputType
  }

  export type CallSessionGroupByOutputType = {
    id: string
    userId: string
    voiceModelId: string | null
    phoneNumber: string
    direction: $Enums.CallDirection
    status: $Enums.CallStatus
    startTime: Date
    endTime: Date | null
    duration: number | null
    sentiment: $Enums.Sentiment | null
    topics: string[]
    externalCallId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CallSessionCountAggregateOutputType | null
    _avg: CallSessionAvgAggregateOutputType | null
    _sum: CallSessionSumAggregateOutputType | null
    _min: CallSessionMinAggregateOutputType | null
    _max: CallSessionMaxAggregateOutputType | null
  }

  type GetCallSessionGroupByPayload<T extends CallSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CallSessionGroupByOutputType[P]>
        }
      >
    >


  export type CallSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    voiceModelId?: boolean
    phoneNumber?: boolean
    direction?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    sentiment?: boolean
    topics?: boolean
    externalCallId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    voiceModel?: boolean | CallSession$voiceModelArgs<ExtArgs>
    transcript?: boolean | CallSession$transcriptArgs<ExtArgs>
    summary?: boolean | CallSession$summaryArgs<ExtArgs>
    _count?: boolean | CallSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callSession"]>

  export type CallSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    voiceModelId?: boolean
    phoneNumber?: boolean
    direction?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    sentiment?: boolean
    topics?: boolean
    externalCallId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    voiceModel?: boolean | CallSession$voiceModelArgs<ExtArgs>
  }, ExtArgs["result"]["callSession"]>

  export type CallSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    voiceModelId?: boolean
    phoneNumber?: boolean
    direction?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    sentiment?: boolean
    topics?: boolean
    externalCallId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CallSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    voiceModel?: boolean | CallSession$voiceModelArgs<ExtArgs>
    transcript?: boolean | CallSession$transcriptArgs<ExtArgs>
    summary?: boolean | CallSession$summaryArgs<ExtArgs>
    _count?: boolean | CallSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CallSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    voiceModel?: boolean | CallSession$voiceModelArgs<ExtArgs>
  }

  export type $CallSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      voiceModel: Prisma.$VoiceModelPayload<ExtArgs> | null
      transcript: Prisma.$TranscriptMessagePayload<ExtArgs>[]
      summary: Prisma.$CallSummaryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      voiceModelId: string | null
      phoneNumber: string
      direction: $Enums.CallDirection
      status: $Enums.CallStatus
      startTime: Date
      endTime: Date | null
      duration: number | null
      sentiment: $Enums.Sentiment | null
      topics: string[]
      externalCallId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["callSession"]>
    composites: {}
  }

  type CallSessionGetPayload<S extends boolean | null | undefined | CallSessionDefaultArgs> = $Result.GetResult<Prisma.$CallSessionPayload, S>

  type CallSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CallSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallSessionCountAggregateInputType | true
    }

  export interface CallSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallSession'], meta: { name: 'CallSession' } }
    /**
     * Find zero or one CallSession that matches the filter.
     * @param {CallSessionFindUniqueArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallSessionFindUniqueArgs>(args: SelectSubset<T, CallSessionFindUniqueArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CallSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CallSessionFindUniqueOrThrowArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CallSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CallSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindFirstArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallSessionFindFirstArgs>(args?: SelectSubset<T, CallSessionFindFirstArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CallSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindFirstOrThrowArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CallSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CallSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallSessions
     * const callSessions = await prisma.callSession.findMany()
     * 
     * // Get first 10 CallSessions
     * const callSessions = await prisma.callSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callSessionWithIdOnly = await prisma.callSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallSessionFindManyArgs>(args?: SelectSubset<T, CallSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CallSession.
     * @param {CallSessionCreateArgs} args - Arguments to create a CallSession.
     * @example
     * // Create one CallSession
     * const CallSession = await prisma.callSession.create({
     *   data: {
     *     // ... data to create a CallSession
     *   }
     * })
     * 
     */
    create<T extends CallSessionCreateArgs>(args: SelectSubset<T, CallSessionCreateArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CallSessions.
     * @param {CallSessionCreateManyArgs} args - Arguments to create many CallSessions.
     * @example
     * // Create many CallSessions
     * const callSession = await prisma.callSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallSessionCreateManyArgs>(args?: SelectSubset<T, CallSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallSessions and returns the data saved in the database.
     * @param {CallSessionCreateManyAndReturnArgs} args - Arguments to create many CallSessions.
     * @example
     * // Create many CallSessions
     * const callSession = await prisma.callSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallSessions and only return the `id`
     * const callSessionWithIdOnly = await prisma.callSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CallSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CallSession.
     * @param {CallSessionDeleteArgs} args - Arguments to delete one CallSession.
     * @example
     * // Delete one CallSession
     * const CallSession = await prisma.callSession.delete({
     *   where: {
     *     // ... filter to delete one CallSession
     *   }
     * })
     * 
     */
    delete<T extends CallSessionDeleteArgs>(args: SelectSubset<T, CallSessionDeleteArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CallSession.
     * @param {CallSessionUpdateArgs} args - Arguments to update one CallSession.
     * @example
     * // Update one CallSession
     * const callSession = await prisma.callSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallSessionUpdateArgs>(args: SelectSubset<T, CallSessionUpdateArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CallSessions.
     * @param {CallSessionDeleteManyArgs} args - Arguments to filter CallSessions to delete.
     * @example
     * // Delete a few CallSessions
     * const { count } = await prisma.callSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallSessionDeleteManyArgs>(args?: SelectSubset<T, CallSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallSessions
     * const callSession = await prisma.callSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallSessionUpdateManyArgs>(args: SelectSubset<T, CallSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CallSession.
     * @param {CallSessionUpsertArgs} args - Arguments to update or create a CallSession.
     * @example
     * // Update or create a CallSession
     * const callSession = await prisma.callSession.upsert({
     *   create: {
     *     // ... data to create a CallSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallSession we want to update
     *   }
     * })
     */
    upsert<T extends CallSessionUpsertArgs>(args: SelectSubset<T, CallSessionUpsertArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CallSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionCountArgs} args - Arguments to filter CallSessions to count.
     * @example
     * // Count the number of CallSessions
     * const count = await prisma.callSession.count({
     *   where: {
     *     // ... the filter for the CallSessions we want to count
     *   }
     * })
    **/
    count<T extends CallSessionCountArgs>(
      args?: Subset<T, CallSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallSessionAggregateArgs>(args: Subset<T, CallSessionAggregateArgs>): Prisma.PrismaPromise<GetCallSessionAggregateType<T>>

    /**
     * Group by CallSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallSessionGroupByArgs['orderBy'] }
        : { orderBy?: CallSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallSession model
   */
  readonly fields: CallSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    voiceModel<T extends CallSession$voiceModelArgs<ExtArgs> = {}>(args?: Subset<T, CallSession$voiceModelArgs<ExtArgs>>): Prisma__VoiceModelClient<$Result.GetResult<Prisma.$VoiceModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transcript<T extends CallSession$transcriptArgs<ExtArgs> = {}>(args?: Subset<T, CallSession$transcriptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "findMany"> | Null>
    summary<T extends CallSession$summaryArgs<ExtArgs> = {}>(args?: Subset<T, CallSession$summaryArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallSession model
   */ 
  interface CallSessionFieldRefs {
    readonly id: FieldRef<"CallSession", 'String'>
    readonly userId: FieldRef<"CallSession", 'String'>
    readonly voiceModelId: FieldRef<"CallSession", 'String'>
    readonly phoneNumber: FieldRef<"CallSession", 'String'>
    readonly direction: FieldRef<"CallSession", 'CallDirection'>
    readonly status: FieldRef<"CallSession", 'CallStatus'>
    readonly startTime: FieldRef<"CallSession", 'DateTime'>
    readonly endTime: FieldRef<"CallSession", 'DateTime'>
    readonly duration: FieldRef<"CallSession", 'Int'>
    readonly sentiment: FieldRef<"CallSession", 'Sentiment'>
    readonly topics: FieldRef<"CallSession", 'String[]'>
    readonly externalCallId: FieldRef<"CallSession", 'String'>
    readonly createdAt: FieldRef<"CallSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CallSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallSession findUnique
   */
  export type CallSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSession to fetch.
     */
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession findUniqueOrThrow
   */
  export type CallSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSession to fetch.
     */
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession findFirst
   */
  export type CallSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSession to fetch.
     */
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     */
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallSessions.
     */
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallSessions.
     */
    distinct?: CallSessionScalarFieldEnum | CallSessionScalarFieldEnum[]
  }

  /**
   * CallSession findFirstOrThrow
   */
  export type CallSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSession to fetch.
     */
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     */
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallSessions.
     */
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallSessions.
     */
    distinct?: CallSessionScalarFieldEnum | CallSessionScalarFieldEnum[]
  }

  /**
   * CallSession findMany
   */
  export type CallSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSessions to fetch.
     */
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     */
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallSessions.
     */
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     */
    skip?: number
    distinct?: CallSessionScalarFieldEnum | CallSessionScalarFieldEnum[]
  }

  /**
   * CallSession create
   */
  export type CallSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CallSession.
     */
    data: XOR<CallSessionCreateInput, CallSessionUncheckedCreateInput>
  }

  /**
   * CallSession createMany
   */
  export type CallSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallSessions.
     */
    data: CallSessionCreateManyInput | CallSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallSession createManyAndReturn
   */
  export type CallSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CallSessions.
     */
    data: CallSessionCreateManyInput | CallSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallSession update
   */
  export type CallSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CallSession.
     */
    data: XOR<CallSessionUpdateInput, CallSessionUncheckedUpdateInput>
    /**
     * Choose, which CallSession to update.
     */
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession updateMany
   */
  export type CallSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallSessions.
     */
    data: XOR<CallSessionUpdateManyMutationInput, CallSessionUncheckedUpdateManyInput>
    /**
     * Filter which CallSessions to update
     */
    where?: CallSessionWhereInput
  }

  /**
   * CallSession upsert
   */
  export type CallSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CallSession to update in case it exists.
     */
    where: CallSessionWhereUniqueInput
    /**
     * In case the CallSession found by the `where` argument doesn't exist, create a new CallSession with this data.
     */
    create: XOR<CallSessionCreateInput, CallSessionUncheckedCreateInput>
    /**
     * In case the CallSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallSessionUpdateInput, CallSessionUncheckedUpdateInput>
  }

  /**
   * CallSession delete
   */
  export type CallSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter which CallSession to delete.
     */
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession deleteMany
   */
  export type CallSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallSessions to delete
     */
    where?: CallSessionWhereInput
  }

  /**
   * CallSession.voiceModel
   */
  export type CallSession$voiceModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceModel
     */
    select?: VoiceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceModelInclude<ExtArgs> | null
    where?: VoiceModelWhereInput
  }

  /**
   * CallSession.transcript
   */
  export type CallSession$transcriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    where?: TranscriptMessageWhereInput
    orderBy?: TranscriptMessageOrderByWithRelationInput | TranscriptMessageOrderByWithRelationInput[]
    cursor?: TranscriptMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptMessageScalarFieldEnum | TranscriptMessageScalarFieldEnum[]
  }

  /**
   * CallSession.summary
   */
  export type CallSession$summaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    where?: CallSummaryWhereInput
  }

  /**
   * CallSession without action
   */
  export type CallSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
  }


  /**
   * Model TranscriptMessage
   */

  export type AggregateTranscriptMessage = {
    _count: TranscriptMessageCountAggregateOutputType | null
    _avg: TranscriptMessageAvgAggregateOutputType | null
    _sum: TranscriptMessageSumAggregateOutputType | null
    _min: TranscriptMessageMinAggregateOutputType | null
    _max: TranscriptMessageMaxAggregateOutputType | null
  }

  export type TranscriptMessageAvgAggregateOutputType = {
    confidence: number | null
  }

  export type TranscriptMessageSumAggregateOutputType = {
    confidence: number | null
  }

  export type TranscriptMessageMinAggregateOutputType = {
    id: string | null
    callSessionId: string | null
    speaker: $Enums.Speaker | null
    text: string | null
    confidence: number | null
    timestamp: Date | null
  }

  export type TranscriptMessageMaxAggregateOutputType = {
    id: string | null
    callSessionId: string | null
    speaker: $Enums.Speaker | null
    text: string | null
    confidence: number | null
    timestamp: Date | null
  }

  export type TranscriptMessageCountAggregateOutputType = {
    id: number
    callSessionId: number
    speaker: number
    text: number
    confidence: number
    timestamp: number
    _all: number
  }


  export type TranscriptMessageAvgAggregateInputType = {
    confidence?: true
  }

  export type TranscriptMessageSumAggregateInputType = {
    confidence?: true
  }

  export type TranscriptMessageMinAggregateInputType = {
    id?: true
    callSessionId?: true
    speaker?: true
    text?: true
    confidence?: true
    timestamp?: true
  }

  export type TranscriptMessageMaxAggregateInputType = {
    id?: true
    callSessionId?: true
    speaker?: true
    text?: true
    confidence?: true
    timestamp?: true
  }

  export type TranscriptMessageCountAggregateInputType = {
    id?: true
    callSessionId?: true
    speaker?: true
    text?: true
    confidence?: true
    timestamp?: true
    _all?: true
  }

  export type TranscriptMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptMessage to aggregate.
     */
    where?: TranscriptMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptMessages to fetch.
     */
    orderBy?: TranscriptMessageOrderByWithRelationInput | TranscriptMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranscriptMessages
    **/
    _count?: true | TranscriptMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptMessageMaxAggregateInputType
  }

  export type GetTranscriptMessageAggregateType<T extends TranscriptMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscriptMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptMessage[P]>
      : GetScalarType<T[P], AggregateTranscriptMessage[P]>
  }




  export type TranscriptMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptMessageWhereInput
    orderBy?: TranscriptMessageOrderByWithAggregationInput | TranscriptMessageOrderByWithAggregationInput[]
    by: TranscriptMessageScalarFieldEnum[] | TranscriptMessageScalarFieldEnum
    having?: TranscriptMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptMessageCountAggregateInputType | true
    _avg?: TranscriptMessageAvgAggregateInputType
    _sum?: TranscriptMessageSumAggregateInputType
    _min?: TranscriptMessageMinAggregateInputType
    _max?: TranscriptMessageMaxAggregateInputType
  }

  export type TranscriptMessageGroupByOutputType = {
    id: string
    callSessionId: string
    speaker: $Enums.Speaker
    text: string
    confidence: number | null
    timestamp: Date
    _count: TranscriptMessageCountAggregateOutputType | null
    _avg: TranscriptMessageAvgAggregateOutputType | null
    _sum: TranscriptMessageSumAggregateOutputType | null
    _min: TranscriptMessageMinAggregateOutputType | null
    _max: TranscriptMessageMaxAggregateOutputType | null
  }

  type GetTranscriptMessageGroupByPayload<T extends TranscriptMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptMessageGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callSessionId?: boolean
    speaker?: boolean
    text?: boolean
    confidence?: boolean
    timestamp?: boolean
    callSession?: boolean | CallSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptMessage"]>

  export type TranscriptMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callSessionId?: boolean
    speaker?: boolean
    text?: boolean
    confidence?: boolean
    timestamp?: boolean
    callSession?: boolean | CallSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptMessage"]>

  export type TranscriptMessageSelectScalar = {
    id?: boolean
    callSessionId?: boolean
    speaker?: boolean
    text?: boolean
    confidence?: boolean
    timestamp?: boolean
  }

  export type TranscriptMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callSession?: boolean | CallSessionDefaultArgs<ExtArgs>
  }
  export type TranscriptMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callSession?: boolean | CallSessionDefaultArgs<ExtArgs>
  }

  export type $TranscriptMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranscriptMessage"
    objects: {
      callSession: Prisma.$CallSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      callSessionId: string
      speaker: $Enums.Speaker
      text: string
      confidence: number | null
      timestamp: Date
    }, ExtArgs["result"]["transcriptMessage"]>
    composites: {}
  }

  type TranscriptMessageGetPayload<S extends boolean | null | undefined | TranscriptMessageDefaultArgs> = $Result.GetResult<Prisma.$TranscriptMessagePayload, S>

  type TranscriptMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranscriptMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranscriptMessageCountAggregateInputType | true
    }

  export interface TranscriptMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranscriptMessage'], meta: { name: 'TranscriptMessage' } }
    /**
     * Find zero or one TranscriptMessage that matches the filter.
     * @param {TranscriptMessageFindUniqueArgs} args - Arguments to find a TranscriptMessage
     * @example
     * // Get one TranscriptMessage
     * const transcriptMessage = await prisma.transcriptMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptMessageFindUniqueArgs>(args: SelectSubset<T, TranscriptMessageFindUniqueArgs<ExtArgs>>): Prisma__TranscriptMessageClient<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TranscriptMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranscriptMessageFindUniqueOrThrowArgs} args - Arguments to find a TranscriptMessage
     * @example
     * // Get one TranscriptMessage
     * const transcriptMessage = await prisma.transcriptMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptMessageClient<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TranscriptMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptMessageFindFirstArgs} args - Arguments to find a TranscriptMessage
     * @example
     * // Get one TranscriptMessage
     * const transcriptMessage = await prisma.transcriptMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptMessageFindFirstArgs>(args?: SelectSubset<T, TranscriptMessageFindFirstArgs<ExtArgs>>): Prisma__TranscriptMessageClient<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TranscriptMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptMessageFindFirstOrThrowArgs} args - Arguments to find a TranscriptMessage
     * @example
     * // Get one TranscriptMessage
     * const transcriptMessage = await prisma.transcriptMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptMessageClient<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TranscriptMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptMessages
     * const transcriptMessages = await prisma.transcriptMessage.findMany()
     * 
     * // Get first 10 TranscriptMessages
     * const transcriptMessages = await prisma.transcriptMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptMessageWithIdOnly = await prisma.transcriptMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptMessageFindManyArgs>(args?: SelectSubset<T, TranscriptMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TranscriptMessage.
     * @param {TranscriptMessageCreateArgs} args - Arguments to create a TranscriptMessage.
     * @example
     * // Create one TranscriptMessage
     * const TranscriptMessage = await prisma.transcriptMessage.create({
     *   data: {
     *     // ... data to create a TranscriptMessage
     *   }
     * })
     * 
     */
    create<T extends TranscriptMessageCreateArgs>(args: SelectSubset<T, TranscriptMessageCreateArgs<ExtArgs>>): Prisma__TranscriptMessageClient<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TranscriptMessages.
     * @param {TranscriptMessageCreateManyArgs} args - Arguments to create many TranscriptMessages.
     * @example
     * // Create many TranscriptMessages
     * const transcriptMessage = await prisma.transcriptMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptMessageCreateManyArgs>(args?: SelectSubset<T, TranscriptMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TranscriptMessages and returns the data saved in the database.
     * @param {TranscriptMessageCreateManyAndReturnArgs} args - Arguments to create many TranscriptMessages.
     * @example
     * // Create many TranscriptMessages
     * const transcriptMessage = await prisma.transcriptMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TranscriptMessages and only return the `id`
     * const transcriptMessageWithIdOnly = await prisma.transcriptMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranscriptMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, TranscriptMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TranscriptMessage.
     * @param {TranscriptMessageDeleteArgs} args - Arguments to delete one TranscriptMessage.
     * @example
     * // Delete one TranscriptMessage
     * const TranscriptMessage = await prisma.transcriptMessage.delete({
     *   where: {
     *     // ... filter to delete one TranscriptMessage
     *   }
     * })
     * 
     */
    delete<T extends TranscriptMessageDeleteArgs>(args: SelectSubset<T, TranscriptMessageDeleteArgs<ExtArgs>>): Prisma__TranscriptMessageClient<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TranscriptMessage.
     * @param {TranscriptMessageUpdateArgs} args - Arguments to update one TranscriptMessage.
     * @example
     * // Update one TranscriptMessage
     * const transcriptMessage = await prisma.transcriptMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptMessageUpdateArgs>(args: SelectSubset<T, TranscriptMessageUpdateArgs<ExtArgs>>): Prisma__TranscriptMessageClient<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TranscriptMessages.
     * @param {TranscriptMessageDeleteManyArgs} args - Arguments to filter TranscriptMessages to delete.
     * @example
     * // Delete a few TranscriptMessages
     * const { count } = await prisma.transcriptMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptMessageDeleteManyArgs>(args?: SelectSubset<T, TranscriptMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptMessages
     * const transcriptMessage = await prisma.transcriptMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptMessageUpdateManyArgs>(args: SelectSubset<T, TranscriptMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TranscriptMessage.
     * @param {TranscriptMessageUpsertArgs} args - Arguments to update or create a TranscriptMessage.
     * @example
     * // Update or create a TranscriptMessage
     * const transcriptMessage = await prisma.transcriptMessage.upsert({
     *   create: {
     *     // ... data to create a TranscriptMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptMessage we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptMessageUpsertArgs>(args: SelectSubset<T, TranscriptMessageUpsertArgs<ExtArgs>>): Prisma__TranscriptMessageClient<$Result.GetResult<Prisma.$TranscriptMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TranscriptMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptMessageCountArgs} args - Arguments to filter TranscriptMessages to count.
     * @example
     * // Count the number of TranscriptMessages
     * const count = await prisma.transcriptMessage.count({
     *   where: {
     *     // ... the filter for the TranscriptMessages we want to count
     *   }
     * })
    **/
    count<T extends TranscriptMessageCountArgs>(
      args?: Subset<T, TranscriptMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranscriptMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptMessageAggregateArgs>(args: Subset<T, TranscriptMessageAggregateArgs>): Prisma.PrismaPromise<GetTranscriptMessageAggregateType<T>>

    /**
     * Group by TranscriptMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptMessageGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranscriptMessage model
   */
  readonly fields: TranscriptMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    callSession<T extends CallSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallSessionDefaultArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranscriptMessage model
   */ 
  interface TranscriptMessageFieldRefs {
    readonly id: FieldRef<"TranscriptMessage", 'String'>
    readonly callSessionId: FieldRef<"TranscriptMessage", 'String'>
    readonly speaker: FieldRef<"TranscriptMessage", 'Speaker'>
    readonly text: FieldRef<"TranscriptMessage", 'String'>
    readonly confidence: FieldRef<"TranscriptMessage", 'Float'>
    readonly timestamp: FieldRef<"TranscriptMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TranscriptMessage findUnique
   */
  export type TranscriptMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptMessage to fetch.
     */
    where: TranscriptMessageWhereUniqueInput
  }

  /**
   * TranscriptMessage findUniqueOrThrow
   */
  export type TranscriptMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptMessage to fetch.
     */
    where: TranscriptMessageWhereUniqueInput
  }

  /**
   * TranscriptMessage findFirst
   */
  export type TranscriptMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptMessage to fetch.
     */
    where?: TranscriptMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptMessages to fetch.
     */
    orderBy?: TranscriptMessageOrderByWithRelationInput | TranscriptMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptMessages.
     */
    cursor?: TranscriptMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptMessages.
     */
    distinct?: TranscriptMessageScalarFieldEnum | TranscriptMessageScalarFieldEnum[]
  }

  /**
   * TranscriptMessage findFirstOrThrow
   */
  export type TranscriptMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptMessage to fetch.
     */
    where?: TranscriptMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptMessages to fetch.
     */
    orderBy?: TranscriptMessageOrderByWithRelationInput | TranscriptMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptMessages.
     */
    cursor?: TranscriptMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptMessages.
     */
    distinct?: TranscriptMessageScalarFieldEnum | TranscriptMessageScalarFieldEnum[]
  }

  /**
   * TranscriptMessage findMany
   */
  export type TranscriptMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptMessages to fetch.
     */
    where?: TranscriptMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptMessages to fetch.
     */
    orderBy?: TranscriptMessageOrderByWithRelationInput | TranscriptMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranscriptMessages.
     */
    cursor?: TranscriptMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptMessages.
     */
    skip?: number
    distinct?: TranscriptMessageScalarFieldEnum | TranscriptMessageScalarFieldEnum[]
  }

  /**
   * TranscriptMessage create
   */
  export type TranscriptMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TranscriptMessage.
     */
    data: XOR<TranscriptMessageCreateInput, TranscriptMessageUncheckedCreateInput>
  }

  /**
   * TranscriptMessage createMany
   */
  export type TranscriptMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranscriptMessages.
     */
    data: TranscriptMessageCreateManyInput | TranscriptMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranscriptMessage createManyAndReturn
   */
  export type TranscriptMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TranscriptMessages.
     */
    data: TranscriptMessageCreateManyInput | TranscriptMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranscriptMessage update
   */
  export type TranscriptMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TranscriptMessage.
     */
    data: XOR<TranscriptMessageUpdateInput, TranscriptMessageUncheckedUpdateInput>
    /**
     * Choose, which TranscriptMessage to update.
     */
    where: TranscriptMessageWhereUniqueInput
  }

  /**
   * TranscriptMessage updateMany
   */
  export type TranscriptMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranscriptMessages.
     */
    data: XOR<TranscriptMessageUpdateManyMutationInput, TranscriptMessageUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptMessages to update
     */
    where?: TranscriptMessageWhereInput
  }

  /**
   * TranscriptMessage upsert
   */
  export type TranscriptMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TranscriptMessage to update in case it exists.
     */
    where: TranscriptMessageWhereUniqueInput
    /**
     * In case the TranscriptMessage found by the `where` argument doesn't exist, create a new TranscriptMessage with this data.
     */
    create: XOR<TranscriptMessageCreateInput, TranscriptMessageUncheckedCreateInput>
    /**
     * In case the TranscriptMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptMessageUpdateInput, TranscriptMessageUncheckedUpdateInput>
  }

  /**
   * TranscriptMessage delete
   */
  export type TranscriptMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
    /**
     * Filter which TranscriptMessage to delete.
     */
    where: TranscriptMessageWhereUniqueInput
  }

  /**
   * TranscriptMessage deleteMany
   */
  export type TranscriptMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptMessages to delete
     */
    where?: TranscriptMessageWhereInput
  }

  /**
   * TranscriptMessage without action
   */
  export type TranscriptMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptMessage
     */
    select?: TranscriptMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptMessageInclude<ExtArgs> | null
  }


  /**
   * Model CallSummary
   */

  export type AggregateCallSummary = {
    _count: CallSummaryCountAggregateOutputType | null
    _min: CallSummaryMinAggregateOutputType | null
    _max: CallSummaryMaxAggregateOutputType | null
  }

  export type CallSummaryMinAggregateOutputType = {
    id: string | null
    callSessionId: string | null
    summary: string | null
    createdAt: Date | null
  }

  export type CallSummaryMaxAggregateOutputType = {
    id: string | null
    callSessionId: string | null
    summary: string | null
    createdAt: Date | null
  }

  export type CallSummaryCountAggregateOutputType = {
    id: number
    callSessionId: number
    summary: number
    actionItems: number
    keyPoints: number
    createdAt: number
    _all: number
  }


  export type CallSummaryMinAggregateInputType = {
    id?: true
    callSessionId?: true
    summary?: true
    createdAt?: true
  }

  export type CallSummaryMaxAggregateInputType = {
    id?: true
    callSessionId?: true
    summary?: true
    createdAt?: true
  }

  export type CallSummaryCountAggregateInputType = {
    id?: true
    callSessionId?: true
    summary?: true
    actionItems?: true
    keyPoints?: true
    createdAt?: true
    _all?: true
  }

  export type CallSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallSummary to aggregate.
     */
    where?: CallSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSummaries to fetch.
     */
    orderBy?: CallSummaryOrderByWithRelationInput | CallSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallSummaries
    **/
    _count?: true | CallSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallSummaryMaxAggregateInputType
  }

  export type GetCallSummaryAggregateType<T extends CallSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateCallSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallSummary[P]>
      : GetScalarType<T[P], AggregateCallSummary[P]>
  }




  export type CallSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallSummaryWhereInput
    orderBy?: CallSummaryOrderByWithAggregationInput | CallSummaryOrderByWithAggregationInput[]
    by: CallSummaryScalarFieldEnum[] | CallSummaryScalarFieldEnum
    having?: CallSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallSummaryCountAggregateInputType | true
    _min?: CallSummaryMinAggregateInputType
    _max?: CallSummaryMaxAggregateInputType
  }

  export type CallSummaryGroupByOutputType = {
    id: string
    callSessionId: string
    summary: string
    actionItems: string[]
    keyPoints: string[]
    createdAt: Date
    _count: CallSummaryCountAggregateOutputType | null
    _min: CallSummaryMinAggregateOutputType | null
    _max: CallSummaryMaxAggregateOutputType | null
  }

  type GetCallSummaryGroupByPayload<T extends CallSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], CallSummaryGroupByOutputType[P]>
        }
      >
    >


  export type CallSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callSessionId?: boolean
    summary?: boolean
    actionItems?: boolean
    keyPoints?: boolean
    createdAt?: boolean
    callSession?: boolean | CallSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callSummary"]>

  export type CallSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callSessionId?: boolean
    summary?: boolean
    actionItems?: boolean
    keyPoints?: boolean
    createdAt?: boolean
    callSession?: boolean | CallSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callSummary"]>

  export type CallSummarySelectScalar = {
    id?: boolean
    callSessionId?: boolean
    summary?: boolean
    actionItems?: boolean
    keyPoints?: boolean
    createdAt?: boolean
  }

  export type CallSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callSession?: boolean | CallSessionDefaultArgs<ExtArgs>
  }
  export type CallSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callSession?: boolean | CallSessionDefaultArgs<ExtArgs>
  }

  export type $CallSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallSummary"
    objects: {
      callSession: Prisma.$CallSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      callSessionId: string
      summary: string
      actionItems: string[]
      keyPoints: string[]
      createdAt: Date
    }, ExtArgs["result"]["callSummary"]>
    composites: {}
  }

  type CallSummaryGetPayload<S extends boolean | null | undefined | CallSummaryDefaultArgs> = $Result.GetResult<Prisma.$CallSummaryPayload, S>

  type CallSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CallSummaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallSummaryCountAggregateInputType | true
    }

  export interface CallSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallSummary'], meta: { name: 'CallSummary' } }
    /**
     * Find zero or one CallSummary that matches the filter.
     * @param {CallSummaryFindUniqueArgs} args - Arguments to find a CallSummary
     * @example
     * // Get one CallSummary
     * const callSummary = await prisma.callSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallSummaryFindUniqueArgs>(args: SelectSubset<T, CallSummaryFindUniqueArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CallSummary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CallSummaryFindUniqueOrThrowArgs} args - Arguments to find a CallSummary
     * @example
     * // Get one CallSummary
     * const callSummary = await prisma.callSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, CallSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CallSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSummaryFindFirstArgs} args - Arguments to find a CallSummary
     * @example
     * // Get one CallSummary
     * const callSummary = await prisma.callSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallSummaryFindFirstArgs>(args?: SelectSubset<T, CallSummaryFindFirstArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CallSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSummaryFindFirstOrThrowArgs} args - Arguments to find a CallSummary
     * @example
     * // Get one CallSummary
     * const callSummary = await prisma.callSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, CallSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CallSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallSummaries
     * const callSummaries = await prisma.callSummary.findMany()
     * 
     * // Get first 10 CallSummaries
     * const callSummaries = await prisma.callSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callSummaryWithIdOnly = await prisma.callSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallSummaryFindManyArgs>(args?: SelectSubset<T, CallSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CallSummary.
     * @param {CallSummaryCreateArgs} args - Arguments to create a CallSummary.
     * @example
     * // Create one CallSummary
     * const CallSummary = await prisma.callSummary.create({
     *   data: {
     *     // ... data to create a CallSummary
     *   }
     * })
     * 
     */
    create<T extends CallSummaryCreateArgs>(args: SelectSubset<T, CallSummaryCreateArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CallSummaries.
     * @param {CallSummaryCreateManyArgs} args - Arguments to create many CallSummaries.
     * @example
     * // Create many CallSummaries
     * const callSummary = await prisma.callSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallSummaryCreateManyArgs>(args?: SelectSubset<T, CallSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallSummaries and returns the data saved in the database.
     * @param {CallSummaryCreateManyAndReturnArgs} args - Arguments to create many CallSummaries.
     * @example
     * // Create many CallSummaries
     * const callSummary = await prisma.callSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallSummaries and only return the `id`
     * const callSummaryWithIdOnly = await prisma.callSummary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, CallSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CallSummary.
     * @param {CallSummaryDeleteArgs} args - Arguments to delete one CallSummary.
     * @example
     * // Delete one CallSummary
     * const CallSummary = await prisma.callSummary.delete({
     *   where: {
     *     // ... filter to delete one CallSummary
     *   }
     * })
     * 
     */
    delete<T extends CallSummaryDeleteArgs>(args: SelectSubset<T, CallSummaryDeleteArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CallSummary.
     * @param {CallSummaryUpdateArgs} args - Arguments to update one CallSummary.
     * @example
     * // Update one CallSummary
     * const callSummary = await prisma.callSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallSummaryUpdateArgs>(args: SelectSubset<T, CallSummaryUpdateArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CallSummaries.
     * @param {CallSummaryDeleteManyArgs} args - Arguments to filter CallSummaries to delete.
     * @example
     * // Delete a few CallSummaries
     * const { count } = await prisma.callSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallSummaryDeleteManyArgs>(args?: SelectSubset<T, CallSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallSummaries
     * const callSummary = await prisma.callSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallSummaryUpdateManyArgs>(args: SelectSubset<T, CallSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CallSummary.
     * @param {CallSummaryUpsertArgs} args - Arguments to update or create a CallSummary.
     * @example
     * // Update or create a CallSummary
     * const callSummary = await prisma.callSummary.upsert({
     *   create: {
     *     // ... data to create a CallSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallSummary we want to update
     *   }
     * })
     */
    upsert<T extends CallSummaryUpsertArgs>(args: SelectSubset<T, CallSummaryUpsertArgs<ExtArgs>>): Prisma__CallSummaryClient<$Result.GetResult<Prisma.$CallSummaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CallSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSummaryCountArgs} args - Arguments to filter CallSummaries to count.
     * @example
     * // Count the number of CallSummaries
     * const count = await prisma.callSummary.count({
     *   where: {
     *     // ... the filter for the CallSummaries we want to count
     *   }
     * })
    **/
    count<T extends CallSummaryCountArgs>(
      args?: Subset<T, CallSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallSummaryAggregateArgs>(args: Subset<T, CallSummaryAggregateArgs>): Prisma.PrismaPromise<GetCallSummaryAggregateType<T>>

    /**
     * Group by CallSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallSummaryGroupByArgs['orderBy'] }
        : { orderBy?: CallSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallSummary model
   */
  readonly fields: CallSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    callSession<T extends CallSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallSessionDefaultArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallSummary model
   */ 
  interface CallSummaryFieldRefs {
    readonly id: FieldRef<"CallSummary", 'String'>
    readonly callSessionId: FieldRef<"CallSummary", 'String'>
    readonly summary: FieldRef<"CallSummary", 'String'>
    readonly actionItems: FieldRef<"CallSummary", 'String[]'>
    readonly keyPoints: FieldRef<"CallSummary", 'String[]'>
    readonly createdAt: FieldRef<"CallSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallSummary findUnique
   */
  export type CallSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * Filter, which CallSummary to fetch.
     */
    where: CallSummaryWhereUniqueInput
  }

  /**
   * CallSummary findUniqueOrThrow
   */
  export type CallSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * Filter, which CallSummary to fetch.
     */
    where: CallSummaryWhereUniqueInput
  }

  /**
   * CallSummary findFirst
   */
  export type CallSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * Filter, which CallSummary to fetch.
     */
    where?: CallSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSummaries to fetch.
     */
    orderBy?: CallSummaryOrderByWithRelationInput | CallSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallSummaries.
     */
    cursor?: CallSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallSummaries.
     */
    distinct?: CallSummaryScalarFieldEnum | CallSummaryScalarFieldEnum[]
  }

  /**
   * CallSummary findFirstOrThrow
   */
  export type CallSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * Filter, which CallSummary to fetch.
     */
    where?: CallSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSummaries to fetch.
     */
    orderBy?: CallSummaryOrderByWithRelationInput | CallSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallSummaries.
     */
    cursor?: CallSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallSummaries.
     */
    distinct?: CallSummaryScalarFieldEnum | CallSummaryScalarFieldEnum[]
  }

  /**
   * CallSummary findMany
   */
  export type CallSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * Filter, which CallSummaries to fetch.
     */
    where?: CallSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSummaries to fetch.
     */
    orderBy?: CallSummaryOrderByWithRelationInput | CallSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallSummaries.
     */
    cursor?: CallSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSummaries.
     */
    skip?: number
    distinct?: CallSummaryScalarFieldEnum | CallSummaryScalarFieldEnum[]
  }

  /**
   * CallSummary create
   */
  export type CallSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a CallSummary.
     */
    data: XOR<CallSummaryCreateInput, CallSummaryUncheckedCreateInput>
  }

  /**
   * CallSummary createMany
   */
  export type CallSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallSummaries.
     */
    data: CallSummaryCreateManyInput | CallSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallSummary createManyAndReturn
   */
  export type CallSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CallSummaries.
     */
    data: CallSummaryCreateManyInput | CallSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallSummary update
   */
  export type CallSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a CallSummary.
     */
    data: XOR<CallSummaryUpdateInput, CallSummaryUncheckedUpdateInput>
    /**
     * Choose, which CallSummary to update.
     */
    where: CallSummaryWhereUniqueInput
  }

  /**
   * CallSummary updateMany
   */
  export type CallSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallSummaries.
     */
    data: XOR<CallSummaryUpdateManyMutationInput, CallSummaryUncheckedUpdateManyInput>
    /**
     * Filter which CallSummaries to update
     */
    where?: CallSummaryWhereInput
  }

  /**
   * CallSummary upsert
   */
  export type CallSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the CallSummary to update in case it exists.
     */
    where: CallSummaryWhereUniqueInput
    /**
     * In case the CallSummary found by the `where` argument doesn't exist, create a new CallSummary with this data.
     */
    create: XOR<CallSummaryCreateInput, CallSummaryUncheckedCreateInput>
    /**
     * In case the CallSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallSummaryUpdateInput, CallSummaryUncheckedUpdateInput>
  }

  /**
   * CallSummary delete
   */
  export type CallSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
    /**
     * Filter which CallSummary to delete.
     */
    where: CallSummaryWhereUniqueInput
  }

  /**
   * CallSummary deleteMany
   */
  export type CallSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallSummaries to delete
     */
    where?: CallSummaryWhereInput
  }

  /**
   * CallSummary without action
   */
  export type CallSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSummary
     */
    select?: CallSummarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSummaryInclude<ExtArgs> | null
  }


  /**
   * Model DailyAnalytics
   */

  export type AggregateDailyAnalytics = {
    _count: DailyAnalyticsCountAggregateOutputType | null
    _avg: DailyAnalyticsAvgAggregateOutputType | null
    _sum: DailyAnalyticsSumAggregateOutputType | null
    _min: DailyAnalyticsMinAggregateOutputType | null
    _max: DailyAnalyticsMaxAggregateOutputType | null
  }

  export type DailyAnalyticsAvgAggregateOutputType = {
    totalCalls: number | null
    completedCalls: number | null
    missedCalls: number | null
    totalDuration: number | null
    avgDuration: number | null
    positiveSentiment: number | null
    neutralSentiment: number | null
    negativeSentiment: number | null
  }

  export type DailyAnalyticsSumAggregateOutputType = {
    totalCalls: number | null
    completedCalls: number | null
    missedCalls: number | null
    totalDuration: number | null
    avgDuration: number | null
    positiveSentiment: number | null
    neutralSentiment: number | null
    negativeSentiment: number | null
  }

  export type DailyAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    totalCalls: number | null
    completedCalls: number | null
    missedCalls: number | null
    totalDuration: number | null
    avgDuration: number | null
    positiveSentiment: number | null
    neutralSentiment: number | null
    negativeSentiment: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    totalCalls: number | null
    completedCalls: number | null
    missedCalls: number | null
    totalDuration: number | null
    avgDuration: number | null
    positiveSentiment: number | null
    neutralSentiment: number | null
    negativeSentiment: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    totalCalls: number
    completedCalls: number
    missedCalls: number
    totalDuration: number
    avgDuration: number
    positiveSentiment: number
    neutralSentiment: number
    negativeSentiment: number
    topTopics: number
    peakHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyAnalyticsAvgAggregateInputType = {
    totalCalls?: true
    completedCalls?: true
    missedCalls?: true
    totalDuration?: true
    avgDuration?: true
    positiveSentiment?: true
    neutralSentiment?: true
    negativeSentiment?: true
  }

  export type DailyAnalyticsSumAggregateInputType = {
    totalCalls?: true
    completedCalls?: true
    missedCalls?: true
    totalDuration?: true
    avgDuration?: true
    positiveSentiment?: true
    neutralSentiment?: true
    negativeSentiment?: true
  }

  export type DailyAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    totalCalls?: true
    completedCalls?: true
    missedCalls?: true
    totalDuration?: true
    avgDuration?: true
    positiveSentiment?: true
    neutralSentiment?: true
    negativeSentiment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    totalCalls?: true
    completedCalls?: true
    missedCalls?: true
    totalDuration?: true
    avgDuration?: true
    positiveSentiment?: true
    neutralSentiment?: true
    negativeSentiment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    totalCalls?: true
    completedCalls?: true
    missedCalls?: true
    totalDuration?: true
    avgDuration?: true
    positiveSentiment?: true
    neutralSentiment?: true
    negativeSentiment?: true
    topTopics?: true
    peakHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyAnalytics to aggregate.
     */
    where?: DailyAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAnalytics to fetch.
     */
    orderBy?: DailyAnalyticsOrderByWithRelationInput | DailyAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyAnalytics
    **/
    _count?: true | DailyAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyAnalyticsMaxAggregateInputType
  }

  export type GetDailyAnalyticsAggregateType<T extends DailyAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyAnalytics[P]>
      : GetScalarType<T[P], AggregateDailyAnalytics[P]>
  }




  export type DailyAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAnalyticsWhereInput
    orderBy?: DailyAnalyticsOrderByWithAggregationInput | DailyAnalyticsOrderByWithAggregationInput[]
    by: DailyAnalyticsScalarFieldEnum[] | DailyAnalyticsScalarFieldEnum
    having?: DailyAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyAnalyticsCountAggregateInputType | true
    _avg?: DailyAnalyticsAvgAggregateInputType
    _sum?: DailyAnalyticsSumAggregateInputType
    _min?: DailyAnalyticsMinAggregateInputType
    _max?: DailyAnalyticsMaxAggregateInputType
  }

  export type DailyAnalyticsGroupByOutputType = {
    id: string
    userId: string
    date: Date
    totalCalls: number
    completedCalls: number
    missedCalls: number
    totalDuration: number
    avgDuration: number
    positiveSentiment: number
    neutralSentiment: number
    negativeSentiment: number
    topTopics: JsonValue | null
    peakHours: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DailyAnalyticsCountAggregateOutputType | null
    _avg: DailyAnalyticsAvgAggregateOutputType | null
    _sum: DailyAnalyticsSumAggregateOutputType | null
    _min: DailyAnalyticsMinAggregateOutputType | null
    _max: DailyAnalyticsMaxAggregateOutputType | null
  }

  type GetDailyAnalyticsGroupByPayload<T extends DailyAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], DailyAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type DailyAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    totalCalls?: boolean
    completedCalls?: boolean
    missedCalls?: boolean
    totalDuration?: boolean
    avgDuration?: boolean
    positiveSentiment?: boolean
    neutralSentiment?: boolean
    negativeSentiment?: boolean
    topTopics?: boolean
    peakHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyAnalytics"]>

  export type DailyAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    totalCalls?: boolean
    completedCalls?: boolean
    missedCalls?: boolean
    totalDuration?: boolean
    avgDuration?: boolean
    positiveSentiment?: boolean
    neutralSentiment?: boolean
    negativeSentiment?: boolean
    topTopics?: boolean
    peakHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyAnalytics"]>

  export type DailyAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    totalCalls?: boolean
    completedCalls?: boolean
    missedCalls?: boolean
    totalDuration?: boolean
    avgDuration?: boolean
    positiveSentiment?: boolean
    neutralSentiment?: boolean
    negativeSentiment?: boolean
    topTopics?: boolean
    peakHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DailyAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      totalCalls: number
      completedCalls: number
      missedCalls: number
      totalDuration: number
      avgDuration: number
      positiveSentiment: number
      neutralSentiment: number
      negativeSentiment: number
      topTopics: Prisma.JsonValue | null
      peakHours: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyAnalytics"]>
    composites: {}
  }

  type DailyAnalyticsGetPayload<S extends boolean | null | undefined | DailyAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$DailyAnalyticsPayload, S>

  type DailyAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyAnalyticsCountAggregateInputType | true
    }

  export interface DailyAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyAnalytics'], meta: { name: 'DailyAnalytics' } }
    /**
     * Find zero or one DailyAnalytics that matches the filter.
     * @param {DailyAnalyticsFindUniqueArgs} args - Arguments to find a DailyAnalytics
     * @example
     * // Get one DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyAnalyticsFindUniqueArgs>(args: SelectSubset<T, DailyAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__DailyAnalyticsClient<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a DailyAnalytics
     * @example
     * // Get one DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyAnalyticsClient<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAnalyticsFindFirstArgs} args - Arguments to find a DailyAnalytics
     * @example
     * // Get one DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyAnalyticsFindFirstArgs>(args?: SelectSubset<T, DailyAnalyticsFindFirstArgs<ExtArgs>>): Prisma__DailyAnalyticsClient<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAnalyticsFindFirstOrThrowArgs} args - Arguments to find a DailyAnalytics
     * @example
     * // Get one DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyAnalyticsClient<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.findMany()
     * 
     * // Get first 10 DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyAnalyticsWithIdOnly = await prisma.dailyAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyAnalyticsFindManyArgs>(args?: SelectSubset<T, DailyAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyAnalytics.
     * @param {DailyAnalyticsCreateArgs} args - Arguments to create a DailyAnalytics.
     * @example
     * // Create one DailyAnalytics
     * const DailyAnalytics = await prisma.dailyAnalytics.create({
     *   data: {
     *     // ... data to create a DailyAnalytics
     *   }
     * })
     * 
     */
    create<T extends DailyAnalyticsCreateArgs>(args: SelectSubset<T, DailyAnalyticsCreateArgs<ExtArgs>>): Prisma__DailyAnalyticsClient<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyAnalytics.
     * @param {DailyAnalyticsCreateManyArgs} args - Arguments to create many DailyAnalytics.
     * @example
     * // Create many DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyAnalyticsCreateManyArgs>(args?: SelectSubset<T, DailyAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyAnalytics and returns the data saved in the database.
     * @param {DailyAnalyticsCreateManyAndReturnArgs} args - Arguments to create many DailyAnalytics.
     * @example
     * // Create many DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyAnalytics and only return the `id`
     * const dailyAnalyticsWithIdOnly = await prisma.dailyAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyAnalytics.
     * @param {DailyAnalyticsDeleteArgs} args - Arguments to delete one DailyAnalytics.
     * @example
     * // Delete one DailyAnalytics
     * const DailyAnalytics = await prisma.dailyAnalytics.delete({
     *   where: {
     *     // ... filter to delete one DailyAnalytics
     *   }
     * })
     * 
     */
    delete<T extends DailyAnalyticsDeleteArgs>(args: SelectSubset<T, DailyAnalyticsDeleteArgs<ExtArgs>>): Prisma__DailyAnalyticsClient<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyAnalytics.
     * @param {DailyAnalyticsUpdateArgs} args - Arguments to update one DailyAnalytics.
     * @example
     * // Update one DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyAnalyticsUpdateArgs>(args: SelectSubset<T, DailyAnalyticsUpdateArgs<ExtArgs>>): Prisma__DailyAnalyticsClient<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyAnalytics.
     * @param {DailyAnalyticsDeleteManyArgs} args - Arguments to filter DailyAnalytics to delete.
     * @example
     * // Delete a few DailyAnalytics
     * const { count } = await prisma.dailyAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyAnalyticsDeleteManyArgs>(args?: SelectSubset<T, DailyAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyAnalyticsUpdateManyArgs>(args: SelectSubset<T, DailyAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyAnalytics.
     * @param {DailyAnalyticsUpsertArgs} args - Arguments to update or create a DailyAnalytics.
     * @example
     * // Update or create a DailyAnalytics
     * const dailyAnalytics = await prisma.dailyAnalytics.upsert({
     *   create: {
     *     // ... data to create a DailyAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends DailyAnalyticsUpsertArgs>(args: SelectSubset<T, DailyAnalyticsUpsertArgs<ExtArgs>>): Prisma__DailyAnalyticsClient<$Result.GetResult<Prisma.$DailyAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAnalyticsCountArgs} args - Arguments to filter DailyAnalytics to count.
     * @example
     * // Count the number of DailyAnalytics
     * const count = await prisma.dailyAnalytics.count({
     *   where: {
     *     // ... the filter for the DailyAnalytics we want to count
     *   }
     * })
    **/
    count<T extends DailyAnalyticsCountArgs>(
      args?: Subset<T, DailyAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyAnalyticsAggregateArgs>(args: Subset<T, DailyAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetDailyAnalyticsAggregateType<T>>

    /**
     * Group by DailyAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: DailyAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyAnalytics model
   */
  readonly fields: DailyAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyAnalytics model
   */ 
  interface DailyAnalyticsFieldRefs {
    readonly id: FieldRef<"DailyAnalytics", 'String'>
    readonly userId: FieldRef<"DailyAnalytics", 'String'>
    readonly date: FieldRef<"DailyAnalytics", 'DateTime'>
    readonly totalCalls: FieldRef<"DailyAnalytics", 'Int'>
    readonly completedCalls: FieldRef<"DailyAnalytics", 'Int'>
    readonly missedCalls: FieldRef<"DailyAnalytics", 'Int'>
    readonly totalDuration: FieldRef<"DailyAnalytics", 'Int'>
    readonly avgDuration: FieldRef<"DailyAnalytics", 'Float'>
    readonly positiveSentiment: FieldRef<"DailyAnalytics", 'Int'>
    readonly neutralSentiment: FieldRef<"DailyAnalytics", 'Int'>
    readonly negativeSentiment: FieldRef<"DailyAnalytics", 'Int'>
    readonly topTopics: FieldRef<"DailyAnalytics", 'Json'>
    readonly peakHours: FieldRef<"DailyAnalytics", 'Json'>
    readonly createdAt: FieldRef<"DailyAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyAnalytics findUnique
   */
  export type DailyAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which DailyAnalytics to fetch.
     */
    where: DailyAnalyticsWhereUniqueInput
  }

  /**
   * DailyAnalytics findUniqueOrThrow
   */
  export type DailyAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which DailyAnalytics to fetch.
     */
    where: DailyAnalyticsWhereUniqueInput
  }

  /**
   * DailyAnalytics findFirst
   */
  export type DailyAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which DailyAnalytics to fetch.
     */
    where?: DailyAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAnalytics to fetch.
     */
    orderBy?: DailyAnalyticsOrderByWithRelationInput | DailyAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyAnalytics.
     */
    cursor?: DailyAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyAnalytics.
     */
    distinct?: DailyAnalyticsScalarFieldEnum | DailyAnalyticsScalarFieldEnum[]
  }

  /**
   * DailyAnalytics findFirstOrThrow
   */
  export type DailyAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which DailyAnalytics to fetch.
     */
    where?: DailyAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAnalytics to fetch.
     */
    orderBy?: DailyAnalyticsOrderByWithRelationInput | DailyAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyAnalytics.
     */
    cursor?: DailyAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyAnalytics.
     */
    distinct?: DailyAnalyticsScalarFieldEnum | DailyAnalyticsScalarFieldEnum[]
  }

  /**
   * DailyAnalytics findMany
   */
  export type DailyAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which DailyAnalytics to fetch.
     */
    where?: DailyAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAnalytics to fetch.
     */
    orderBy?: DailyAnalyticsOrderByWithRelationInput | DailyAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyAnalytics.
     */
    cursor?: DailyAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAnalytics.
     */
    skip?: number
    distinct?: DailyAnalyticsScalarFieldEnum | DailyAnalyticsScalarFieldEnum[]
  }

  /**
   * DailyAnalytics create
   */
  export type DailyAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a DailyAnalytics.
     */
    data: XOR<DailyAnalyticsCreateInput, DailyAnalyticsUncheckedCreateInput>
  }

  /**
   * DailyAnalytics createMany
   */
  export type DailyAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyAnalytics.
     */
    data: DailyAnalyticsCreateManyInput | DailyAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyAnalytics createManyAndReturn
   */
  export type DailyAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyAnalytics.
     */
    data: DailyAnalyticsCreateManyInput | DailyAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyAnalytics update
   */
  export type DailyAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a DailyAnalytics.
     */
    data: XOR<DailyAnalyticsUpdateInput, DailyAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which DailyAnalytics to update.
     */
    where: DailyAnalyticsWhereUniqueInput
  }

  /**
   * DailyAnalytics updateMany
   */
  export type DailyAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyAnalytics.
     */
    data: XOR<DailyAnalyticsUpdateManyMutationInput, DailyAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which DailyAnalytics to update
     */
    where?: DailyAnalyticsWhereInput
  }

  /**
   * DailyAnalytics upsert
   */
  export type DailyAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the DailyAnalytics to update in case it exists.
     */
    where: DailyAnalyticsWhereUniqueInput
    /**
     * In case the DailyAnalytics found by the `where` argument doesn't exist, create a new DailyAnalytics with this data.
     */
    create: XOR<DailyAnalyticsCreateInput, DailyAnalyticsUncheckedCreateInput>
    /**
     * In case the DailyAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyAnalyticsUpdateInput, DailyAnalyticsUncheckedUpdateInput>
  }

  /**
   * DailyAnalytics delete
   */
  export type DailyAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which DailyAnalytics to delete.
     */
    where: DailyAnalyticsWhereUniqueInput
  }

  /**
   * DailyAnalytics deleteMany
   */
  export type DailyAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyAnalytics to delete
     */
    where?: DailyAnalyticsWhereInput
  }

  /**
   * DailyAnalytics without action
   */
  export type DailyAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAnalytics
     */
    select?: DailyAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model Business
   */

  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    phone: string | null
    timezone: string | null
    defaultVoiceId: string | null
    greeting: string | null
    voicemailPrompt: string | null
    holdMusicUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    phone: string | null
    timezone: string | null
    defaultVoiceId: string | null
    greeting: string | null
    voicemailPrompt: string | null
    holdMusicUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    phone: number
    timezone: number
    inboundConfig: number
    outboundConfig: number
    defaultVoiceId: number
    greeting: number
    voicemailPrompt: number
    holdMusicUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    timezone?: true
    defaultVoiceId?: true
    greeting?: true
    voicemailPrompt?: true
    holdMusicUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    timezone?: true
    defaultVoiceId?: true
    greeting?: true
    voicemailPrompt?: true
    holdMusicUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    timezone?: true
    inboundConfig?: true
    outboundConfig?: true
    defaultVoiceId?: true
    greeting?: true
    voicemailPrompt?: true
    holdMusicUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithAggregationInput | BusinessOrderByWithAggregationInput[]
    by: BusinessScalarFieldEnum[] | BusinessScalarFieldEnum
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }

  export type BusinessGroupByOutputType = {
    id: string
    userId: string
    name: string
    phone: string | null
    timezone: string
    inboundConfig: JsonValue | null
    outboundConfig: JsonValue | null
    defaultVoiceId: string | null
    greeting: string | null
    voicemailPrompt: string | null
    holdMusicUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: BusinessCountAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    timezone?: boolean
    inboundConfig?: boolean
    outboundConfig?: boolean
    defaultVoiceId?: boolean
    greeting?: boolean
    voicemailPrompt?: boolean
    holdMusicUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inboundCalls?: boolean | Business$inboundCallsArgs<ExtArgs>
    outboundCalls?: boolean | Business$outboundCallsArgs<ExtArgs>
    routingRules?: boolean | Business$routingRulesArgs<ExtArgs>
    campaigns?: boolean | Business$campaignsArgs<ExtArgs>
    callQueue?: boolean | Business$callQueueArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    timezone?: boolean
    inboundConfig?: boolean
    outboundConfig?: boolean
    defaultVoiceId?: boolean
    greeting?: boolean
    voicemailPrompt?: boolean
    holdMusicUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    timezone?: boolean
    inboundConfig?: boolean
    outboundConfig?: boolean
    defaultVoiceId?: boolean
    greeting?: boolean
    voicemailPrompt?: boolean
    holdMusicUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inboundCalls?: boolean | Business$inboundCallsArgs<ExtArgs>
    outboundCalls?: boolean | Business$outboundCallsArgs<ExtArgs>
    routingRules?: boolean | Business$routingRulesArgs<ExtArgs>
    campaigns?: boolean | Business$campaignsArgs<ExtArgs>
    callQueue?: boolean | Business$callQueueArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Business"
    objects: {
      inboundCalls: Prisma.$InboundCallPayload<ExtArgs>[]
      outboundCalls: Prisma.$OutboundCallPayload<ExtArgs>[]
      routingRules: Prisma.$CallRoutingRulePayload<ExtArgs>[]
      campaigns: Prisma.$OutboundCampaignPayload<ExtArgs>[]
      callQueue: Prisma.$CallQueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      phone: string | null
      timezone: string
      inboundConfig: Prisma.JsonValue | null
      outboundConfig: Prisma.JsonValue | null
      defaultVoiceId: string | null
      greeting: string | null
      voicemailPrompt: string | null
      holdMusicUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["business"]>
    composites: {}
  }

  type BusinessGetPayload<S extends boolean | null | undefined | BusinessDefaultArgs> = $Result.GetResult<Prisma.$BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFindUniqueArgs>(args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Business that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFindFirstArgs>(args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFindManyArgs>(args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
     */
    create<T extends BusinessCreateArgs>(args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Businesses.
     * @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCreateManyArgs>(args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Businesses and returns the data saved in the database.
     * @param {BusinessCreateManyAndReturnArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
     */
    delete<T extends BusinessDeleteArgs>(args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUpdateArgs>(args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDeleteManyArgs>(args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUpdateManyArgs>(args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUpsertArgs>(args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Business model
   */
  readonly fields: BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inboundCalls<T extends Business$inboundCallsArgs<ExtArgs> = {}>(args?: Subset<T, Business$inboundCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "findMany"> | Null>
    outboundCalls<T extends Business$outboundCallsArgs<ExtArgs> = {}>(args?: Subset<T, Business$outboundCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "findMany"> | Null>
    routingRules<T extends Business$routingRulesArgs<ExtArgs> = {}>(args?: Subset<T, Business$routingRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "findMany"> | Null>
    campaigns<T extends Business$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Business$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "findMany"> | Null>
    callQueue<T extends Business$callQueueArgs<ExtArgs> = {}>(args?: Subset<T, Business$callQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Business model
   */ 
  interface BusinessFieldRefs {
    readonly id: FieldRef<"Business", 'String'>
    readonly userId: FieldRef<"Business", 'String'>
    readonly name: FieldRef<"Business", 'String'>
    readonly phone: FieldRef<"Business", 'String'>
    readonly timezone: FieldRef<"Business", 'String'>
    readonly inboundConfig: FieldRef<"Business", 'Json'>
    readonly outboundConfig: FieldRef<"Business", 'Json'>
    readonly defaultVoiceId: FieldRef<"Business", 'String'>
    readonly greeting: FieldRef<"Business", 'String'>
    readonly voicemailPrompt: FieldRef<"Business", 'String'>
    readonly holdMusicUrl: FieldRef<"Business", 'String'>
    readonly createdAt: FieldRef<"Business", 'DateTime'>
    readonly updatedAt: FieldRef<"Business", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Business findUnique
   */
  export type BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findFirst
   */
  export type BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }

  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business createManyAndReturn
   */
  export type BusinessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
  }

  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }

  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
  }

  /**
   * Business.inboundCalls
   */
  export type Business$inboundCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    where?: InboundCallWhereInput
    orderBy?: InboundCallOrderByWithRelationInput | InboundCallOrderByWithRelationInput[]
    cursor?: InboundCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InboundCallScalarFieldEnum | InboundCallScalarFieldEnum[]
  }

  /**
   * Business.outboundCalls
   */
  export type Business$outboundCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    where?: OutboundCallWhereInput
    orderBy?: OutboundCallOrderByWithRelationInput | OutboundCallOrderByWithRelationInput[]
    cursor?: OutboundCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutboundCallScalarFieldEnum | OutboundCallScalarFieldEnum[]
  }

  /**
   * Business.routingRules
   */
  export type Business$routingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    where?: CallRoutingRuleWhereInput
    orderBy?: CallRoutingRuleOrderByWithRelationInput | CallRoutingRuleOrderByWithRelationInput[]
    cursor?: CallRoutingRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallRoutingRuleScalarFieldEnum | CallRoutingRuleScalarFieldEnum[]
  }

  /**
   * Business.campaigns
   */
  export type Business$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    where?: OutboundCampaignWhereInput
    orderBy?: OutboundCampaignOrderByWithRelationInput | OutboundCampaignOrderByWithRelationInput[]
    cursor?: OutboundCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutboundCampaignScalarFieldEnum | OutboundCampaignScalarFieldEnum[]
  }

  /**
   * Business.callQueue
   */
  export type Business$callQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    where?: CallQueueWhereInput
    orderBy?: CallQueueOrderByWithRelationInput | CallQueueOrderByWithRelationInput[]
    cursor?: CallQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallQueueScalarFieldEnum | CallQueueScalarFieldEnum[]
  }

  /**
   * Business without action
   */
  export type BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
  }


  /**
   * Model InboundCall
   */

  export type AggregateInboundCall = {
    _count: InboundCallCountAggregateOutputType | null
    _avg: InboundCallAvgAggregateOutputType | null
    _sum: InboundCallSumAggregateOutputType | null
    _min: InboundCallMinAggregateOutputType | null
    _max: InboundCallMaxAggregateOutputType | null
  }

  export type InboundCallAvgAggregateOutputType = {
    duration: number | null
    waitTime: number | null
  }

  export type InboundCallSumAggregateOutputType = {
    duration: number | null
    waitTime: number | null
  }

  export type InboundCallMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    callerNumber: string | null
    callerName: string | null
    status: $Enums.InboundCallStatus | null
    duration: number | null
    waitTime: number | null
    routedTo: string | null
    routingRuleId: string | null
    transcript: string | null
    summary: string | null
    sentiment: $Enums.Sentiment | null
    externalCallId: string | null
    recordingUrl: string | null
    startedAt: Date | null
    answeredAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InboundCallMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    callerNumber: string | null
    callerName: string | null
    status: $Enums.InboundCallStatus | null
    duration: number | null
    waitTime: number | null
    routedTo: string | null
    routingRuleId: string | null
    transcript: string | null
    summary: string | null
    sentiment: $Enums.Sentiment | null
    externalCallId: string | null
    recordingUrl: string | null
    startedAt: Date | null
    answeredAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InboundCallCountAggregateOutputType = {
    id: number
    businessId: number
    callerNumber: number
    callerName: number
    status: number
    duration: number
    waitTime: number
    routedTo: number
    routingRuleId: number
    transcript: number
    summary: number
    sentiment: number
    tags: number
    externalCallId: number
    recordingUrl: number
    startedAt: number
    answeredAt: number
    endedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InboundCallAvgAggregateInputType = {
    duration?: true
    waitTime?: true
  }

  export type InboundCallSumAggregateInputType = {
    duration?: true
    waitTime?: true
  }

  export type InboundCallMinAggregateInputType = {
    id?: true
    businessId?: true
    callerNumber?: true
    callerName?: true
    status?: true
    duration?: true
    waitTime?: true
    routedTo?: true
    routingRuleId?: true
    transcript?: true
    summary?: true
    sentiment?: true
    externalCallId?: true
    recordingUrl?: true
    startedAt?: true
    answeredAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InboundCallMaxAggregateInputType = {
    id?: true
    businessId?: true
    callerNumber?: true
    callerName?: true
    status?: true
    duration?: true
    waitTime?: true
    routedTo?: true
    routingRuleId?: true
    transcript?: true
    summary?: true
    sentiment?: true
    externalCallId?: true
    recordingUrl?: true
    startedAt?: true
    answeredAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InboundCallCountAggregateInputType = {
    id?: true
    businessId?: true
    callerNumber?: true
    callerName?: true
    status?: true
    duration?: true
    waitTime?: true
    routedTo?: true
    routingRuleId?: true
    transcript?: true
    summary?: true
    sentiment?: true
    tags?: true
    externalCallId?: true
    recordingUrl?: true
    startedAt?: true
    answeredAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InboundCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InboundCall to aggregate.
     */
    where?: InboundCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InboundCalls to fetch.
     */
    orderBy?: InboundCallOrderByWithRelationInput | InboundCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InboundCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InboundCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InboundCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InboundCalls
    **/
    _count?: true | InboundCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InboundCallAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InboundCallSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InboundCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InboundCallMaxAggregateInputType
  }

  export type GetInboundCallAggregateType<T extends InboundCallAggregateArgs> = {
        [P in keyof T & keyof AggregateInboundCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInboundCall[P]>
      : GetScalarType<T[P], AggregateInboundCall[P]>
  }




  export type InboundCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InboundCallWhereInput
    orderBy?: InboundCallOrderByWithAggregationInput | InboundCallOrderByWithAggregationInput[]
    by: InboundCallScalarFieldEnum[] | InboundCallScalarFieldEnum
    having?: InboundCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InboundCallCountAggregateInputType | true
    _avg?: InboundCallAvgAggregateInputType
    _sum?: InboundCallSumAggregateInputType
    _min?: InboundCallMinAggregateInputType
    _max?: InboundCallMaxAggregateInputType
  }

  export type InboundCallGroupByOutputType = {
    id: string
    businessId: string
    callerNumber: string
    callerName: string | null
    status: $Enums.InboundCallStatus
    duration: number | null
    waitTime: number | null
    routedTo: string | null
    routingRuleId: string | null
    transcript: string | null
    summary: string | null
    sentiment: $Enums.Sentiment | null
    tags: string[]
    externalCallId: string | null
    recordingUrl: string | null
    startedAt: Date
    answeredAt: Date | null
    endedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InboundCallCountAggregateOutputType | null
    _avg: InboundCallAvgAggregateOutputType | null
    _sum: InboundCallSumAggregateOutputType | null
    _min: InboundCallMinAggregateOutputType | null
    _max: InboundCallMaxAggregateOutputType | null
  }

  type GetInboundCallGroupByPayload<T extends InboundCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InboundCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InboundCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InboundCallGroupByOutputType[P]>
            : GetScalarType<T[P], InboundCallGroupByOutputType[P]>
        }
      >
    >


  export type InboundCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    callerNumber?: boolean
    callerName?: boolean
    status?: boolean
    duration?: boolean
    waitTime?: boolean
    routedTo?: boolean
    routingRuleId?: boolean
    transcript?: boolean
    summary?: boolean
    sentiment?: boolean
    tags?: boolean
    externalCallId?: boolean
    recordingUrl?: boolean
    startedAt?: boolean
    answeredAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inboundCall"]>

  export type InboundCallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    callerNumber?: boolean
    callerName?: boolean
    status?: boolean
    duration?: boolean
    waitTime?: boolean
    routedTo?: boolean
    routingRuleId?: boolean
    transcript?: boolean
    summary?: boolean
    sentiment?: boolean
    tags?: boolean
    externalCallId?: boolean
    recordingUrl?: boolean
    startedAt?: boolean
    answeredAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inboundCall"]>

  export type InboundCallSelectScalar = {
    id?: boolean
    businessId?: boolean
    callerNumber?: boolean
    callerName?: boolean
    status?: boolean
    duration?: boolean
    waitTime?: boolean
    routedTo?: boolean
    routingRuleId?: boolean
    transcript?: boolean
    summary?: boolean
    sentiment?: boolean
    tags?: boolean
    externalCallId?: boolean
    recordingUrl?: boolean
    startedAt?: boolean
    answeredAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InboundCallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type InboundCallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $InboundCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InboundCall"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      callerNumber: string
      callerName: string | null
      status: $Enums.InboundCallStatus
      duration: number | null
      waitTime: number | null
      routedTo: string | null
      routingRuleId: string | null
      transcript: string | null
      summary: string | null
      sentiment: $Enums.Sentiment | null
      tags: string[]
      externalCallId: string | null
      recordingUrl: string | null
      startedAt: Date
      answeredAt: Date | null
      endedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inboundCall"]>
    composites: {}
  }

  type InboundCallGetPayload<S extends boolean | null | undefined | InboundCallDefaultArgs> = $Result.GetResult<Prisma.$InboundCallPayload, S>

  type InboundCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InboundCallFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InboundCallCountAggregateInputType | true
    }

  export interface InboundCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InboundCall'], meta: { name: 'InboundCall' } }
    /**
     * Find zero or one InboundCall that matches the filter.
     * @param {InboundCallFindUniqueArgs} args - Arguments to find a InboundCall
     * @example
     * // Get one InboundCall
     * const inboundCall = await prisma.inboundCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InboundCallFindUniqueArgs>(args: SelectSubset<T, InboundCallFindUniqueArgs<ExtArgs>>): Prisma__InboundCallClient<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InboundCall that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InboundCallFindUniqueOrThrowArgs} args - Arguments to find a InboundCall
     * @example
     * // Get one InboundCall
     * const inboundCall = await prisma.inboundCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InboundCallFindUniqueOrThrowArgs>(args: SelectSubset<T, InboundCallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InboundCallClient<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InboundCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboundCallFindFirstArgs} args - Arguments to find a InboundCall
     * @example
     * // Get one InboundCall
     * const inboundCall = await prisma.inboundCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InboundCallFindFirstArgs>(args?: SelectSubset<T, InboundCallFindFirstArgs<ExtArgs>>): Prisma__InboundCallClient<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InboundCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboundCallFindFirstOrThrowArgs} args - Arguments to find a InboundCall
     * @example
     * // Get one InboundCall
     * const inboundCall = await prisma.inboundCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InboundCallFindFirstOrThrowArgs>(args?: SelectSubset<T, InboundCallFindFirstOrThrowArgs<ExtArgs>>): Prisma__InboundCallClient<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InboundCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboundCallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InboundCalls
     * const inboundCalls = await prisma.inboundCall.findMany()
     * 
     * // Get first 10 InboundCalls
     * const inboundCalls = await prisma.inboundCall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inboundCallWithIdOnly = await prisma.inboundCall.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InboundCallFindManyArgs>(args?: SelectSubset<T, InboundCallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InboundCall.
     * @param {InboundCallCreateArgs} args - Arguments to create a InboundCall.
     * @example
     * // Create one InboundCall
     * const InboundCall = await prisma.inboundCall.create({
     *   data: {
     *     // ... data to create a InboundCall
     *   }
     * })
     * 
     */
    create<T extends InboundCallCreateArgs>(args: SelectSubset<T, InboundCallCreateArgs<ExtArgs>>): Prisma__InboundCallClient<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InboundCalls.
     * @param {InboundCallCreateManyArgs} args - Arguments to create many InboundCalls.
     * @example
     * // Create many InboundCalls
     * const inboundCall = await prisma.inboundCall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InboundCallCreateManyArgs>(args?: SelectSubset<T, InboundCallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InboundCalls and returns the data saved in the database.
     * @param {InboundCallCreateManyAndReturnArgs} args - Arguments to create many InboundCalls.
     * @example
     * // Create many InboundCalls
     * const inboundCall = await prisma.inboundCall.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InboundCalls and only return the `id`
     * const inboundCallWithIdOnly = await prisma.inboundCall.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InboundCallCreateManyAndReturnArgs>(args?: SelectSubset<T, InboundCallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InboundCall.
     * @param {InboundCallDeleteArgs} args - Arguments to delete one InboundCall.
     * @example
     * // Delete one InboundCall
     * const InboundCall = await prisma.inboundCall.delete({
     *   where: {
     *     // ... filter to delete one InboundCall
     *   }
     * })
     * 
     */
    delete<T extends InboundCallDeleteArgs>(args: SelectSubset<T, InboundCallDeleteArgs<ExtArgs>>): Prisma__InboundCallClient<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InboundCall.
     * @param {InboundCallUpdateArgs} args - Arguments to update one InboundCall.
     * @example
     * // Update one InboundCall
     * const inboundCall = await prisma.inboundCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InboundCallUpdateArgs>(args: SelectSubset<T, InboundCallUpdateArgs<ExtArgs>>): Prisma__InboundCallClient<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InboundCalls.
     * @param {InboundCallDeleteManyArgs} args - Arguments to filter InboundCalls to delete.
     * @example
     * // Delete a few InboundCalls
     * const { count } = await prisma.inboundCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InboundCallDeleteManyArgs>(args?: SelectSubset<T, InboundCallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InboundCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboundCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InboundCalls
     * const inboundCall = await prisma.inboundCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InboundCallUpdateManyArgs>(args: SelectSubset<T, InboundCallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InboundCall.
     * @param {InboundCallUpsertArgs} args - Arguments to update or create a InboundCall.
     * @example
     * // Update or create a InboundCall
     * const inboundCall = await prisma.inboundCall.upsert({
     *   create: {
     *     // ... data to create a InboundCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InboundCall we want to update
     *   }
     * })
     */
    upsert<T extends InboundCallUpsertArgs>(args: SelectSubset<T, InboundCallUpsertArgs<ExtArgs>>): Prisma__InboundCallClient<$Result.GetResult<Prisma.$InboundCallPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InboundCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboundCallCountArgs} args - Arguments to filter InboundCalls to count.
     * @example
     * // Count the number of InboundCalls
     * const count = await prisma.inboundCall.count({
     *   where: {
     *     // ... the filter for the InboundCalls we want to count
     *   }
     * })
    **/
    count<T extends InboundCallCountArgs>(
      args?: Subset<T, InboundCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InboundCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InboundCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboundCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InboundCallAggregateArgs>(args: Subset<T, InboundCallAggregateArgs>): Prisma.PrismaPromise<GetInboundCallAggregateType<T>>

    /**
     * Group by InboundCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InboundCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InboundCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InboundCallGroupByArgs['orderBy'] }
        : { orderBy?: InboundCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InboundCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInboundCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InboundCall model
   */
  readonly fields: InboundCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InboundCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InboundCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InboundCall model
   */ 
  interface InboundCallFieldRefs {
    readonly id: FieldRef<"InboundCall", 'String'>
    readonly businessId: FieldRef<"InboundCall", 'String'>
    readonly callerNumber: FieldRef<"InboundCall", 'String'>
    readonly callerName: FieldRef<"InboundCall", 'String'>
    readonly status: FieldRef<"InboundCall", 'InboundCallStatus'>
    readonly duration: FieldRef<"InboundCall", 'Int'>
    readonly waitTime: FieldRef<"InboundCall", 'Int'>
    readonly routedTo: FieldRef<"InboundCall", 'String'>
    readonly routingRuleId: FieldRef<"InboundCall", 'String'>
    readonly transcript: FieldRef<"InboundCall", 'String'>
    readonly summary: FieldRef<"InboundCall", 'String'>
    readonly sentiment: FieldRef<"InboundCall", 'Sentiment'>
    readonly tags: FieldRef<"InboundCall", 'String[]'>
    readonly externalCallId: FieldRef<"InboundCall", 'String'>
    readonly recordingUrl: FieldRef<"InboundCall", 'String'>
    readonly startedAt: FieldRef<"InboundCall", 'DateTime'>
    readonly answeredAt: FieldRef<"InboundCall", 'DateTime'>
    readonly endedAt: FieldRef<"InboundCall", 'DateTime'>
    readonly createdAt: FieldRef<"InboundCall", 'DateTime'>
    readonly updatedAt: FieldRef<"InboundCall", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InboundCall findUnique
   */
  export type InboundCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * Filter, which InboundCall to fetch.
     */
    where: InboundCallWhereUniqueInput
  }

  /**
   * InboundCall findUniqueOrThrow
   */
  export type InboundCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * Filter, which InboundCall to fetch.
     */
    where: InboundCallWhereUniqueInput
  }

  /**
   * InboundCall findFirst
   */
  export type InboundCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * Filter, which InboundCall to fetch.
     */
    where?: InboundCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InboundCalls to fetch.
     */
    orderBy?: InboundCallOrderByWithRelationInput | InboundCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InboundCalls.
     */
    cursor?: InboundCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InboundCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InboundCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InboundCalls.
     */
    distinct?: InboundCallScalarFieldEnum | InboundCallScalarFieldEnum[]
  }

  /**
   * InboundCall findFirstOrThrow
   */
  export type InboundCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * Filter, which InboundCall to fetch.
     */
    where?: InboundCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InboundCalls to fetch.
     */
    orderBy?: InboundCallOrderByWithRelationInput | InboundCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InboundCalls.
     */
    cursor?: InboundCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InboundCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InboundCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InboundCalls.
     */
    distinct?: InboundCallScalarFieldEnum | InboundCallScalarFieldEnum[]
  }

  /**
   * InboundCall findMany
   */
  export type InboundCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * Filter, which InboundCalls to fetch.
     */
    where?: InboundCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InboundCalls to fetch.
     */
    orderBy?: InboundCallOrderByWithRelationInput | InboundCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InboundCalls.
     */
    cursor?: InboundCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InboundCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InboundCalls.
     */
    skip?: number
    distinct?: InboundCallScalarFieldEnum | InboundCallScalarFieldEnum[]
  }

  /**
   * InboundCall create
   */
  export type InboundCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * The data needed to create a InboundCall.
     */
    data: XOR<InboundCallCreateInput, InboundCallUncheckedCreateInput>
  }

  /**
   * InboundCall createMany
   */
  export type InboundCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InboundCalls.
     */
    data: InboundCallCreateManyInput | InboundCallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InboundCall createManyAndReturn
   */
  export type InboundCallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InboundCalls.
     */
    data: InboundCallCreateManyInput | InboundCallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InboundCall update
   */
  export type InboundCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * The data needed to update a InboundCall.
     */
    data: XOR<InboundCallUpdateInput, InboundCallUncheckedUpdateInput>
    /**
     * Choose, which InboundCall to update.
     */
    where: InboundCallWhereUniqueInput
  }

  /**
   * InboundCall updateMany
   */
  export type InboundCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InboundCalls.
     */
    data: XOR<InboundCallUpdateManyMutationInput, InboundCallUncheckedUpdateManyInput>
    /**
     * Filter which InboundCalls to update
     */
    where?: InboundCallWhereInput
  }

  /**
   * InboundCall upsert
   */
  export type InboundCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * The filter to search for the InboundCall to update in case it exists.
     */
    where: InboundCallWhereUniqueInput
    /**
     * In case the InboundCall found by the `where` argument doesn't exist, create a new InboundCall with this data.
     */
    create: XOR<InboundCallCreateInput, InboundCallUncheckedCreateInput>
    /**
     * In case the InboundCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InboundCallUpdateInput, InboundCallUncheckedUpdateInput>
  }

  /**
   * InboundCall delete
   */
  export type InboundCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
    /**
     * Filter which InboundCall to delete.
     */
    where: InboundCallWhereUniqueInput
  }

  /**
   * InboundCall deleteMany
   */
  export type InboundCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InboundCalls to delete
     */
    where?: InboundCallWhereInput
  }

  /**
   * InboundCall without action
   */
  export type InboundCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InboundCall
     */
    select?: InboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InboundCallInclude<ExtArgs> | null
  }


  /**
   * Model OutboundCall
   */

  export type AggregateOutboundCall = {
    _count: OutboundCallCountAggregateOutputType | null
    _avg: OutboundCallAvgAggregateOutputType | null
    _sum: OutboundCallSumAggregateOutputType | null
    _min: OutboundCallMinAggregateOutputType | null
    _max: OutboundCallMaxAggregateOutputType | null
  }

  export type OutboundCallAvgAggregateOutputType = {
    duration: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type OutboundCallSumAggregateOutputType = {
    duration: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type OutboundCallMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    recipientNumber: string | null
    recipientName: string | null
    campaignId: string | null
    status: $Enums.OutboundCallStatus | null
    result: $Enums.CallResult | null
    duration: number | null
    attempts: number | null
    maxAttempts: number | null
    scriptUsed: string | null
    transcript: string | null
    notes: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    externalCallId: string | null
    recordingUrl: string | null
    isCallback: boolean | null
    callbackReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutboundCallMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    recipientNumber: string | null
    recipientName: string | null
    campaignId: string | null
    status: $Enums.OutboundCallStatus | null
    result: $Enums.CallResult | null
    duration: number | null
    attempts: number | null
    maxAttempts: number | null
    scriptUsed: string | null
    transcript: string | null
    notes: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    externalCallId: string | null
    recordingUrl: string | null
    isCallback: boolean | null
    callbackReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutboundCallCountAggregateOutputType = {
    id: number
    businessId: number
    recipientNumber: number
    recipientName: number
    campaignId: number
    status: number
    result: number
    duration: number
    attempts: number
    maxAttempts: number
    scriptUsed: number
    transcript: number
    notes: number
    scheduledAt: number
    startedAt: number
    completedAt: number
    externalCallId: number
    recordingUrl: number
    isCallback: number
    callbackReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutboundCallAvgAggregateInputType = {
    duration?: true
    attempts?: true
    maxAttempts?: true
  }

  export type OutboundCallSumAggregateInputType = {
    duration?: true
    attempts?: true
    maxAttempts?: true
  }

  export type OutboundCallMinAggregateInputType = {
    id?: true
    businessId?: true
    recipientNumber?: true
    recipientName?: true
    campaignId?: true
    status?: true
    result?: true
    duration?: true
    attempts?: true
    maxAttempts?: true
    scriptUsed?: true
    transcript?: true
    notes?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    externalCallId?: true
    recordingUrl?: true
    isCallback?: true
    callbackReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutboundCallMaxAggregateInputType = {
    id?: true
    businessId?: true
    recipientNumber?: true
    recipientName?: true
    campaignId?: true
    status?: true
    result?: true
    duration?: true
    attempts?: true
    maxAttempts?: true
    scriptUsed?: true
    transcript?: true
    notes?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    externalCallId?: true
    recordingUrl?: true
    isCallback?: true
    callbackReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutboundCallCountAggregateInputType = {
    id?: true
    businessId?: true
    recipientNumber?: true
    recipientName?: true
    campaignId?: true
    status?: true
    result?: true
    duration?: true
    attempts?: true
    maxAttempts?: true
    scriptUsed?: true
    transcript?: true
    notes?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    externalCallId?: true
    recordingUrl?: true
    isCallback?: true
    callbackReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutboundCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboundCall to aggregate.
     */
    where?: OutboundCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundCalls to fetch.
     */
    orderBy?: OutboundCallOrderByWithRelationInput | OutboundCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutboundCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutboundCalls
    **/
    _count?: true | OutboundCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutboundCallAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutboundCallSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutboundCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutboundCallMaxAggregateInputType
  }

  export type GetOutboundCallAggregateType<T extends OutboundCallAggregateArgs> = {
        [P in keyof T & keyof AggregateOutboundCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutboundCall[P]>
      : GetScalarType<T[P], AggregateOutboundCall[P]>
  }




  export type OutboundCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundCallWhereInput
    orderBy?: OutboundCallOrderByWithAggregationInput | OutboundCallOrderByWithAggregationInput[]
    by: OutboundCallScalarFieldEnum[] | OutboundCallScalarFieldEnum
    having?: OutboundCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutboundCallCountAggregateInputType | true
    _avg?: OutboundCallAvgAggregateInputType
    _sum?: OutboundCallSumAggregateInputType
    _min?: OutboundCallMinAggregateInputType
    _max?: OutboundCallMaxAggregateInputType
  }

  export type OutboundCallGroupByOutputType = {
    id: string
    businessId: string
    recipientNumber: string
    recipientName: string | null
    campaignId: string | null
    status: $Enums.OutboundCallStatus
    result: $Enums.CallResult | null
    duration: number | null
    attempts: number
    maxAttempts: number
    scriptUsed: string | null
    transcript: string | null
    notes: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    externalCallId: string | null
    recordingUrl: string | null
    isCallback: boolean
    callbackReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: OutboundCallCountAggregateOutputType | null
    _avg: OutboundCallAvgAggregateOutputType | null
    _sum: OutboundCallSumAggregateOutputType | null
    _min: OutboundCallMinAggregateOutputType | null
    _max: OutboundCallMaxAggregateOutputType | null
  }

  type GetOutboundCallGroupByPayload<T extends OutboundCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutboundCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutboundCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutboundCallGroupByOutputType[P]>
            : GetScalarType<T[P], OutboundCallGroupByOutputType[P]>
        }
      >
    >


  export type OutboundCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    recipientNumber?: boolean
    recipientName?: boolean
    campaignId?: boolean
    status?: boolean
    result?: boolean
    duration?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scriptUsed?: boolean
    transcript?: boolean
    notes?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    externalCallId?: boolean
    recordingUrl?: boolean
    isCallback?: boolean
    callbackReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    campaign?: boolean | OutboundCall$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["outboundCall"]>

  export type OutboundCallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    recipientNumber?: boolean
    recipientName?: boolean
    campaignId?: boolean
    status?: boolean
    result?: boolean
    duration?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scriptUsed?: boolean
    transcript?: boolean
    notes?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    externalCallId?: boolean
    recordingUrl?: boolean
    isCallback?: boolean
    callbackReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    campaign?: boolean | OutboundCall$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["outboundCall"]>

  export type OutboundCallSelectScalar = {
    id?: boolean
    businessId?: boolean
    recipientNumber?: boolean
    recipientName?: boolean
    campaignId?: boolean
    status?: boolean
    result?: boolean
    duration?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scriptUsed?: boolean
    transcript?: boolean
    notes?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    externalCallId?: boolean
    recordingUrl?: boolean
    isCallback?: boolean
    callbackReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutboundCallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    campaign?: boolean | OutboundCall$campaignArgs<ExtArgs>
  }
  export type OutboundCallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    campaign?: boolean | OutboundCall$campaignArgs<ExtArgs>
  }

  export type $OutboundCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutboundCall"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      campaign: Prisma.$OutboundCampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      recipientNumber: string
      recipientName: string | null
      campaignId: string | null
      status: $Enums.OutboundCallStatus
      result: $Enums.CallResult | null
      duration: number | null
      attempts: number
      maxAttempts: number
      scriptUsed: string | null
      transcript: string | null
      notes: string | null
      scheduledAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      externalCallId: string | null
      recordingUrl: string | null
      isCallback: boolean
      callbackReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outboundCall"]>
    composites: {}
  }

  type OutboundCallGetPayload<S extends boolean | null | undefined | OutboundCallDefaultArgs> = $Result.GetResult<Prisma.$OutboundCallPayload, S>

  type OutboundCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OutboundCallFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OutboundCallCountAggregateInputType | true
    }

  export interface OutboundCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutboundCall'], meta: { name: 'OutboundCall' } }
    /**
     * Find zero or one OutboundCall that matches the filter.
     * @param {OutboundCallFindUniqueArgs} args - Arguments to find a OutboundCall
     * @example
     * // Get one OutboundCall
     * const outboundCall = await prisma.outboundCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutboundCallFindUniqueArgs>(args: SelectSubset<T, OutboundCallFindUniqueArgs<ExtArgs>>): Prisma__OutboundCallClient<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OutboundCall that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OutboundCallFindUniqueOrThrowArgs} args - Arguments to find a OutboundCall
     * @example
     * // Get one OutboundCall
     * const outboundCall = await prisma.outboundCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutboundCallFindUniqueOrThrowArgs>(args: SelectSubset<T, OutboundCallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutboundCallClient<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OutboundCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCallFindFirstArgs} args - Arguments to find a OutboundCall
     * @example
     * // Get one OutboundCall
     * const outboundCall = await prisma.outboundCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutboundCallFindFirstArgs>(args?: SelectSubset<T, OutboundCallFindFirstArgs<ExtArgs>>): Prisma__OutboundCallClient<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OutboundCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCallFindFirstOrThrowArgs} args - Arguments to find a OutboundCall
     * @example
     * // Get one OutboundCall
     * const outboundCall = await prisma.outboundCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutboundCallFindFirstOrThrowArgs>(args?: SelectSubset<T, OutboundCallFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutboundCallClient<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OutboundCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutboundCalls
     * const outboundCalls = await prisma.outboundCall.findMany()
     * 
     * // Get first 10 OutboundCalls
     * const outboundCalls = await prisma.outboundCall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outboundCallWithIdOnly = await prisma.outboundCall.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutboundCallFindManyArgs>(args?: SelectSubset<T, OutboundCallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OutboundCall.
     * @param {OutboundCallCreateArgs} args - Arguments to create a OutboundCall.
     * @example
     * // Create one OutboundCall
     * const OutboundCall = await prisma.outboundCall.create({
     *   data: {
     *     // ... data to create a OutboundCall
     *   }
     * })
     * 
     */
    create<T extends OutboundCallCreateArgs>(args: SelectSubset<T, OutboundCallCreateArgs<ExtArgs>>): Prisma__OutboundCallClient<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OutboundCalls.
     * @param {OutboundCallCreateManyArgs} args - Arguments to create many OutboundCalls.
     * @example
     * // Create many OutboundCalls
     * const outboundCall = await prisma.outboundCall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutboundCallCreateManyArgs>(args?: SelectSubset<T, OutboundCallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutboundCalls and returns the data saved in the database.
     * @param {OutboundCallCreateManyAndReturnArgs} args - Arguments to create many OutboundCalls.
     * @example
     * // Create many OutboundCalls
     * const outboundCall = await prisma.outboundCall.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutboundCalls and only return the `id`
     * const outboundCallWithIdOnly = await prisma.outboundCall.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutboundCallCreateManyAndReturnArgs>(args?: SelectSubset<T, OutboundCallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OutboundCall.
     * @param {OutboundCallDeleteArgs} args - Arguments to delete one OutboundCall.
     * @example
     * // Delete one OutboundCall
     * const OutboundCall = await prisma.outboundCall.delete({
     *   where: {
     *     // ... filter to delete one OutboundCall
     *   }
     * })
     * 
     */
    delete<T extends OutboundCallDeleteArgs>(args: SelectSubset<T, OutboundCallDeleteArgs<ExtArgs>>): Prisma__OutboundCallClient<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OutboundCall.
     * @param {OutboundCallUpdateArgs} args - Arguments to update one OutboundCall.
     * @example
     * // Update one OutboundCall
     * const outboundCall = await prisma.outboundCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutboundCallUpdateArgs>(args: SelectSubset<T, OutboundCallUpdateArgs<ExtArgs>>): Prisma__OutboundCallClient<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OutboundCalls.
     * @param {OutboundCallDeleteManyArgs} args - Arguments to filter OutboundCalls to delete.
     * @example
     * // Delete a few OutboundCalls
     * const { count } = await prisma.outboundCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutboundCallDeleteManyArgs>(args?: SelectSubset<T, OutboundCallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutboundCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutboundCalls
     * const outboundCall = await prisma.outboundCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutboundCallUpdateManyArgs>(args: SelectSubset<T, OutboundCallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutboundCall.
     * @param {OutboundCallUpsertArgs} args - Arguments to update or create a OutboundCall.
     * @example
     * // Update or create a OutboundCall
     * const outboundCall = await prisma.outboundCall.upsert({
     *   create: {
     *     // ... data to create a OutboundCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutboundCall we want to update
     *   }
     * })
     */
    upsert<T extends OutboundCallUpsertArgs>(args: SelectSubset<T, OutboundCallUpsertArgs<ExtArgs>>): Prisma__OutboundCallClient<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OutboundCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCallCountArgs} args - Arguments to filter OutboundCalls to count.
     * @example
     * // Count the number of OutboundCalls
     * const count = await prisma.outboundCall.count({
     *   where: {
     *     // ... the filter for the OutboundCalls we want to count
     *   }
     * })
    **/
    count<T extends OutboundCallCountArgs>(
      args?: Subset<T, OutboundCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutboundCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutboundCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutboundCallAggregateArgs>(args: Subset<T, OutboundCallAggregateArgs>): Prisma.PrismaPromise<GetOutboundCallAggregateType<T>>

    /**
     * Group by OutboundCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutboundCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutboundCallGroupByArgs['orderBy'] }
        : { orderBy?: OutboundCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutboundCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutboundCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutboundCall model
   */
  readonly fields: OutboundCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutboundCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutboundCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaign<T extends OutboundCall$campaignArgs<ExtArgs> = {}>(args?: Subset<T, OutboundCall$campaignArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutboundCall model
   */ 
  interface OutboundCallFieldRefs {
    readonly id: FieldRef<"OutboundCall", 'String'>
    readonly businessId: FieldRef<"OutboundCall", 'String'>
    readonly recipientNumber: FieldRef<"OutboundCall", 'String'>
    readonly recipientName: FieldRef<"OutboundCall", 'String'>
    readonly campaignId: FieldRef<"OutboundCall", 'String'>
    readonly status: FieldRef<"OutboundCall", 'OutboundCallStatus'>
    readonly result: FieldRef<"OutboundCall", 'CallResult'>
    readonly duration: FieldRef<"OutboundCall", 'Int'>
    readonly attempts: FieldRef<"OutboundCall", 'Int'>
    readonly maxAttempts: FieldRef<"OutboundCall", 'Int'>
    readonly scriptUsed: FieldRef<"OutboundCall", 'String'>
    readonly transcript: FieldRef<"OutboundCall", 'String'>
    readonly notes: FieldRef<"OutboundCall", 'String'>
    readonly scheduledAt: FieldRef<"OutboundCall", 'DateTime'>
    readonly startedAt: FieldRef<"OutboundCall", 'DateTime'>
    readonly completedAt: FieldRef<"OutboundCall", 'DateTime'>
    readonly externalCallId: FieldRef<"OutboundCall", 'String'>
    readonly recordingUrl: FieldRef<"OutboundCall", 'String'>
    readonly isCallback: FieldRef<"OutboundCall", 'Boolean'>
    readonly callbackReason: FieldRef<"OutboundCall", 'String'>
    readonly createdAt: FieldRef<"OutboundCall", 'DateTime'>
    readonly updatedAt: FieldRef<"OutboundCall", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutboundCall findUnique
   */
  export type OutboundCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCall to fetch.
     */
    where: OutboundCallWhereUniqueInput
  }

  /**
   * OutboundCall findUniqueOrThrow
   */
  export type OutboundCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCall to fetch.
     */
    where: OutboundCallWhereUniqueInput
  }

  /**
   * OutboundCall findFirst
   */
  export type OutboundCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCall to fetch.
     */
    where?: OutboundCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundCalls to fetch.
     */
    orderBy?: OutboundCallOrderByWithRelationInput | OutboundCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboundCalls.
     */
    cursor?: OutboundCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboundCalls.
     */
    distinct?: OutboundCallScalarFieldEnum | OutboundCallScalarFieldEnum[]
  }

  /**
   * OutboundCall findFirstOrThrow
   */
  export type OutboundCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCall to fetch.
     */
    where?: OutboundCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundCalls to fetch.
     */
    orderBy?: OutboundCallOrderByWithRelationInput | OutboundCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboundCalls.
     */
    cursor?: OutboundCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboundCalls.
     */
    distinct?: OutboundCallScalarFieldEnum | OutboundCallScalarFieldEnum[]
  }

  /**
   * OutboundCall findMany
   */
  export type OutboundCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCalls to fetch.
     */
    where?: OutboundCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundCalls to fetch.
     */
    orderBy?: OutboundCallOrderByWithRelationInput | OutboundCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutboundCalls.
     */
    cursor?: OutboundCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundCalls.
     */
    skip?: number
    distinct?: OutboundCallScalarFieldEnum | OutboundCallScalarFieldEnum[]
  }

  /**
   * OutboundCall create
   */
  export type OutboundCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * The data needed to create a OutboundCall.
     */
    data: XOR<OutboundCallCreateInput, OutboundCallUncheckedCreateInput>
  }

  /**
   * OutboundCall createMany
   */
  export type OutboundCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutboundCalls.
     */
    data: OutboundCallCreateManyInput | OutboundCallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutboundCall createManyAndReturn
   */
  export type OutboundCallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OutboundCalls.
     */
    data: OutboundCallCreateManyInput | OutboundCallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutboundCall update
   */
  export type OutboundCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * The data needed to update a OutboundCall.
     */
    data: XOR<OutboundCallUpdateInput, OutboundCallUncheckedUpdateInput>
    /**
     * Choose, which OutboundCall to update.
     */
    where: OutboundCallWhereUniqueInput
  }

  /**
   * OutboundCall updateMany
   */
  export type OutboundCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutboundCalls.
     */
    data: XOR<OutboundCallUpdateManyMutationInput, OutboundCallUncheckedUpdateManyInput>
    /**
     * Filter which OutboundCalls to update
     */
    where?: OutboundCallWhereInput
  }

  /**
   * OutboundCall upsert
   */
  export type OutboundCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * The filter to search for the OutboundCall to update in case it exists.
     */
    where: OutboundCallWhereUniqueInput
    /**
     * In case the OutboundCall found by the `where` argument doesn't exist, create a new OutboundCall with this data.
     */
    create: XOR<OutboundCallCreateInput, OutboundCallUncheckedCreateInput>
    /**
     * In case the OutboundCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutboundCallUpdateInput, OutboundCallUncheckedUpdateInput>
  }

  /**
   * OutboundCall delete
   */
  export type OutboundCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    /**
     * Filter which OutboundCall to delete.
     */
    where: OutboundCallWhereUniqueInput
  }

  /**
   * OutboundCall deleteMany
   */
  export type OutboundCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboundCalls to delete
     */
    where?: OutboundCallWhereInput
  }

  /**
   * OutboundCall.campaign
   */
  export type OutboundCall$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    where?: OutboundCampaignWhereInput
  }

  /**
   * OutboundCall without action
   */
  export type OutboundCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
  }


  /**
   * Model CallRoutingRule
   */

  export type AggregateCallRoutingRule = {
    _count: CallRoutingRuleCountAggregateOutputType | null
    _avg: CallRoutingRuleAvgAggregateOutputType | null
    _sum: CallRoutingRuleSumAggregateOutputType | null
    _min: CallRoutingRuleMinAggregateOutputType | null
    _max: CallRoutingRuleMaxAggregateOutputType | null
  }

  export type CallRoutingRuleAvgAggregateOutputType = {
    priority: number | null
  }

  export type CallRoutingRuleSumAggregateOutputType = {
    priority: number | null
  }

  export type CallRoutingRuleMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    priority: number | null
    isActive: boolean | null
    conditionType: $Enums.ConditionType | null
    actionType: $Enums.ActionType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallRoutingRuleMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    priority: number | null
    isActive: boolean | null
    conditionType: $Enums.ConditionType | null
    actionType: $Enums.ActionType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallRoutingRuleCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    priority: number
    isActive: number
    conditionType: number
    conditionValue: number
    actionType: number
    actionConfig: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CallRoutingRuleAvgAggregateInputType = {
    priority?: true
  }

  export type CallRoutingRuleSumAggregateInputType = {
    priority?: true
  }

  export type CallRoutingRuleMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    priority?: true
    isActive?: true
    conditionType?: true
    actionType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallRoutingRuleMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    priority?: true
    isActive?: true
    conditionType?: true
    actionType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallRoutingRuleCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    priority?: true
    isActive?: true
    conditionType?: true
    conditionValue?: true
    actionType?: true
    actionConfig?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CallRoutingRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallRoutingRule to aggregate.
     */
    where?: CallRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRoutingRules to fetch.
     */
    orderBy?: CallRoutingRuleOrderByWithRelationInput | CallRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallRoutingRules
    **/
    _count?: true | CallRoutingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallRoutingRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallRoutingRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallRoutingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallRoutingRuleMaxAggregateInputType
  }

  export type GetCallRoutingRuleAggregateType<T extends CallRoutingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCallRoutingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallRoutingRule[P]>
      : GetScalarType<T[P], AggregateCallRoutingRule[P]>
  }




  export type CallRoutingRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallRoutingRuleWhereInput
    orderBy?: CallRoutingRuleOrderByWithAggregationInput | CallRoutingRuleOrderByWithAggregationInput[]
    by: CallRoutingRuleScalarFieldEnum[] | CallRoutingRuleScalarFieldEnum
    having?: CallRoutingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallRoutingRuleCountAggregateInputType | true
    _avg?: CallRoutingRuleAvgAggregateInputType
    _sum?: CallRoutingRuleSumAggregateInputType
    _min?: CallRoutingRuleMinAggregateInputType
    _max?: CallRoutingRuleMaxAggregateInputType
  }

  export type CallRoutingRuleGroupByOutputType = {
    id: string
    businessId: string
    name: string
    priority: number
    isActive: boolean
    conditionType: $Enums.ConditionType
    conditionValue: JsonValue
    actionType: $Enums.ActionType
    actionConfig: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CallRoutingRuleCountAggregateOutputType | null
    _avg: CallRoutingRuleAvgAggregateOutputType | null
    _sum: CallRoutingRuleSumAggregateOutputType | null
    _min: CallRoutingRuleMinAggregateOutputType | null
    _max: CallRoutingRuleMaxAggregateOutputType | null
  }

  type GetCallRoutingRuleGroupByPayload<T extends CallRoutingRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallRoutingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallRoutingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallRoutingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], CallRoutingRuleGroupByOutputType[P]>
        }
      >
    >


  export type CallRoutingRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    priority?: boolean
    isActive?: boolean
    conditionType?: boolean
    conditionValue?: boolean
    actionType?: boolean
    actionConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callRoutingRule"]>

  export type CallRoutingRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    priority?: boolean
    isActive?: boolean
    conditionType?: boolean
    conditionValue?: boolean
    actionType?: boolean
    actionConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callRoutingRule"]>

  export type CallRoutingRuleSelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    priority?: boolean
    isActive?: boolean
    conditionType?: boolean
    conditionValue?: boolean
    actionType?: boolean
    actionConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CallRoutingRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type CallRoutingRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $CallRoutingRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallRoutingRule"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      name: string
      priority: number
      isActive: boolean
      conditionType: $Enums.ConditionType
      conditionValue: Prisma.JsonValue
      actionType: $Enums.ActionType
      actionConfig: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["callRoutingRule"]>
    composites: {}
  }

  type CallRoutingRuleGetPayload<S extends boolean | null | undefined | CallRoutingRuleDefaultArgs> = $Result.GetResult<Prisma.$CallRoutingRulePayload, S>

  type CallRoutingRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CallRoutingRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallRoutingRuleCountAggregateInputType | true
    }

  export interface CallRoutingRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallRoutingRule'], meta: { name: 'CallRoutingRule' } }
    /**
     * Find zero or one CallRoutingRule that matches the filter.
     * @param {CallRoutingRuleFindUniqueArgs} args - Arguments to find a CallRoutingRule
     * @example
     * // Get one CallRoutingRule
     * const callRoutingRule = await prisma.callRoutingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallRoutingRuleFindUniqueArgs>(args: SelectSubset<T, CallRoutingRuleFindUniqueArgs<ExtArgs>>): Prisma__CallRoutingRuleClient<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CallRoutingRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CallRoutingRuleFindUniqueOrThrowArgs} args - Arguments to find a CallRoutingRule
     * @example
     * // Get one CallRoutingRule
     * const callRoutingRule = await prisma.callRoutingRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallRoutingRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CallRoutingRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallRoutingRuleClient<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CallRoutingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRoutingRuleFindFirstArgs} args - Arguments to find a CallRoutingRule
     * @example
     * // Get one CallRoutingRule
     * const callRoutingRule = await prisma.callRoutingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallRoutingRuleFindFirstArgs>(args?: SelectSubset<T, CallRoutingRuleFindFirstArgs<ExtArgs>>): Prisma__CallRoutingRuleClient<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CallRoutingRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRoutingRuleFindFirstOrThrowArgs} args - Arguments to find a CallRoutingRule
     * @example
     * // Get one CallRoutingRule
     * const callRoutingRule = await prisma.callRoutingRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallRoutingRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CallRoutingRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallRoutingRuleClient<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CallRoutingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRoutingRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallRoutingRules
     * const callRoutingRules = await prisma.callRoutingRule.findMany()
     * 
     * // Get first 10 CallRoutingRules
     * const callRoutingRules = await prisma.callRoutingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callRoutingRuleWithIdOnly = await prisma.callRoutingRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallRoutingRuleFindManyArgs>(args?: SelectSubset<T, CallRoutingRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CallRoutingRule.
     * @param {CallRoutingRuleCreateArgs} args - Arguments to create a CallRoutingRule.
     * @example
     * // Create one CallRoutingRule
     * const CallRoutingRule = await prisma.callRoutingRule.create({
     *   data: {
     *     // ... data to create a CallRoutingRule
     *   }
     * })
     * 
     */
    create<T extends CallRoutingRuleCreateArgs>(args: SelectSubset<T, CallRoutingRuleCreateArgs<ExtArgs>>): Prisma__CallRoutingRuleClient<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CallRoutingRules.
     * @param {CallRoutingRuleCreateManyArgs} args - Arguments to create many CallRoutingRules.
     * @example
     * // Create many CallRoutingRules
     * const callRoutingRule = await prisma.callRoutingRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallRoutingRuleCreateManyArgs>(args?: SelectSubset<T, CallRoutingRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallRoutingRules and returns the data saved in the database.
     * @param {CallRoutingRuleCreateManyAndReturnArgs} args - Arguments to create many CallRoutingRules.
     * @example
     * // Create many CallRoutingRules
     * const callRoutingRule = await prisma.callRoutingRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallRoutingRules and only return the `id`
     * const callRoutingRuleWithIdOnly = await prisma.callRoutingRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallRoutingRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CallRoutingRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CallRoutingRule.
     * @param {CallRoutingRuleDeleteArgs} args - Arguments to delete one CallRoutingRule.
     * @example
     * // Delete one CallRoutingRule
     * const CallRoutingRule = await prisma.callRoutingRule.delete({
     *   where: {
     *     // ... filter to delete one CallRoutingRule
     *   }
     * })
     * 
     */
    delete<T extends CallRoutingRuleDeleteArgs>(args: SelectSubset<T, CallRoutingRuleDeleteArgs<ExtArgs>>): Prisma__CallRoutingRuleClient<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CallRoutingRule.
     * @param {CallRoutingRuleUpdateArgs} args - Arguments to update one CallRoutingRule.
     * @example
     * // Update one CallRoutingRule
     * const callRoutingRule = await prisma.callRoutingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallRoutingRuleUpdateArgs>(args: SelectSubset<T, CallRoutingRuleUpdateArgs<ExtArgs>>): Prisma__CallRoutingRuleClient<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CallRoutingRules.
     * @param {CallRoutingRuleDeleteManyArgs} args - Arguments to filter CallRoutingRules to delete.
     * @example
     * // Delete a few CallRoutingRules
     * const { count } = await prisma.callRoutingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallRoutingRuleDeleteManyArgs>(args?: SelectSubset<T, CallRoutingRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallRoutingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRoutingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallRoutingRules
     * const callRoutingRule = await prisma.callRoutingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallRoutingRuleUpdateManyArgs>(args: SelectSubset<T, CallRoutingRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CallRoutingRule.
     * @param {CallRoutingRuleUpsertArgs} args - Arguments to update or create a CallRoutingRule.
     * @example
     * // Update or create a CallRoutingRule
     * const callRoutingRule = await prisma.callRoutingRule.upsert({
     *   create: {
     *     // ... data to create a CallRoutingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallRoutingRule we want to update
     *   }
     * })
     */
    upsert<T extends CallRoutingRuleUpsertArgs>(args: SelectSubset<T, CallRoutingRuleUpsertArgs<ExtArgs>>): Prisma__CallRoutingRuleClient<$Result.GetResult<Prisma.$CallRoutingRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CallRoutingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRoutingRuleCountArgs} args - Arguments to filter CallRoutingRules to count.
     * @example
     * // Count the number of CallRoutingRules
     * const count = await prisma.callRoutingRule.count({
     *   where: {
     *     // ... the filter for the CallRoutingRules we want to count
     *   }
     * })
    **/
    count<T extends CallRoutingRuleCountArgs>(
      args?: Subset<T, CallRoutingRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallRoutingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallRoutingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRoutingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallRoutingRuleAggregateArgs>(args: Subset<T, CallRoutingRuleAggregateArgs>): Prisma.PrismaPromise<GetCallRoutingRuleAggregateType<T>>

    /**
     * Group by CallRoutingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRoutingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallRoutingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallRoutingRuleGroupByArgs['orderBy'] }
        : { orderBy?: CallRoutingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallRoutingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallRoutingRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallRoutingRule model
   */
  readonly fields: CallRoutingRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallRoutingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallRoutingRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallRoutingRule model
   */ 
  interface CallRoutingRuleFieldRefs {
    readonly id: FieldRef<"CallRoutingRule", 'String'>
    readonly businessId: FieldRef<"CallRoutingRule", 'String'>
    readonly name: FieldRef<"CallRoutingRule", 'String'>
    readonly priority: FieldRef<"CallRoutingRule", 'Int'>
    readonly isActive: FieldRef<"CallRoutingRule", 'Boolean'>
    readonly conditionType: FieldRef<"CallRoutingRule", 'ConditionType'>
    readonly conditionValue: FieldRef<"CallRoutingRule", 'Json'>
    readonly actionType: FieldRef<"CallRoutingRule", 'ActionType'>
    readonly actionConfig: FieldRef<"CallRoutingRule", 'Json'>
    readonly createdAt: FieldRef<"CallRoutingRule", 'DateTime'>
    readonly updatedAt: FieldRef<"CallRoutingRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallRoutingRule findUnique
   */
  export type CallRoutingRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CallRoutingRule to fetch.
     */
    where: CallRoutingRuleWhereUniqueInput
  }

  /**
   * CallRoutingRule findUniqueOrThrow
   */
  export type CallRoutingRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CallRoutingRule to fetch.
     */
    where: CallRoutingRuleWhereUniqueInput
  }

  /**
   * CallRoutingRule findFirst
   */
  export type CallRoutingRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CallRoutingRule to fetch.
     */
    where?: CallRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRoutingRules to fetch.
     */
    orderBy?: CallRoutingRuleOrderByWithRelationInput | CallRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallRoutingRules.
     */
    cursor?: CallRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallRoutingRules.
     */
    distinct?: CallRoutingRuleScalarFieldEnum | CallRoutingRuleScalarFieldEnum[]
  }

  /**
   * CallRoutingRule findFirstOrThrow
   */
  export type CallRoutingRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CallRoutingRule to fetch.
     */
    where?: CallRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRoutingRules to fetch.
     */
    orderBy?: CallRoutingRuleOrderByWithRelationInput | CallRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallRoutingRules.
     */
    cursor?: CallRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallRoutingRules.
     */
    distinct?: CallRoutingRuleScalarFieldEnum | CallRoutingRuleScalarFieldEnum[]
  }

  /**
   * CallRoutingRule findMany
   */
  export type CallRoutingRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CallRoutingRules to fetch.
     */
    where?: CallRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRoutingRules to fetch.
     */
    orderBy?: CallRoutingRuleOrderByWithRelationInput | CallRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallRoutingRules.
     */
    cursor?: CallRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRoutingRules.
     */
    skip?: number
    distinct?: CallRoutingRuleScalarFieldEnum | CallRoutingRuleScalarFieldEnum[]
  }

  /**
   * CallRoutingRule create
   */
  export type CallRoutingRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CallRoutingRule.
     */
    data: XOR<CallRoutingRuleCreateInput, CallRoutingRuleUncheckedCreateInput>
  }

  /**
   * CallRoutingRule createMany
   */
  export type CallRoutingRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallRoutingRules.
     */
    data: CallRoutingRuleCreateManyInput | CallRoutingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallRoutingRule createManyAndReturn
   */
  export type CallRoutingRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CallRoutingRules.
     */
    data: CallRoutingRuleCreateManyInput | CallRoutingRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallRoutingRule update
   */
  export type CallRoutingRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CallRoutingRule.
     */
    data: XOR<CallRoutingRuleUpdateInput, CallRoutingRuleUncheckedUpdateInput>
    /**
     * Choose, which CallRoutingRule to update.
     */
    where: CallRoutingRuleWhereUniqueInput
  }

  /**
   * CallRoutingRule updateMany
   */
  export type CallRoutingRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallRoutingRules.
     */
    data: XOR<CallRoutingRuleUpdateManyMutationInput, CallRoutingRuleUncheckedUpdateManyInput>
    /**
     * Filter which CallRoutingRules to update
     */
    where?: CallRoutingRuleWhereInput
  }

  /**
   * CallRoutingRule upsert
   */
  export type CallRoutingRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CallRoutingRule to update in case it exists.
     */
    where: CallRoutingRuleWhereUniqueInput
    /**
     * In case the CallRoutingRule found by the `where` argument doesn't exist, create a new CallRoutingRule with this data.
     */
    create: XOR<CallRoutingRuleCreateInput, CallRoutingRuleUncheckedCreateInput>
    /**
     * In case the CallRoutingRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallRoutingRuleUpdateInput, CallRoutingRuleUncheckedUpdateInput>
  }

  /**
   * CallRoutingRule delete
   */
  export type CallRoutingRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
    /**
     * Filter which CallRoutingRule to delete.
     */
    where: CallRoutingRuleWhereUniqueInput
  }

  /**
   * CallRoutingRule deleteMany
   */
  export type CallRoutingRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallRoutingRules to delete
     */
    where?: CallRoutingRuleWhereInput
  }

  /**
   * CallRoutingRule without action
   */
  export type CallRoutingRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRoutingRule
     */
    select?: CallRoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRoutingRuleInclude<ExtArgs> | null
  }


  /**
   * Model OutboundCampaign
   */

  export type AggregateOutboundCampaign = {
    _count: OutboundCampaignCountAggregateOutputType | null
    _avg: OutboundCampaignAvgAggregateOutputType | null
    _sum: OutboundCampaignSumAggregateOutputType | null
    _min: OutboundCampaignMinAggregateOutputType | null
    _max: OutboundCampaignMaxAggregateOutputType | null
  }

  export type OutboundCampaignAvgAggregateOutputType = {
    totalContacts: number | null
    callsPerMinute: number | null
    maxConcurrent: number | null
    completedCalls: number | null
    answeredCalls: number | null
    voicemailCalls: number | null
    failedCalls: number | null
  }

  export type OutboundCampaignSumAggregateOutputType = {
    totalContacts: number | null
    callsPerMinute: number | null
    maxConcurrent: number | null
    completedCalls: number | null
    answeredCalls: number | null
    voicemailCalls: number | null
    failedCalls: number | null
  }

  export type OutboundCampaignMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    scriptTemplate: string | null
    voiceId: string | null
    totalContacts: number | null
    startDate: Date | null
    endDate: Date | null
    callsPerMinute: number | null
    maxConcurrent: number | null
    status: $Enums.CampaignStatus | null
    completedCalls: number | null
    answeredCalls: number | null
    voicemailCalls: number | null
    failedCalls: number | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type OutboundCampaignMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    scriptTemplate: string | null
    voiceId: string | null
    totalContacts: number | null
    startDate: Date | null
    endDate: Date | null
    callsPerMinute: number | null
    maxConcurrent: number | null
    status: $Enums.CampaignStatus | null
    completedCalls: number | null
    answeredCalls: number | null
    voicemailCalls: number | null
    failedCalls: number | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type OutboundCampaignCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    description: number
    scriptTemplate: number
    voiceId: number
    contactList: number
    totalContacts: number
    scheduleConfig: number
    startDate: number
    endDate: number
    callsPerMinute: number
    maxConcurrent: number
    status: number
    completedCalls: number
    answeredCalls: number
    voicemailCalls: number
    failedCalls: number
    createdAt: number
    updatedAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type OutboundCampaignAvgAggregateInputType = {
    totalContacts?: true
    callsPerMinute?: true
    maxConcurrent?: true
    completedCalls?: true
    answeredCalls?: true
    voicemailCalls?: true
    failedCalls?: true
  }

  export type OutboundCampaignSumAggregateInputType = {
    totalContacts?: true
    callsPerMinute?: true
    maxConcurrent?: true
    completedCalls?: true
    answeredCalls?: true
    voicemailCalls?: true
    failedCalls?: true
  }

  export type OutboundCampaignMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    scriptTemplate?: true
    voiceId?: true
    totalContacts?: true
    startDate?: true
    endDate?: true
    callsPerMinute?: true
    maxConcurrent?: true
    status?: true
    completedCalls?: true
    answeredCalls?: true
    voicemailCalls?: true
    failedCalls?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type OutboundCampaignMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    scriptTemplate?: true
    voiceId?: true
    totalContacts?: true
    startDate?: true
    endDate?: true
    callsPerMinute?: true
    maxConcurrent?: true
    status?: true
    completedCalls?: true
    answeredCalls?: true
    voicemailCalls?: true
    failedCalls?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type OutboundCampaignCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    scriptTemplate?: true
    voiceId?: true
    contactList?: true
    totalContacts?: true
    scheduleConfig?: true
    startDate?: true
    endDate?: true
    callsPerMinute?: true
    maxConcurrent?: true
    status?: true
    completedCalls?: true
    answeredCalls?: true
    voicemailCalls?: true
    failedCalls?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type OutboundCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboundCampaign to aggregate.
     */
    where?: OutboundCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundCampaigns to fetch.
     */
    orderBy?: OutboundCampaignOrderByWithRelationInput | OutboundCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutboundCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutboundCampaigns
    **/
    _count?: true | OutboundCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutboundCampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutboundCampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutboundCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutboundCampaignMaxAggregateInputType
  }

  export type GetOutboundCampaignAggregateType<T extends OutboundCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateOutboundCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutboundCampaign[P]>
      : GetScalarType<T[P], AggregateOutboundCampaign[P]>
  }




  export type OutboundCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboundCampaignWhereInput
    orderBy?: OutboundCampaignOrderByWithAggregationInput | OutboundCampaignOrderByWithAggregationInput[]
    by: OutboundCampaignScalarFieldEnum[] | OutboundCampaignScalarFieldEnum
    having?: OutboundCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutboundCampaignCountAggregateInputType | true
    _avg?: OutboundCampaignAvgAggregateInputType
    _sum?: OutboundCampaignSumAggregateInputType
    _min?: OutboundCampaignMinAggregateInputType
    _max?: OutboundCampaignMaxAggregateInputType
  }

  export type OutboundCampaignGroupByOutputType = {
    id: string
    businessId: string
    name: string
    description: string | null
    scriptTemplate: string
    voiceId: string | null
    contactList: JsonValue
    totalContacts: number
    scheduleConfig: JsonValue | null
    startDate: Date | null
    endDate: Date | null
    callsPerMinute: number
    maxConcurrent: number
    status: $Enums.CampaignStatus
    completedCalls: number
    answeredCalls: number
    voicemailCalls: number
    failedCalls: number
    createdAt: Date
    updatedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: OutboundCampaignCountAggregateOutputType | null
    _avg: OutboundCampaignAvgAggregateOutputType | null
    _sum: OutboundCampaignSumAggregateOutputType | null
    _min: OutboundCampaignMinAggregateOutputType | null
    _max: OutboundCampaignMaxAggregateOutputType | null
  }

  type GetOutboundCampaignGroupByPayload<T extends OutboundCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutboundCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutboundCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutboundCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], OutboundCampaignGroupByOutputType[P]>
        }
      >
    >


  export type OutboundCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    scriptTemplate?: boolean
    voiceId?: boolean
    contactList?: boolean
    totalContacts?: boolean
    scheduleConfig?: boolean
    startDate?: boolean
    endDate?: boolean
    callsPerMinute?: boolean
    maxConcurrent?: boolean
    status?: boolean
    completedCalls?: boolean
    answeredCalls?: boolean
    voicemailCalls?: boolean
    failedCalls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    calls?: boolean | OutboundCampaign$callsArgs<ExtArgs>
    _count?: boolean | OutboundCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outboundCampaign"]>

  export type OutboundCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    scriptTemplate?: boolean
    voiceId?: boolean
    contactList?: boolean
    totalContacts?: boolean
    scheduleConfig?: boolean
    startDate?: boolean
    endDate?: boolean
    callsPerMinute?: boolean
    maxConcurrent?: boolean
    status?: boolean
    completedCalls?: boolean
    answeredCalls?: boolean
    voicemailCalls?: boolean
    failedCalls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outboundCampaign"]>

  export type OutboundCampaignSelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    scriptTemplate?: boolean
    voiceId?: boolean
    contactList?: boolean
    totalContacts?: boolean
    scheduleConfig?: boolean
    startDate?: boolean
    endDate?: boolean
    callsPerMinute?: boolean
    maxConcurrent?: boolean
    status?: boolean
    completedCalls?: boolean
    answeredCalls?: boolean
    voicemailCalls?: boolean
    failedCalls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type OutboundCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    calls?: boolean | OutboundCampaign$callsArgs<ExtArgs>
    _count?: boolean | OutboundCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OutboundCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $OutboundCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutboundCampaign"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      calls: Prisma.$OutboundCallPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      name: string
      description: string | null
      scriptTemplate: string
      voiceId: string | null
      contactList: Prisma.JsonValue
      totalContacts: number
      scheduleConfig: Prisma.JsonValue | null
      startDate: Date | null
      endDate: Date | null
      callsPerMinute: number
      maxConcurrent: number
      status: $Enums.CampaignStatus
      completedCalls: number
      answeredCalls: number
      voicemailCalls: number
      failedCalls: number
      createdAt: Date
      updatedAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["outboundCampaign"]>
    composites: {}
  }

  type OutboundCampaignGetPayload<S extends boolean | null | undefined | OutboundCampaignDefaultArgs> = $Result.GetResult<Prisma.$OutboundCampaignPayload, S>

  type OutboundCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OutboundCampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OutboundCampaignCountAggregateInputType | true
    }

  export interface OutboundCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutboundCampaign'], meta: { name: 'OutboundCampaign' } }
    /**
     * Find zero or one OutboundCampaign that matches the filter.
     * @param {OutboundCampaignFindUniqueArgs} args - Arguments to find a OutboundCampaign
     * @example
     * // Get one OutboundCampaign
     * const outboundCampaign = await prisma.outboundCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutboundCampaignFindUniqueArgs>(args: SelectSubset<T, OutboundCampaignFindUniqueArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OutboundCampaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OutboundCampaignFindUniqueOrThrowArgs} args - Arguments to find a OutboundCampaign
     * @example
     * // Get one OutboundCampaign
     * const outboundCampaign = await prisma.outboundCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutboundCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, OutboundCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OutboundCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCampaignFindFirstArgs} args - Arguments to find a OutboundCampaign
     * @example
     * // Get one OutboundCampaign
     * const outboundCampaign = await prisma.outboundCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutboundCampaignFindFirstArgs>(args?: SelectSubset<T, OutboundCampaignFindFirstArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OutboundCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCampaignFindFirstOrThrowArgs} args - Arguments to find a OutboundCampaign
     * @example
     * // Get one OutboundCampaign
     * const outboundCampaign = await prisma.outboundCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutboundCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, OutboundCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OutboundCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutboundCampaigns
     * const outboundCampaigns = await prisma.outboundCampaign.findMany()
     * 
     * // Get first 10 OutboundCampaigns
     * const outboundCampaigns = await prisma.outboundCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outboundCampaignWithIdOnly = await prisma.outboundCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutboundCampaignFindManyArgs>(args?: SelectSubset<T, OutboundCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OutboundCampaign.
     * @param {OutboundCampaignCreateArgs} args - Arguments to create a OutboundCampaign.
     * @example
     * // Create one OutboundCampaign
     * const OutboundCampaign = await prisma.outboundCampaign.create({
     *   data: {
     *     // ... data to create a OutboundCampaign
     *   }
     * })
     * 
     */
    create<T extends OutboundCampaignCreateArgs>(args: SelectSubset<T, OutboundCampaignCreateArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OutboundCampaigns.
     * @param {OutboundCampaignCreateManyArgs} args - Arguments to create many OutboundCampaigns.
     * @example
     * // Create many OutboundCampaigns
     * const outboundCampaign = await prisma.outboundCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutboundCampaignCreateManyArgs>(args?: SelectSubset<T, OutboundCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutboundCampaigns and returns the data saved in the database.
     * @param {OutboundCampaignCreateManyAndReturnArgs} args - Arguments to create many OutboundCampaigns.
     * @example
     * // Create many OutboundCampaigns
     * const outboundCampaign = await prisma.outboundCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutboundCampaigns and only return the `id`
     * const outboundCampaignWithIdOnly = await prisma.outboundCampaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutboundCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, OutboundCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OutboundCampaign.
     * @param {OutboundCampaignDeleteArgs} args - Arguments to delete one OutboundCampaign.
     * @example
     * // Delete one OutboundCampaign
     * const OutboundCampaign = await prisma.outboundCampaign.delete({
     *   where: {
     *     // ... filter to delete one OutboundCampaign
     *   }
     * })
     * 
     */
    delete<T extends OutboundCampaignDeleteArgs>(args: SelectSubset<T, OutboundCampaignDeleteArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OutboundCampaign.
     * @param {OutboundCampaignUpdateArgs} args - Arguments to update one OutboundCampaign.
     * @example
     * // Update one OutboundCampaign
     * const outboundCampaign = await prisma.outboundCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutboundCampaignUpdateArgs>(args: SelectSubset<T, OutboundCampaignUpdateArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OutboundCampaigns.
     * @param {OutboundCampaignDeleteManyArgs} args - Arguments to filter OutboundCampaigns to delete.
     * @example
     * // Delete a few OutboundCampaigns
     * const { count } = await prisma.outboundCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutboundCampaignDeleteManyArgs>(args?: SelectSubset<T, OutboundCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutboundCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutboundCampaigns
     * const outboundCampaign = await prisma.outboundCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutboundCampaignUpdateManyArgs>(args: SelectSubset<T, OutboundCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutboundCampaign.
     * @param {OutboundCampaignUpsertArgs} args - Arguments to update or create a OutboundCampaign.
     * @example
     * // Update or create a OutboundCampaign
     * const outboundCampaign = await prisma.outboundCampaign.upsert({
     *   create: {
     *     // ... data to create a OutboundCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutboundCampaign we want to update
     *   }
     * })
     */
    upsert<T extends OutboundCampaignUpsertArgs>(args: SelectSubset<T, OutboundCampaignUpsertArgs<ExtArgs>>): Prisma__OutboundCampaignClient<$Result.GetResult<Prisma.$OutboundCampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OutboundCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCampaignCountArgs} args - Arguments to filter OutboundCampaigns to count.
     * @example
     * // Count the number of OutboundCampaigns
     * const count = await prisma.outboundCampaign.count({
     *   where: {
     *     // ... the filter for the OutboundCampaigns we want to count
     *   }
     * })
    **/
    count<T extends OutboundCampaignCountArgs>(
      args?: Subset<T, OutboundCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutboundCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutboundCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutboundCampaignAggregateArgs>(args: Subset<T, OutboundCampaignAggregateArgs>): Prisma.PrismaPromise<GetOutboundCampaignAggregateType<T>>

    /**
     * Group by OutboundCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboundCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutboundCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutboundCampaignGroupByArgs['orderBy'] }
        : { orderBy?: OutboundCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutboundCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutboundCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutboundCampaign model
   */
  readonly fields: OutboundCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutboundCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutboundCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    calls<T extends OutboundCampaign$callsArgs<ExtArgs> = {}>(args?: Subset<T, OutboundCampaign$callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboundCallPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutboundCampaign model
   */ 
  interface OutboundCampaignFieldRefs {
    readonly id: FieldRef<"OutboundCampaign", 'String'>
    readonly businessId: FieldRef<"OutboundCampaign", 'String'>
    readonly name: FieldRef<"OutboundCampaign", 'String'>
    readonly description: FieldRef<"OutboundCampaign", 'String'>
    readonly scriptTemplate: FieldRef<"OutboundCampaign", 'String'>
    readonly voiceId: FieldRef<"OutboundCampaign", 'String'>
    readonly contactList: FieldRef<"OutboundCampaign", 'Json'>
    readonly totalContacts: FieldRef<"OutboundCampaign", 'Int'>
    readonly scheduleConfig: FieldRef<"OutboundCampaign", 'Json'>
    readonly startDate: FieldRef<"OutboundCampaign", 'DateTime'>
    readonly endDate: FieldRef<"OutboundCampaign", 'DateTime'>
    readonly callsPerMinute: FieldRef<"OutboundCampaign", 'Int'>
    readonly maxConcurrent: FieldRef<"OutboundCampaign", 'Int'>
    readonly status: FieldRef<"OutboundCampaign", 'CampaignStatus'>
    readonly completedCalls: FieldRef<"OutboundCampaign", 'Int'>
    readonly answeredCalls: FieldRef<"OutboundCampaign", 'Int'>
    readonly voicemailCalls: FieldRef<"OutboundCampaign", 'Int'>
    readonly failedCalls: FieldRef<"OutboundCampaign", 'Int'>
    readonly createdAt: FieldRef<"OutboundCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"OutboundCampaign", 'DateTime'>
    readonly startedAt: FieldRef<"OutboundCampaign", 'DateTime'>
    readonly completedAt: FieldRef<"OutboundCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutboundCampaign findUnique
   */
  export type OutboundCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCampaign to fetch.
     */
    where: OutboundCampaignWhereUniqueInput
  }

  /**
   * OutboundCampaign findUniqueOrThrow
   */
  export type OutboundCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCampaign to fetch.
     */
    where: OutboundCampaignWhereUniqueInput
  }

  /**
   * OutboundCampaign findFirst
   */
  export type OutboundCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCampaign to fetch.
     */
    where?: OutboundCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundCampaigns to fetch.
     */
    orderBy?: OutboundCampaignOrderByWithRelationInput | OutboundCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboundCampaigns.
     */
    cursor?: OutboundCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboundCampaigns.
     */
    distinct?: OutboundCampaignScalarFieldEnum | OutboundCampaignScalarFieldEnum[]
  }

  /**
   * OutboundCampaign findFirstOrThrow
   */
  export type OutboundCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCampaign to fetch.
     */
    where?: OutboundCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundCampaigns to fetch.
     */
    orderBy?: OutboundCampaignOrderByWithRelationInput | OutboundCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboundCampaigns.
     */
    cursor?: OutboundCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboundCampaigns.
     */
    distinct?: OutboundCampaignScalarFieldEnum | OutboundCampaignScalarFieldEnum[]
  }

  /**
   * OutboundCampaign findMany
   */
  export type OutboundCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * Filter, which OutboundCampaigns to fetch.
     */
    where?: OutboundCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboundCampaigns to fetch.
     */
    orderBy?: OutboundCampaignOrderByWithRelationInput | OutboundCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutboundCampaigns.
     */
    cursor?: OutboundCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboundCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboundCampaigns.
     */
    skip?: number
    distinct?: OutboundCampaignScalarFieldEnum | OutboundCampaignScalarFieldEnum[]
  }

  /**
   * OutboundCampaign create
   */
  export type OutboundCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a OutboundCampaign.
     */
    data: XOR<OutboundCampaignCreateInput, OutboundCampaignUncheckedCreateInput>
  }

  /**
   * OutboundCampaign createMany
   */
  export type OutboundCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutboundCampaigns.
     */
    data: OutboundCampaignCreateManyInput | OutboundCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutboundCampaign createManyAndReturn
   */
  export type OutboundCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OutboundCampaigns.
     */
    data: OutboundCampaignCreateManyInput | OutboundCampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutboundCampaign update
   */
  export type OutboundCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a OutboundCampaign.
     */
    data: XOR<OutboundCampaignUpdateInput, OutboundCampaignUncheckedUpdateInput>
    /**
     * Choose, which OutboundCampaign to update.
     */
    where: OutboundCampaignWhereUniqueInput
  }

  /**
   * OutboundCampaign updateMany
   */
  export type OutboundCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutboundCampaigns.
     */
    data: XOR<OutboundCampaignUpdateManyMutationInput, OutboundCampaignUncheckedUpdateManyInput>
    /**
     * Filter which OutboundCampaigns to update
     */
    where?: OutboundCampaignWhereInput
  }

  /**
   * OutboundCampaign upsert
   */
  export type OutboundCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the OutboundCampaign to update in case it exists.
     */
    where: OutboundCampaignWhereUniqueInput
    /**
     * In case the OutboundCampaign found by the `where` argument doesn't exist, create a new OutboundCampaign with this data.
     */
    create: XOR<OutboundCampaignCreateInput, OutboundCampaignUncheckedCreateInput>
    /**
     * In case the OutboundCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutboundCampaignUpdateInput, OutboundCampaignUncheckedUpdateInput>
  }

  /**
   * OutboundCampaign delete
   */
  export type OutboundCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
    /**
     * Filter which OutboundCampaign to delete.
     */
    where: OutboundCampaignWhereUniqueInput
  }

  /**
   * OutboundCampaign deleteMany
   */
  export type OutboundCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboundCampaigns to delete
     */
    where?: OutboundCampaignWhereInput
  }

  /**
   * OutboundCampaign.calls
   */
  export type OutboundCampaign$callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCall
     */
    select?: OutboundCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCallInclude<ExtArgs> | null
    where?: OutboundCallWhereInput
    orderBy?: OutboundCallOrderByWithRelationInput | OutboundCallOrderByWithRelationInput[]
    cursor?: OutboundCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutboundCallScalarFieldEnum | OutboundCallScalarFieldEnum[]
  }

  /**
   * OutboundCampaign without action
   */
  export type OutboundCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboundCampaign
     */
    select?: OutboundCampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboundCampaignInclude<ExtArgs> | null
  }


  /**
   * Model CallQueue
   */

  export type AggregateCallQueue = {
    _count: CallQueueCountAggregateOutputType | null
    _avg: CallQueueAvgAggregateOutputType | null
    _sum: CallQueueSumAggregateOutputType | null
    _min: CallQueueMinAggregateOutputType | null
    _max: CallQueueMaxAggregateOutputType | null
  }

  export type CallQueueAvgAggregateOutputType = {
    position: number | null
    priority: number | null
    estimatedWait: number | null
    actualWait: number | null
  }

  export type CallQueueSumAggregateOutputType = {
    position: number | null
    priority: number | null
    estimatedWait: number | null
    actualWait: number | null
  }

  export type CallQueueMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    callerNumber: string | null
    callerName: string | null
    status: $Enums.QueueStatus | null
    position: number | null
    priority: number | null
    estimatedWait: number | null
    actualWait: number | null
    externalCallId: string | null
    enteredAt: Date | null
    servedAt: Date | null
  }

  export type CallQueueMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    callerNumber: string | null
    callerName: string | null
    status: $Enums.QueueStatus | null
    position: number | null
    priority: number | null
    estimatedWait: number | null
    actualWait: number | null
    externalCallId: string | null
    enteredAt: Date | null
    servedAt: Date | null
  }

  export type CallQueueCountAggregateOutputType = {
    id: number
    businessId: number
    callerNumber: number
    callerName: number
    status: number
    position: number
    priority: number
    estimatedWait: number
    actualWait: number
    externalCallId: number
    enteredAt: number
    servedAt: number
    _all: number
  }


  export type CallQueueAvgAggregateInputType = {
    position?: true
    priority?: true
    estimatedWait?: true
    actualWait?: true
  }

  export type CallQueueSumAggregateInputType = {
    position?: true
    priority?: true
    estimatedWait?: true
    actualWait?: true
  }

  export type CallQueueMinAggregateInputType = {
    id?: true
    businessId?: true
    callerNumber?: true
    callerName?: true
    status?: true
    position?: true
    priority?: true
    estimatedWait?: true
    actualWait?: true
    externalCallId?: true
    enteredAt?: true
    servedAt?: true
  }

  export type CallQueueMaxAggregateInputType = {
    id?: true
    businessId?: true
    callerNumber?: true
    callerName?: true
    status?: true
    position?: true
    priority?: true
    estimatedWait?: true
    actualWait?: true
    externalCallId?: true
    enteredAt?: true
    servedAt?: true
  }

  export type CallQueueCountAggregateInputType = {
    id?: true
    businessId?: true
    callerNumber?: true
    callerName?: true
    status?: true
    position?: true
    priority?: true
    estimatedWait?: true
    actualWait?: true
    externalCallId?: true
    enteredAt?: true
    servedAt?: true
    _all?: true
  }

  export type CallQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallQueue to aggregate.
     */
    where?: CallQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallQueues to fetch.
     */
    orderBy?: CallQueueOrderByWithRelationInput | CallQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallQueues
    **/
    _count?: true | CallQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallQueueMaxAggregateInputType
  }

  export type GetCallQueueAggregateType<T extends CallQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateCallQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallQueue[P]>
      : GetScalarType<T[P], AggregateCallQueue[P]>
  }




  export type CallQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallQueueWhereInput
    orderBy?: CallQueueOrderByWithAggregationInput | CallQueueOrderByWithAggregationInput[]
    by: CallQueueScalarFieldEnum[] | CallQueueScalarFieldEnum
    having?: CallQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallQueueCountAggregateInputType | true
    _avg?: CallQueueAvgAggregateInputType
    _sum?: CallQueueSumAggregateInputType
    _min?: CallQueueMinAggregateInputType
    _max?: CallQueueMaxAggregateInputType
  }

  export type CallQueueGroupByOutputType = {
    id: string
    businessId: string
    callerNumber: string
    callerName: string | null
    status: $Enums.QueueStatus
    position: number
    priority: number
    estimatedWait: number | null
    actualWait: number | null
    externalCallId: string | null
    enteredAt: Date
    servedAt: Date | null
    _count: CallQueueCountAggregateOutputType | null
    _avg: CallQueueAvgAggregateOutputType | null
    _sum: CallQueueSumAggregateOutputType | null
    _min: CallQueueMinAggregateOutputType | null
    _max: CallQueueMaxAggregateOutputType | null
  }

  type GetCallQueueGroupByPayload<T extends CallQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallQueueGroupByOutputType[P]>
            : GetScalarType<T[P], CallQueueGroupByOutputType[P]>
        }
      >
    >


  export type CallQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    callerNumber?: boolean
    callerName?: boolean
    status?: boolean
    position?: boolean
    priority?: boolean
    estimatedWait?: boolean
    actualWait?: boolean
    externalCallId?: boolean
    enteredAt?: boolean
    servedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callQueue"]>

  export type CallQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    callerNumber?: boolean
    callerName?: boolean
    status?: boolean
    position?: boolean
    priority?: boolean
    estimatedWait?: boolean
    actualWait?: boolean
    externalCallId?: boolean
    enteredAt?: boolean
    servedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callQueue"]>

  export type CallQueueSelectScalar = {
    id?: boolean
    businessId?: boolean
    callerNumber?: boolean
    callerName?: boolean
    status?: boolean
    position?: boolean
    priority?: boolean
    estimatedWait?: boolean
    actualWait?: boolean
    externalCallId?: boolean
    enteredAt?: boolean
    servedAt?: boolean
  }

  export type CallQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type CallQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $CallQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallQueue"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      callerNumber: string
      callerName: string | null
      status: $Enums.QueueStatus
      position: number
      priority: number
      estimatedWait: number | null
      actualWait: number | null
      externalCallId: string | null
      enteredAt: Date
      servedAt: Date | null
    }, ExtArgs["result"]["callQueue"]>
    composites: {}
  }

  type CallQueueGetPayload<S extends boolean | null | undefined | CallQueueDefaultArgs> = $Result.GetResult<Prisma.$CallQueuePayload, S>

  type CallQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CallQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallQueueCountAggregateInputType | true
    }

  export interface CallQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallQueue'], meta: { name: 'CallQueue' } }
    /**
     * Find zero or one CallQueue that matches the filter.
     * @param {CallQueueFindUniqueArgs} args - Arguments to find a CallQueue
     * @example
     * // Get one CallQueue
     * const callQueue = await prisma.callQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallQueueFindUniqueArgs>(args: SelectSubset<T, CallQueueFindUniqueArgs<ExtArgs>>): Prisma__CallQueueClient<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CallQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CallQueueFindUniqueOrThrowArgs} args - Arguments to find a CallQueue
     * @example
     * // Get one CallQueue
     * const callQueue = await prisma.callQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, CallQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallQueueClient<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CallQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallQueueFindFirstArgs} args - Arguments to find a CallQueue
     * @example
     * // Get one CallQueue
     * const callQueue = await prisma.callQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallQueueFindFirstArgs>(args?: SelectSubset<T, CallQueueFindFirstArgs<ExtArgs>>): Prisma__CallQueueClient<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CallQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallQueueFindFirstOrThrowArgs} args - Arguments to find a CallQueue
     * @example
     * // Get one CallQueue
     * const callQueue = await prisma.callQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, CallQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallQueueClient<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CallQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallQueues
     * const callQueues = await prisma.callQueue.findMany()
     * 
     * // Get first 10 CallQueues
     * const callQueues = await prisma.callQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callQueueWithIdOnly = await prisma.callQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallQueueFindManyArgs>(args?: SelectSubset<T, CallQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CallQueue.
     * @param {CallQueueCreateArgs} args - Arguments to create a CallQueue.
     * @example
     * // Create one CallQueue
     * const CallQueue = await prisma.callQueue.create({
     *   data: {
     *     // ... data to create a CallQueue
     *   }
     * })
     * 
     */
    create<T extends CallQueueCreateArgs>(args: SelectSubset<T, CallQueueCreateArgs<ExtArgs>>): Prisma__CallQueueClient<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CallQueues.
     * @param {CallQueueCreateManyArgs} args - Arguments to create many CallQueues.
     * @example
     * // Create many CallQueues
     * const callQueue = await prisma.callQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallQueueCreateManyArgs>(args?: SelectSubset<T, CallQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallQueues and returns the data saved in the database.
     * @param {CallQueueCreateManyAndReturnArgs} args - Arguments to create many CallQueues.
     * @example
     * // Create many CallQueues
     * const callQueue = await prisma.callQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallQueues and only return the `id`
     * const callQueueWithIdOnly = await prisma.callQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, CallQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CallQueue.
     * @param {CallQueueDeleteArgs} args - Arguments to delete one CallQueue.
     * @example
     * // Delete one CallQueue
     * const CallQueue = await prisma.callQueue.delete({
     *   where: {
     *     // ... filter to delete one CallQueue
     *   }
     * })
     * 
     */
    delete<T extends CallQueueDeleteArgs>(args: SelectSubset<T, CallQueueDeleteArgs<ExtArgs>>): Prisma__CallQueueClient<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CallQueue.
     * @param {CallQueueUpdateArgs} args - Arguments to update one CallQueue.
     * @example
     * // Update one CallQueue
     * const callQueue = await prisma.callQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallQueueUpdateArgs>(args: SelectSubset<T, CallQueueUpdateArgs<ExtArgs>>): Prisma__CallQueueClient<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CallQueues.
     * @param {CallQueueDeleteManyArgs} args - Arguments to filter CallQueues to delete.
     * @example
     * // Delete a few CallQueues
     * const { count } = await prisma.callQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallQueueDeleteManyArgs>(args?: SelectSubset<T, CallQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallQueues
     * const callQueue = await prisma.callQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallQueueUpdateManyArgs>(args: SelectSubset<T, CallQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CallQueue.
     * @param {CallQueueUpsertArgs} args - Arguments to update or create a CallQueue.
     * @example
     * // Update or create a CallQueue
     * const callQueue = await prisma.callQueue.upsert({
     *   create: {
     *     // ... data to create a CallQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallQueue we want to update
     *   }
     * })
     */
    upsert<T extends CallQueueUpsertArgs>(args: SelectSubset<T, CallQueueUpsertArgs<ExtArgs>>): Prisma__CallQueueClient<$Result.GetResult<Prisma.$CallQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CallQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallQueueCountArgs} args - Arguments to filter CallQueues to count.
     * @example
     * // Count the number of CallQueues
     * const count = await prisma.callQueue.count({
     *   where: {
     *     // ... the filter for the CallQueues we want to count
     *   }
     * })
    **/
    count<T extends CallQueueCountArgs>(
      args?: Subset<T, CallQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallQueueAggregateArgs>(args: Subset<T, CallQueueAggregateArgs>): Prisma.PrismaPromise<GetCallQueueAggregateType<T>>

    /**
     * Group by CallQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallQueueGroupByArgs['orderBy'] }
        : { orderBy?: CallQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallQueue model
   */
  readonly fields: CallQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallQueue model
   */ 
  interface CallQueueFieldRefs {
    readonly id: FieldRef<"CallQueue", 'String'>
    readonly businessId: FieldRef<"CallQueue", 'String'>
    readonly callerNumber: FieldRef<"CallQueue", 'String'>
    readonly callerName: FieldRef<"CallQueue", 'String'>
    readonly status: FieldRef<"CallQueue", 'QueueStatus'>
    readonly position: FieldRef<"CallQueue", 'Int'>
    readonly priority: FieldRef<"CallQueue", 'Int'>
    readonly estimatedWait: FieldRef<"CallQueue", 'Int'>
    readonly actualWait: FieldRef<"CallQueue", 'Int'>
    readonly externalCallId: FieldRef<"CallQueue", 'String'>
    readonly enteredAt: FieldRef<"CallQueue", 'DateTime'>
    readonly servedAt: FieldRef<"CallQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallQueue findUnique
   */
  export type CallQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * Filter, which CallQueue to fetch.
     */
    where: CallQueueWhereUniqueInput
  }

  /**
   * CallQueue findUniqueOrThrow
   */
  export type CallQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * Filter, which CallQueue to fetch.
     */
    where: CallQueueWhereUniqueInput
  }

  /**
   * CallQueue findFirst
   */
  export type CallQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * Filter, which CallQueue to fetch.
     */
    where?: CallQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallQueues to fetch.
     */
    orderBy?: CallQueueOrderByWithRelationInput | CallQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallQueues.
     */
    cursor?: CallQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallQueues.
     */
    distinct?: CallQueueScalarFieldEnum | CallQueueScalarFieldEnum[]
  }

  /**
   * CallQueue findFirstOrThrow
   */
  export type CallQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * Filter, which CallQueue to fetch.
     */
    where?: CallQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallQueues to fetch.
     */
    orderBy?: CallQueueOrderByWithRelationInput | CallQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallQueues.
     */
    cursor?: CallQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallQueues.
     */
    distinct?: CallQueueScalarFieldEnum | CallQueueScalarFieldEnum[]
  }

  /**
   * CallQueue findMany
   */
  export type CallQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * Filter, which CallQueues to fetch.
     */
    where?: CallQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallQueues to fetch.
     */
    orderBy?: CallQueueOrderByWithRelationInput | CallQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallQueues.
     */
    cursor?: CallQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallQueues.
     */
    skip?: number
    distinct?: CallQueueScalarFieldEnum | CallQueueScalarFieldEnum[]
  }

  /**
   * CallQueue create
   */
  export type CallQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a CallQueue.
     */
    data: XOR<CallQueueCreateInput, CallQueueUncheckedCreateInput>
  }

  /**
   * CallQueue createMany
   */
  export type CallQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallQueues.
     */
    data: CallQueueCreateManyInput | CallQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallQueue createManyAndReturn
   */
  export type CallQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CallQueues.
     */
    data: CallQueueCreateManyInput | CallQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallQueue update
   */
  export type CallQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a CallQueue.
     */
    data: XOR<CallQueueUpdateInput, CallQueueUncheckedUpdateInput>
    /**
     * Choose, which CallQueue to update.
     */
    where: CallQueueWhereUniqueInput
  }

  /**
   * CallQueue updateMany
   */
  export type CallQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallQueues.
     */
    data: XOR<CallQueueUpdateManyMutationInput, CallQueueUncheckedUpdateManyInput>
    /**
     * Filter which CallQueues to update
     */
    where?: CallQueueWhereInput
  }

  /**
   * CallQueue upsert
   */
  export type CallQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the CallQueue to update in case it exists.
     */
    where: CallQueueWhereUniqueInput
    /**
     * In case the CallQueue found by the `where` argument doesn't exist, create a new CallQueue with this data.
     */
    create: XOR<CallQueueCreateInput, CallQueueUncheckedCreateInput>
    /**
     * In case the CallQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallQueueUpdateInput, CallQueueUncheckedUpdateInput>
  }

  /**
   * CallQueue delete
   */
  export type CallQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
    /**
     * Filter which CallQueue to delete.
     */
    where: CallQueueWhereUniqueInput
  }

  /**
   * CallQueue deleteMany
   */
  export type CallQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallQueues to delete
     */
    where?: CallQueueWhereInput
  }

  /**
   * CallQueue without action
   */
  export type CallQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallQueue
     */
    select?: CallQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallQueueInclude<ExtArgs> | null
  }


  /**
   * Model CallbackRequest
   */

  export type AggregateCallbackRequest = {
    _count: CallbackRequestCountAggregateOutputType | null
    _min: CallbackRequestMinAggregateOutputType | null
    _max: CallbackRequestMaxAggregateOutputType | null
  }

  export type CallbackRequestMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    phoneNumber: string | null
    name: string | null
    reason: string | null
    preferredTime: Date | null
    status: $Enums.CallbackStatus | null
    outboundCallId: string | null
    requestedAt: Date | null
    processedAt: Date | null
  }

  export type CallbackRequestMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    phoneNumber: string | null
    name: string | null
    reason: string | null
    preferredTime: Date | null
    status: $Enums.CallbackStatus | null
    outboundCallId: string | null
    requestedAt: Date | null
    processedAt: Date | null
  }

  export type CallbackRequestCountAggregateOutputType = {
    id: number
    businessId: number
    phoneNumber: number
    name: number
    reason: number
    preferredTime: number
    status: number
    outboundCallId: number
    requestedAt: number
    processedAt: number
    _all: number
  }


  export type CallbackRequestMinAggregateInputType = {
    id?: true
    businessId?: true
    phoneNumber?: true
    name?: true
    reason?: true
    preferredTime?: true
    status?: true
    outboundCallId?: true
    requestedAt?: true
    processedAt?: true
  }

  export type CallbackRequestMaxAggregateInputType = {
    id?: true
    businessId?: true
    phoneNumber?: true
    name?: true
    reason?: true
    preferredTime?: true
    status?: true
    outboundCallId?: true
    requestedAt?: true
    processedAt?: true
  }

  export type CallbackRequestCountAggregateInputType = {
    id?: true
    businessId?: true
    phoneNumber?: true
    name?: true
    reason?: true
    preferredTime?: true
    status?: true
    outboundCallId?: true
    requestedAt?: true
    processedAt?: true
    _all?: true
  }

  export type CallbackRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallbackRequest to aggregate.
     */
    where?: CallbackRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallbackRequests to fetch.
     */
    orderBy?: CallbackRequestOrderByWithRelationInput | CallbackRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallbackRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallbackRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallbackRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallbackRequests
    **/
    _count?: true | CallbackRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallbackRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallbackRequestMaxAggregateInputType
  }

  export type GetCallbackRequestAggregateType<T extends CallbackRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCallbackRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallbackRequest[P]>
      : GetScalarType<T[P], AggregateCallbackRequest[P]>
  }




  export type CallbackRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallbackRequestWhereInput
    orderBy?: CallbackRequestOrderByWithAggregationInput | CallbackRequestOrderByWithAggregationInput[]
    by: CallbackRequestScalarFieldEnum[] | CallbackRequestScalarFieldEnum
    having?: CallbackRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallbackRequestCountAggregateInputType | true
    _min?: CallbackRequestMinAggregateInputType
    _max?: CallbackRequestMaxAggregateInputType
  }

  export type CallbackRequestGroupByOutputType = {
    id: string
    businessId: string
    phoneNumber: string
    name: string | null
    reason: string | null
    preferredTime: Date | null
    status: $Enums.CallbackStatus
    outboundCallId: string | null
    requestedAt: Date
    processedAt: Date | null
    _count: CallbackRequestCountAggregateOutputType | null
    _min: CallbackRequestMinAggregateOutputType | null
    _max: CallbackRequestMaxAggregateOutputType | null
  }

  type GetCallbackRequestGroupByPayload<T extends CallbackRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallbackRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallbackRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallbackRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CallbackRequestGroupByOutputType[P]>
        }
      >
    >


  export type CallbackRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    phoneNumber?: boolean
    name?: boolean
    reason?: boolean
    preferredTime?: boolean
    status?: boolean
    outboundCallId?: boolean
    requestedAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["callbackRequest"]>

  export type CallbackRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    phoneNumber?: boolean
    name?: boolean
    reason?: boolean
    preferredTime?: boolean
    status?: boolean
    outboundCallId?: boolean
    requestedAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["callbackRequest"]>

  export type CallbackRequestSelectScalar = {
    id?: boolean
    businessId?: boolean
    phoneNumber?: boolean
    name?: boolean
    reason?: boolean
    preferredTime?: boolean
    status?: boolean
    outboundCallId?: boolean
    requestedAt?: boolean
    processedAt?: boolean
  }


  export type $CallbackRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallbackRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      phoneNumber: string
      name: string | null
      reason: string | null
      preferredTime: Date | null
      status: $Enums.CallbackStatus
      outboundCallId: string | null
      requestedAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["callbackRequest"]>
    composites: {}
  }

  type CallbackRequestGetPayload<S extends boolean | null | undefined | CallbackRequestDefaultArgs> = $Result.GetResult<Prisma.$CallbackRequestPayload, S>

  type CallbackRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CallbackRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallbackRequestCountAggregateInputType | true
    }

  export interface CallbackRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallbackRequest'], meta: { name: 'CallbackRequest' } }
    /**
     * Find zero or one CallbackRequest that matches the filter.
     * @param {CallbackRequestFindUniqueArgs} args - Arguments to find a CallbackRequest
     * @example
     * // Get one CallbackRequest
     * const callbackRequest = await prisma.callbackRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallbackRequestFindUniqueArgs>(args: SelectSubset<T, CallbackRequestFindUniqueArgs<ExtArgs>>): Prisma__CallbackRequestClient<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CallbackRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CallbackRequestFindUniqueOrThrowArgs} args - Arguments to find a CallbackRequest
     * @example
     * // Get one CallbackRequest
     * const callbackRequest = await prisma.callbackRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallbackRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CallbackRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallbackRequestClient<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CallbackRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallbackRequestFindFirstArgs} args - Arguments to find a CallbackRequest
     * @example
     * // Get one CallbackRequest
     * const callbackRequest = await prisma.callbackRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallbackRequestFindFirstArgs>(args?: SelectSubset<T, CallbackRequestFindFirstArgs<ExtArgs>>): Prisma__CallbackRequestClient<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CallbackRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallbackRequestFindFirstOrThrowArgs} args - Arguments to find a CallbackRequest
     * @example
     * // Get one CallbackRequest
     * const callbackRequest = await prisma.callbackRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallbackRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CallbackRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallbackRequestClient<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CallbackRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallbackRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallbackRequests
     * const callbackRequests = await prisma.callbackRequest.findMany()
     * 
     * // Get first 10 CallbackRequests
     * const callbackRequests = await prisma.callbackRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callbackRequestWithIdOnly = await prisma.callbackRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallbackRequestFindManyArgs>(args?: SelectSubset<T, CallbackRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CallbackRequest.
     * @param {CallbackRequestCreateArgs} args - Arguments to create a CallbackRequest.
     * @example
     * // Create one CallbackRequest
     * const CallbackRequest = await prisma.callbackRequest.create({
     *   data: {
     *     // ... data to create a CallbackRequest
     *   }
     * })
     * 
     */
    create<T extends CallbackRequestCreateArgs>(args: SelectSubset<T, CallbackRequestCreateArgs<ExtArgs>>): Prisma__CallbackRequestClient<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CallbackRequests.
     * @param {CallbackRequestCreateManyArgs} args - Arguments to create many CallbackRequests.
     * @example
     * // Create many CallbackRequests
     * const callbackRequest = await prisma.callbackRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallbackRequestCreateManyArgs>(args?: SelectSubset<T, CallbackRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallbackRequests and returns the data saved in the database.
     * @param {CallbackRequestCreateManyAndReturnArgs} args - Arguments to create many CallbackRequests.
     * @example
     * // Create many CallbackRequests
     * const callbackRequest = await prisma.callbackRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallbackRequests and only return the `id`
     * const callbackRequestWithIdOnly = await prisma.callbackRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallbackRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CallbackRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CallbackRequest.
     * @param {CallbackRequestDeleteArgs} args - Arguments to delete one CallbackRequest.
     * @example
     * // Delete one CallbackRequest
     * const CallbackRequest = await prisma.callbackRequest.delete({
     *   where: {
     *     // ... filter to delete one CallbackRequest
     *   }
     * })
     * 
     */
    delete<T extends CallbackRequestDeleteArgs>(args: SelectSubset<T, CallbackRequestDeleteArgs<ExtArgs>>): Prisma__CallbackRequestClient<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CallbackRequest.
     * @param {CallbackRequestUpdateArgs} args - Arguments to update one CallbackRequest.
     * @example
     * // Update one CallbackRequest
     * const callbackRequest = await prisma.callbackRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallbackRequestUpdateArgs>(args: SelectSubset<T, CallbackRequestUpdateArgs<ExtArgs>>): Prisma__CallbackRequestClient<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CallbackRequests.
     * @param {CallbackRequestDeleteManyArgs} args - Arguments to filter CallbackRequests to delete.
     * @example
     * // Delete a few CallbackRequests
     * const { count } = await prisma.callbackRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallbackRequestDeleteManyArgs>(args?: SelectSubset<T, CallbackRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallbackRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallbackRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallbackRequests
     * const callbackRequest = await prisma.callbackRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallbackRequestUpdateManyArgs>(args: SelectSubset<T, CallbackRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CallbackRequest.
     * @param {CallbackRequestUpsertArgs} args - Arguments to update or create a CallbackRequest.
     * @example
     * // Update or create a CallbackRequest
     * const callbackRequest = await prisma.callbackRequest.upsert({
     *   create: {
     *     // ... data to create a CallbackRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallbackRequest we want to update
     *   }
     * })
     */
    upsert<T extends CallbackRequestUpsertArgs>(args: SelectSubset<T, CallbackRequestUpsertArgs<ExtArgs>>): Prisma__CallbackRequestClient<$Result.GetResult<Prisma.$CallbackRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CallbackRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallbackRequestCountArgs} args - Arguments to filter CallbackRequests to count.
     * @example
     * // Count the number of CallbackRequests
     * const count = await prisma.callbackRequest.count({
     *   where: {
     *     // ... the filter for the CallbackRequests we want to count
     *   }
     * })
    **/
    count<T extends CallbackRequestCountArgs>(
      args?: Subset<T, CallbackRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallbackRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallbackRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallbackRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallbackRequestAggregateArgs>(args: Subset<T, CallbackRequestAggregateArgs>): Prisma.PrismaPromise<GetCallbackRequestAggregateType<T>>

    /**
     * Group by CallbackRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallbackRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallbackRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallbackRequestGroupByArgs['orderBy'] }
        : { orderBy?: CallbackRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallbackRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallbackRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallbackRequest model
   */
  readonly fields: CallbackRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallbackRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallbackRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallbackRequest model
   */ 
  interface CallbackRequestFieldRefs {
    readonly id: FieldRef<"CallbackRequest", 'String'>
    readonly businessId: FieldRef<"CallbackRequest", 'String'>
    readonly phoneNumber: FieldRef<"CallbackRequest", 'String'>
    readonly name: FieldRef<"CallbackRequest", 'String'>
    readonly reason: FieldRef<"CallbackRequest", 'String'>
    readonly preferredTime: FieldRef<"CallbackRequest", 'DateTime'>
    readonly status: FieldRef<"CallbackRequest", 'CallbackStatus'>
    readonly outboundCallId: FieldRef<"CallbackRequest", 'String'>
    readonly requestedAt: FieldRef<"CallbackRequest", 'DateTime'>
    readonly processedAt: FieldRef<"CallbackRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallbackRequest findUnique
   */
  export type CallbackRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * Filter, which CallbackRequest to fetch.
     */
    where: CallbackRequestWhereUniqueInput
  }

  /**
   * CallbackRequest findUniqueOrThrow
   */
  export type CallbackRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * Filter, which CallbackRequest to fetch.
     */
    where: CallbackRequestWhereUniqueInput
  }

  /**
   * CallbackRequest findFirst
   */
  export type CallbackRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * Filter, which CallbackRequest to fetch.
     */
    where?: CallbackRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallbackRequests to fetch.
     */
    orderBy?: CallbackRequestOrderByWithRelationInput | CallbackRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallbackRequests.
     */
    cursor?: CallbackRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallbackRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallbackRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallbackRequests.
     */
    distinct?: CallbackRequestScalarFieldEnum | CallbackRequestScalarFieldEnum[]
  }

  /**
   * CallbackRequest findFirstOrThrow
   */
  export type CallbackRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * Filter, which CallbackRequest to fetch.
     */
    where?: CallbackRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallbackRequests to fetch.
     */
    orderBy?: CallbackRequestOrderByWithRelationInput | CallbackRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallbackRequests.
     */
    cursor?: CallbackRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallbackRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallbackRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallbackRequests.
     */
    distinct?: CallbackRequestScalarFieldEnum | CallbackRequestScalarFieldEnum[]
  }

  /**
   * CallbackRequest findMany
   */
  export type CallbackRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * Filter, which CallbackRequests to fetch.
     */
    where?: CallbackRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallbackRequests to fetch.
     */
    orderBy?: CallbackRequestOrderByWithRelationInput | CallbackRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallbackRequests.
     */
    cursor?: CallbackRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallbackRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallbackRequests.
     */
    skip?: number
    distinct?: CallbackRequestScalarFieldEnum | CallbackRequestScalarFieldEnum[]
  }

  /**
   * CallbackRequest create
   */
  export type CallbackRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a CallbackRequest.
     */
    data: XOR<CallbackRequestCreateInput, CallbackRequestUncheckedCreateInput>
  }

  /**
   * CallbackRequest createMany
   */
  export type CallbackRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallbackRequests.
     */
    data: CallbackRequestCreateManyInput | CallbackRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallbackRequest createManyAndReturn
   */
  export type CallbackRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CallbackRequests.
     */
    data: CallbackRequestCreateManyInput | CallbackRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallbackRequest update
   */
  export type CallbackRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a CallbackRequest.
     */
    data: XOR<CallbackRequestUpdateInput, CallbackRequestUncheckedUpdateInput>
    /**
     * Choose, which CallbackRequest to update.
     */
    where: CallbackRequestWhereUniqueInput
  }

  /**
   * CallbackRequest updateMany
   */
  export type CallbackRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallbackRequests.
     */
    data: XOR<CallbackRequestUpdateManyMutationInput, CallbackRequestUncheckedUpdateManyInput>
    /**
     * Filter which CallbackRequests to update
     */
    where?: CallbackRequestWhereInput
  }

  /**
   * CallbackRequest upsert
   */
  export type CallbackRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the CallbackRequest to update in case it exists.
     */
    where: CallbackRequestWhereUniqueInput
    /**
     * In case the CallbackRequest found by the `where` argument doesn't exist, create a new CallbackRequest with this data.
     */
    create: XOR<CallbackRequestCreateInput, CallbackRequestUncheckedCreateInput>
    /**
     * In case the CallbackRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallbackRequestUpdateInput, CallbackRequestUncheckedUpdateInput>
  }

  /**
   * CallbackRequest delete
   */
  export type CallbackRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
    /**
     * Filter which CallbackRequest to delete.
     */
    where: CallbackRequestWhereUniqueInput
  }

  /**
   * CallbackRequest deleteMany
   */
  export type CallbackRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallbackRequests to delete
     */
    where?: CallbackRequestWhereInput
  }

  /**
   * CallbackRequest without action
   */
  export type CallbackRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallbackRequest
     */
    select?: CallbackRequestSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    company: 'company',
    phone: 'phone',
    plan: 'plan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailNotifications: 'emailNotifications',
    smsNotifications: 'smsNotifications',
    callSummaries: 'callSummaries',
    weeklyReports: 'weeklyReports',
    marketingEmails: 'marketingEmails',
    companyName: 'companyName',
    industry: 'industry',
    greeting: 'greeting',
    fallbackMessage: 'fallbackMessage',
    businessHours: 'businessHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    key: 'key',
    name: 'name',
    type: 'type',
    lastUsed: 'lastUsed',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const VoiceModelScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    status: 'status',
    friendliness: 'friendliness',
    professionalism: 'professionalism',
    energy: 'energy',
    formality: 'formality',
    externalVoiceId: 'externalVoiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoiceModelScalarFieldEnum = (typeof VoiceModelScalarFieldEnum)[keyof typeof VoiceModelScalarFieldEnum]


  export const TrainingSampleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    voiceModelId: 'voiceModelId',
    filename: 'filename',
    originalName: 'originalName',
    fileSize: 'fileSize',
    duration: 'duration',
    mimeType: 'mimeType',
    createdAt: 'createdAt'
  };

  export type TrainingSampleScalarFieldEnum = (typeof TrainingSampleScalarFieldEnum)[keyof typeof TrainingSampleScalarFieldEnum]


  export const CallSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    voiceModelId: 'voiceModelId',
    phoneNumber: 'phoneNumber',
    direction: 'direction',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    sentiment: 'sentiment',
    topics: 'topics',
    externalCallId: 'externalCallId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CallSessionScalarFieldEnum = (typeof CallSessionScalarFieldEnum)[keyof typeof CallSessionScalarFieldEnum]


  export const TranscriptMessageScalarFieldEnum: {
    id: 'id',
    callSessionId: 'callSessionId',
    speaker: 'speaker',
    text: 'text',
    confidence: 'confidence',
    timestamp: 'timestamp'
  };

  export type TranscriptMessageScalarFieldEnum = (typeof TranscriptMessageScalarFieldEnum)[keyof typeof TranscriptMessageScalarFieldEnum]


  export const CallSummaryScalarFieldEnum: {
    id: 'id',
    callSessionId: 'callSessionId',
    summary: 'summary',
    actionItems: 'actionItems',
    keyPoints: 'keyPoints',
    createdAt: 'createdAt'
  };

  export type CallSummaryScalarFieldEnum = (typeof CallSummaryScalarFieldEnum)[keyof typeof CallSummaryScalarFieldEnum]


  export const DailyAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    totalCalls: 'totalCalls',
    completedCalls: 'completedCalls',
    missedCalls: 'missedCalls',
    totalDuration: 'totalDuration',
    avgDuration: 'avgDuration',
    positiveSentiment: 'positiveSentiment',
    neutralSentiment: 'neutralSentiment',
    negativeSentiment: 'negativeSentiment',
    topTopics: 'topTopics',
    peakHours: 'peakHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyAnalyticsScalarFieldEnum = (typeof DailyAnalyticsScalarFieldEnum)[keyof typeof DailyAnalyticsScalarFieldEnum]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    phone: 'phone',
    timezone: 'timezone',
    inboundConfig: 'inboundConfig',
    outboundConfig: 'outboundConfig',
    defaultVoiceId: 'defaultVoiceId',
    greeting: 'greeting',
    voicemailPrompt: 'voicemailPrompt',
    holdMusicUrl: 'holdMusicUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const InboundCallScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    callerNumber: 'callerNumber',
    callerName: 'callerName',
    status: 'status',
    duration: 'duration',
    waitTime: 'waitTime',
    routedTo: 'routedTo',
    routingRuleId: 'routingRuleId',
    transcript: 'transcript',
    summary: 'summary',
    sentiment: 'sentiment',
    tags: 'tags',
    externalCallId: 'externalCallId',
    recordingUrl: 'recordingUrl',
    startedAt: 'startedAt',
    answeredAt: 'answeredAt',
    endedAt: 'endedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InboundCallScalarFieldEnum = (typeof InboundCallScalarFieldEnum)[keyof typeof InboundCallScalarFieldEnum]


  export const OutboundCallScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    recipientNumber: 'recipientNumber',
    recipientName: 'recipientName',
    campaignId: 'campaignId',
    status: 'status',
    result: 'result',
    duration: 'duration',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    scriptUsed: 'scriptUsed',
    transcript: 'transcript',
    notes: 'notes',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    externalCallId: 'externalCallId',
    recordingUrl: 'recordingUrl',
    isCallback: 'isCallback',
    callbackReason: 'callbackReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutboundCallScalarFieldEnum = (typeof OutboundCallScalarFieldEnum)[keyof typeof OutboundCallScalarFieldEnum]


  export const CallRoutingRuleScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    priority: 'priority',
    isActive: 'isActive',
    conditionType: 'conditionType',
    conditionValue: 'conditionValue',
    actionType: 'actionType',
    actionConfig: 'actionConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CallRoutingRuleScalarFieldEnum = (typeof CallRoutingRuleScalarFieldEnum)[keyof typeof CallRoutingRuleScalarFieldEnum]


  export const OutboundCampaignScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description',
    scriptTemplate: 'scriptTemplate',
    voiceId: 'voiceId',
    contactList: 'contactList',
    totalContacts: 'totalContacts',
    scheduleConfig: 'scheduleConfig',
    startDate: 'startDate',
    endDate: 'endDate',
    callsPerMinute: 'callsPerMinute',
    maxConcurrent: 'maxConcurrent',
    status: 'status',
    completedCalls: 'completedCalls',
    answeredCalls: 'answeredCalls',
    voicemailCalls: 'voicemailCalls',
    failedCalls: 'failedCalls',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type OutboundCampaignScalarFieldEnum = (typeof OutboundCampaignScalarFieldEnum)[keyof typeof OutboundCampaignScalarFieldEnum]


  export const CallQueueScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    callerNumber: 'callerNumber',
    callerName: 'callerName',
    status: 'status',
    position: 'position',
    priority: 'priority',
    estimatedWait: 'estimatedWait',
    actualWait: 'actualWait',
    externalCallId: 'externalCallId',
    enteredAt: 'enteredAt',
    servedAt: 'servedAt'
  };

  export type CallQueueScalarFieldEnum = (typeof CallQueueScalarFieldEnum)[keyof typeof CallQueueScalarFieldEnum]


  export const CallbackRequestScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    phoneNumber: 'phoneNumber',
    name: 'name',
    reason: 'reason',
    preferredTime: 'preferredTime',
    status: 'status',
    outboundCallId: 'outboundCallId',
    requestedAt: 'requestedAt',
    processedAt: 'processedAt'
  };

  export type CallbackRequestScalarFieldEnum = (typeof CallbackRequestScalarFieldEnum)[keyof typeof CallbackRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Plan'
   */
  export type EnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan'>
    


  /**
   * Reference to a field of type 'Plan[]'
   */
  export type ListEnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ApiKeyType'
   */
  export type EnumApiKeyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiKeyType'>
    


  /**
   * Reference to a field of type 'ApiKeyType[]'
   */
  export type ListEnumApiKeyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiKeyType[]'>
    


  /**
   * Reference to a field of type 'VoiceModelStatus'
   */
  export type EnumVoiceModelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoiceModelStatus'>
    


  /**
   * Reference to a field of type 'VoiceModelStatus[]'
   */
  export type ListEnumVoiceModelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoiceModelStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CallDirection'
   */
  export type EnumCallDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallDirection'>
    


  /**
   * Reference to a field of type 'CallDirection[]'
   */
  export type ListEnumCallDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallDirection[]'>
    


  /**
   * Reference to a field of type 'CallStatus'
   */
  export type EnumCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallStatus'>
    


  /**
   * Reference to a field of type 'CallStatus[]'
   */
  export type ListEnumCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallStatus[]'>
    


  /**
   * Reference to a field of type 'Sentiment'
   */
  export type EnumSentimentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sentiment'>
    


  /**
   * Reference to a field of type 'Sentiment[]'
   */
  export type ListEnumSentimentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sentiment[]'>
    


  /**
   * Reference to a field of type 'Speaker'
   */
  export type EnumSpeakerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Speaker'>
    


  /**
   * Reference to a field of type 'Speaker[]'
   */
  export type ListEnumSpeakerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Speaker[]'>
    


  /**
   * Reference to a field of type 'InboundCallStatus'
   */
  export type EnumInboundCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InboundCallStatus'>
    


  /**
   * Reference to a field of type 'InboundCallStatus[]'
   */
  export type ListEnumInboundCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InboundCallStatus[]'>
    


  /**
   * Reference to a field of type 'OutboundCallStatus'
   */
  export type EnumOutboundCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutboundCallStatus'>
    


  /**
   * Reference to a field of type 'OutboundCallStatus[]'
   */
  export type ListEnumOutboundCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutboundCallStatus[]'>
    


  /**
   * Reference to a field of type 'CallResult'
   */
  export type EnumCallResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallResult'>
    


  /**
   * Reference to a field of type 'CallResult[]'
   */
  export type ListEnumCallResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallResult[]'>
    


  /**
   * Reference to a field of type 'ConditionType'
   */
  export type EnumConditionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConditionType'>
    


  /**
   * Reference to a field of type 'ConditionType[]'
   */
  export type ListEnumConditionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConditionType[]'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'ActionType[]'
   */
  export type ListEnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'QueueStatus'
   */
  export type EnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus'>
    


  /**
   * Reference to a field of type 'QueueStatus[]'
   */
  export type ListEnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus[]'>
    


  /**
   * Reference to a field of type 'CallbackStatus'
   */
  export type EnumCallbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallbackStatus'>
    


  /**
   * Reference to a field of type 'CallbackStatus[]'
   */
  export type ListEnumCallbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallbackStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    company?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    plan?: EnumPlanFilter<"User"> | $Enums.Plan
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    voiceModels?: VoiceModelListRelationFilter
    callSessions?: CallSessionListRelationFilter
    trainingSamples?: TrainingSampleListRelationFilter
    settings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    apiKeys?: ApiKeyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    company?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    voiceModels?: VoiceModelOrderByRelationAggregateInput
    callSessions?: CallSessionOrderByRelationAggregateInput
    trainingSamples?: TrainingSampleOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    company?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    plan?: EnumPlanFilter<"User"> | $Enums.Plan
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    voiceModels?: VoiceModelListRelationFilter
    callSessions?: CallSessionListRelationFilter
    trainingSamples?: TrainingSampleListRelationFilter
    settings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    apiKeys?: ApiKeyListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    company?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    company?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    plan?: EnumPlanWithAggregatesFilter<"User"> | $Enums.Plan
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    smsNotifications?: BoolFilter<"UserSettings"> | boolean
    callSummaries?: BoolFilter<"UserSettings"> | boolean
    weeklyReports?: BoolFilter<"UserSettings"> | boolean
    marketingEmails?: BoolFilter<"UserSettings"> | boolean
    companyName?: StringNullableFilter<"UserSettings"> | string | null
    industry?: StringNullableFilter<"UserSettings"> | string | null
    greeting?: StringNullableFilter<"UserSettings"> | string | null
    fallbackMessage?: StringNullableFilter<"UserSettings"> | string | null
    businessHours?: JsonNullableFilter<"UserSettings">
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    callSummaries?: SortOrder
    weeklyReports?: SortOrder
    marketingEmails?: SortOrder
    companyName?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    greeting?: SortOrderInput | SortOrder
    fallbackMessage?: SortOrderInput | SortOrder
    businessHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    smsNotifications?: BoolFilter<"UserSettings"> | boolean
    callSummaries?: BoolFilter<"UserSettings"> | boolean
    weeklyReports?: BoolFilter<"UserSettings"> | boolean
    marketingEmails?: BoolFilter<"UserSettings"> | boolean
    companyName?: StringNullableFilter<"UserSettings"> | string | null
    industry?: StringNullableFilter<"UserSettings"> | string | null
    greeting?: StringNullableFilter<"UserSettings"> | string | null
    fallbackMessage?: StringNullableFilter<"UserSettings"> | string | null
    businessHours?: JsonNullableFilter<"UserSettings">
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    callSummaries?: SortOrder
    weeklyReports?: SortOrder
    marketingEmails?: SortOrder
    companyName?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    greeting?: SortOrderInput | SortOrder
    fallbackMessage?: SortOrderInput | SortOrder
    businessHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    emailNotifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    smsNotifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    callSummaries?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    weeklyReports?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    marketingEmails?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    companyName?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    industry?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    greeting?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    fallbackMessage?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    businessHours?: JsonNullableWithAggregatesFilter<"UserSettings">
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    type?: EnumApiKeyTypeFilter<"ApiKey"> | $Enums.ApiKeyType
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    type?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    type?: EnumApiKeyTypeFilter<"ApiKey"> | $Enums.ApiKeyType
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    type?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    type?: EnumApiKeyTypeWithAggregatesFilter<"ApiKey"> | $Enums.ApiKeyType
    lastUsed?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type VoiceModelWhereInput = {
    AND?: VoiceModelWhereInput | VoiceModelWhereInput[]
    OR?: VoiceModelWhereInput[]
    NOT?: VoiceModelWhereInput | VoiceModelWhereInput[]
    id?: StringFilter<"VoiceModel"> | string
    userId?: StringFilter<"VoiceModel"> | string
    name?: StringFilter<"VoiceModel"> | string
    status?: EnumVoiceModelStatusFilter<"VoiceModel"> | $Enums.VoiceModelStatus
    friendliness?: IntFilter<"VoiceModel"> | number
    professionalism?: IntFilter<"VoiceModel"> | number
    energy?: IntFilter<"VoiceModel"> | number
    formality?: IntFilter<"VoiceModel"> | number
    externalVoiceId?: StringNullableFilter<"VoiceModel"> | string | null
    createdAt?: DateTimeFilter<"VoiceModel"> | Date | string
    updatedAt?: DateTimeFilter<"VoiceModel"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    samples?: TrainingSampleListRelationFilter
    callSessions?: CallSessionListRelationFilter
  }

  export type VoiceModelOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    friendliness?: SortOrder
    professionalism?: SortOrder
    energy?: SortOrder
    formality?: SortOrder
    externalVoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    samples?: TrainingSampleOrderByRelationAggregateInput
    callSessions?: CallSessionOrderByRelationAggregateInput
  }

  export type VoiceModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoiceModelWhereInput | VoiceModelWhereInput[]
    OR?: VoiceModelWhereInput[]
    NOT?: VoiceModelWhereInput | VoiceModelWhereInput[]
    userId?: StringFilter<"VoiceModel"> | string
    name?: StringFilter<"VoiceModel"> | string
    status?: EnumVoiceModelStatusFilter<"VoiceModel"> | $Enums.VoiceModelStatus
    friendliness?: IntFilter<"VoiceModel"> | number
    professionalism?: IntFilter<"VoiceModel"> | number
    energy?: IntFilter<"VoiceModel"> | number
    formality?: IntFilter<"VoiceModel"> | number
    externalVoiceId?: StringNullableFilter<"VoiceModel"> | string | null
    createdAt?: DateTimeFilter<"VoiceModel"> | Date | string
    updatedAt?: DateTimeFilter<"VoiceModel"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    samples?: TrainingSampleListRelationFilter
    callSessions?: CallSessionListRelationFilter
  }, "id">

  export type VoiceModelOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    friendliness?: SortOrder
    professionalism?: SortOrder
    energy?: SortOrder
    formality?: SortOrder
    externalVoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoiceModelCountOrderByAggregateInput
    _avg?: VoiceModelAvgOrderByAggregateInput
    _max?: VoiceModelMaxOrderByAggregateInput
    _min?: VoiceModelMinOrderByAggregateInput
    _sum?: VoiceModelSumOrderByAggregateInput
  }

  export type VoiceModelScalarWhereWithAggregatesInput = {
    AND?: VoiceModelScalarWhereWithAggregatesInput | VoiceModelScalarWhereWithAggregatesInput[]
    OR?: VoiceModelScalarWhereWithAggregatesInput[]
    NOT?: VoiceModelScalarWhereWithAggregatesInput | VoiceModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoiceModel"> | string
    userId?: StringWithAggregatesFilter<"VoiceModel"> | string
    name?: StringWithAggregatesFilter<"VoiceModel"> | string
    status?: EnumVoiceModelStatusWithAggregatesFilter<"VoiceModel"> | $Enums.VoiceModelStatus
    friendliness?: IntWithAggregatesFilter<"VoiceModel"> | number
    professionalism?: IntWithAggregatesFilter<"VoiceModel"> | number
    energy?: IntWithAggregatesFilter<"VoiceModel"> | number
    formality?: IntWithAggregatesFilter<"VoiceModel"> | number
    externalVoiceId?: StringNullableWithAggregatesFilter<"VoiceModel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VoiceModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VoiceModel"> | Date | string
  }

  export type TrainingSampleWhereInput = {
    AND?: TrainingSampleWhereInput | TrainingSampleWhereInput[]
    OR?: TrainingSampleWhereInput[]
    NOT?: TrainingSampleWhereInput | TrainingSampleWhereInput[]
    id?: StringFilter<"TrainingSample"> | string
    userId?: StringFilter<"TrainingSample"> | string
    voiceModelId?: StringNullableFilter<"TrainingSample"> | string | null
    filename?: StringFilter<"TrainingSample"> | string
    originalName?: StringFilter<"TrainingSample"> | string
    fileSize?: IntFilter<"TrainingSample"> | number
    duration?: FloatNullableFilter<"TrainingSample"> | number | null
    mimeType?: StringFilter<"TrainingSample"> | string
    createdAt?: DateTimeFilter<"TrainingSample"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    voiceModel?: XOR<VoiceModelNullableRelationFilter, VoiceModelWhereInput> | null
  }

  export type TrainingSampleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrderInput | SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    voiceModel?: VoiceModelOrderByWithRelationInput
  }

  export type TrainingSampleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingSampleWhereInput | TrainingSampleWhereInput[]
    OR?: TrainingSampleWhereInput[]
    NOT?: TrainingSampleWhereInput | TrainingSampleWhereInput[]
    userId?: StringFilter<"TrainingSample"> | string
    voiceModelId?: StringNullableFilter<"TrainingSample"> | string | null
    filename?: StringFilter<"TrainingSample"> | string
    originalName?: StringFilter<"TrainingSample"> | string
    fileSize?: IntFilter<"TrainingSample"> | number
    duration?: FloatNullableFilter<"TrainingSample"> | number | null
    mimeType?: StringFilter<"TrainingSample"> | string
    createdAt?: DateTimeFilter<"TrainingSample"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    voiceModel?: XOR<VoiceModelNullableRelationFilter, VoiceModelWhereInput> | null
  }, "id">

  export type TrainingSampleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrderInput | SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    _count?: TrainingSampleCountOrderByAggregateInput
    _avg?: TrainingSampleAvgOrderByAggregateInput
    _max?: TrainingSampleMaxOrderByAggregateInput
    _min?: TrainingSampleMinOrderByAggregateInput
    _sum?: TrainingSampleSumOrderByAggregateInput
  }

  export type TrainingSampleScalarWhereWithAggregatesInput = {
    AND?: TrainingSampleScalarWhereWithAggregatesInput | TrainingSampleScalarWhereWithAggregatesInput[]
    OR?: TrainingSampleScalarWhereWithAggregatesInput[]
    NOT?: TrainingSampleScalarWhereWithAggregatesInput | TrainingSampleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingSample"> | string
    userId?: StringWithAggregatesFilter<"TrainingSample"> | string
    voiceModelId?: StringNullableWithAggregatesFilter<"TrainingSample"> | string | null
    filename?: StringWithAggregatesFilter<"TrainingSample"> | string
    originalName?: StringWithAggregatesFilter<"TrainingSample"> | string
    fileSize?: IntWithAggregatesFilter<"TrainingSample"> | number
    duration?: FloatNullableWithAggregatesFilter<"TrainingSample"> | number | null
    mimeType?: StringWithAggregatesFilter<"TrainingSample"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingSample"> | Date | string
  }

  export type CallSessionWhereInput = {
    AND?: CallSessionWhereInput | CallSessionWhereInput[]
    OR?: CallSessionWhereInput[]
    NOT?: CallSessionWhereInput | CallSessionWhereInput[]
    id?: StringFilter<"CallSession"> | string
    userId?: StringFilter<"CallSession"> | string
    voiceModelId?: StringNullableFilter<"CallSession"> | string | null
    phoneNumber?: StringFilter<"CallSession"> | string
    direction?: EnumCallDirectionFilter<"CallSession"> | $Enums.CallDirection
    status?: EnumCallStatusFilter<"CallSession"> | $Enums.CallStatus
    startTime?: DateTimeFilter<"CallSession"> | Date | string
    endTime?: DateTimeNullableFilter<"CallSession"> | Date | string | null
    duration?: IntNullableFilter<"CallSession"> | number | null
    sentiment?: EnumSentimentNullableFilter<"CallSession"> | $Enums.Sentiment | null
    topics?: StringNullableListFilter<"CallSession">
    externalCallId?: StringNullableFilter<"CallSession"> | string | null
    createdAt?: DateTimeFilter<"CallSession"> | Date | string
    updatedAt?: DateTimeFilter<"CallSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    voiceModel?: XOR<VoiceModelNullableRelationFilter, VoiceModelWhereInput> | null
    transcript?: TranscriptMessageListRelationFilter
    summary?: XOR<CallSummaryNullableRelationFilter, CallSummaryWhereInput> | null
  }

  export type CallSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    topics?: SortOrder
    externalCallId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    voiceModel?: VoiceModelOrderByWithRelationInput
    transcript?: TranscriptMessageOrderByRelationAggregateInput
    summary?: CallSummaryOrderByWithRelationInput
  }

  export type CallSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallSessionWhereInput | CallSessionWhereInput[]
    OR?: CallSessionWhereInput[]
    NOT?: CallSessionWhereInput | CallSessionWhereInput[]
    userId?: StringFilter<"CallSession"> | string
    voiceModelId?: StringNullableFilter<"CallSession"> | string | null
    phoneNumber?: StringFilter<"CallSession"> | string
    direction?: EnumCallDirectionFilter<"CallSession"> | $Enums.CallDirection
    status?: EnumCallStatusFilter<"CallSession"> | $Enums.CallStatus
    startTime?: DateTimeFilter<"CallSession"> | Date | string
    endTime?: DateTimeNullableFilter<"CallSession"> | Date | string | null
    duration?: IntNullableFilter<"CallSession"> | number | null
    sentiment?: EnumSentimentNullableFilter<"CallSession"> | $Enums.Sentiment | null
    topics?: StringNullableListFilter<"CallSession">
    externalCallId?: StringNullableFilter<"CallSession"> | string | null
    createdAt?: DateTimeFilter<"CallSession"> | Date | string
    updatedAt?: DateTimeFilter<"CallSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    voiceModel?: XOR<VoiceModelNullableRelationFilter, VoiceModelWhereInput> | null
    transcript?: TranscriptMessageListRelationFilter
    summary?: XOR<CallSummaryNullableRelationFilter, CallSummaryWhereInput> | null
  }, "id">

  export type CallSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    topics?: SortOrder
    externalCallId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CallSessionCountOrderByAggregateInput
    _avg?: CallSessionAvgOrderByAggregateInput
    _max?: CallSessionMaxOrderByAggregateInput
    _min?: CallSessionMinOrderByAggregateInput
    _sum?: CallSessionSumOrderByAggregateInput
  }

  export type CallSessionScalarWhereWithAggregatesInput = {
    AND?: CallSessionScalarWhereWithAggregatesInput | CallSessionScalarWhereWithAggregatesInput[]
    OR?: CallSessionScalarWhereWithAggregatesInput[]
    NOT?: CallSessionScalarWhereWithAggregatesInput | CallSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallSession"> | string
    userId?: StringWithAggregatesFilter<"CallSession"> | string
    voiceModelId?: StringNullableWithAggregatesFilter<"CallSession"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"CallSession"> | string
    direction?: EnumCallDirectionWithAggregatesFilter<"CallSession"> | $Enums.CallDirection
    status?: EnumCallStatusWithAggregatesFilter<"CallSession"> | $Enums.CallStatus
    startTime?: DateTimeWithAggregatesFilter<"CallSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"CallSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"CallSession"> | number | null
    sentiment?: EnumSentimentNullableWithAggregatesFilter<"CallSession"> | $Enums.Sentiment | null
    topics?: StringNullableListFilter<"CallSession">
    externalCallId?: StringNullableWithAggregatesFilter<"CallSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CallSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CallSession"> | Date | string
  }

  export type TranscriptMessageWhereInput = {
    AND?: TranscriptMessageWhereInput | TranscriptMessageWhereInput[]
    OR?: TranscriptMessageWhereInput[]
    NOT?: TranscriptMessageWhereInput | TranscriptMessageWhereInput[]
    id?: StringFilter<"TranscriptMessage"> | string
    callSessionId?: StringFilter<"TranscriptMessage"> | string
    speaker?: EnumSpeakerFilter<"TranscriptMessage"> | $Enums.Speaker
    text?: StringFilter<"TranscriptMessage"> | string
    confidence?: FloatNullableFilter<"TranscriptMessage"> | number | null
    timestamp?: DateTimeFilter<"TranscriptMessage"> | Date | string
    callSession?: XOR<CallSessionRelationFilter, CallSessionWhereInput>
  }

  export type TranscriptMessageOrderByWithRelationInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    speaker?: SortOrder
    text?: SortOrder
    confidence?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    callSession?: CallSessionOrderByWithRelationInput
  }

  export type TranscriptMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptMessageWhereInput | TranscriptMessageWhereInput[]
    OR?: TranscriptMessageWhereInput[]
    NOT?: TranscriptMessageWhereInput | TranscriptMessageWhereInput[]
    callSessionId?: StringFilter<"TranscriptMessage"> | string
    speaker?: EnumSpeakerFilter<"TranscriptMessage"> | $Enums.Speaker
    text?: StringFilter<"TranscriptMessage"> | string
    confidence?: FloatNullableFilter<"TranscriptMessage"> | number | null
    timestamp?: DateTimeFilter<"TranscriptMessage"> | Date | string
    callSession?: XOR<CallSessionRelationFilter, CallSessionWhereInput>
  }, "id">

  export type TranscriptMessageOrderByWithAggregationInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    speaker?: SortOrder
    text?: SortOrder
    confidence?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: TranscriptMessageCountOrderByAggregateInput
    _avg?: TranscriptMessageAvgOrderByAggregateInput
    _max?: TranscriptMessageMaxOrderByAggregateInput
    _min?: TranscriptMessageMinOrderByAggregateInput
    _sum?: TranscriptMessageSumOrderByAggregateInput
  }

  export type TranscriptMessageScalarWhereWithAggregatesInput = {
    AND?: TranscriptMessageScalarWhereWithAggregatesInput | TranscriptMessageScalarWhereWithAggregatesInput[]
    OR?: TranscriptMessageScalarWhereWithAggregatesInput[]
    NOT?: TranscriptMessageScalarWhereWithAggregatesInput | TranscriptMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TranscriptMessage"> | string
    callSessionId?: StringWithAggregatesFilter<"TranscriptMessage"> | string
    speaker?: EnumSpeakerWithAggregatesFilter<"TranscriptMessage"> | $Enums.Speaker
    text?: StringWithAggregatesFilter<"TranscriptMessage"> | string
    confidence?: FloatNullableWithAggregatesFilter<"TranscriptMessage"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"TranscriptMessage"> | Date | string
  }

  export type CallSummaryWhereInput = {
    AND?: CallSummaryWhereInput | CallSummaryWhereInput[]
    OR?: CallSummaryWhereInput[]
    NOT?: CallSummaryWhereInput | CallSummaryWhereInput[]
    id?: StringFilter<"CallSummary"> | string
    callSessionId?: StringFilter<"CallSummary"> | string
    summary?: StringFilter<"CallSummary"> | string
    actionItems?: StringNullableListFilter<"CallSummary">
    keyPoints?: StringNullableListFilter<"CallSummary">
    createdAt?: DateTimeFilter<"CallSummary"> | Date | string
    callSession?: XOR<CallSessionRelationFilter, CallSessionWhereInput>
  }

  export type CallSummaryOrderByWithRelationInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    summary?: SortOrder
    actionItems?: SortOrder
    keyPoints?: SortOrder
    createdAt?: SortOrder
    callSession?: CallSessionOrderByWithRelationInput
  }

  export type CallSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    callSessionId?: string
    AND?: CallSummaryWhereInput | CallSummaryWhereInput[]
    OR?: CallSummaryWhereInput[]
    NOT?: CallSummaryWhereInput | CallSummaryWhereInput[]
    summary?: StringFilter<"CallSummary"> | string
    actionItems?: StringNullableListFilter<"CallSummary">
    keyPoints?: StringNullableListFilter<"CallSummary">
    createdAt?: DateTimeFilter<"CallSummary"> | Date | string
    callSession?: XOR<CallSessionRelationFilter, CallSessionWhereInput>
  }, "id" | "callSessionId">

  export type CallSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    summary?: SortOrder
    actionItems?: SortOrder
    keyPoints?: SortOrder
    createdAt?: SortOrder
    _count?: CallSummaryCountOrderByAggregateInput
    _max?: CallSummaryMaxOrderByAggregateInput
    _min?: CallSummaryMinOrderByAggregateInput
  }

  export type CallSummaryScalarWhereWithAggregatesInput = {
    AND?: CallSummaryScalarWhereWithAggregatesInput | CallSummaryScalarWhereWithAggregatesInput[]
    OR?: CallSummaryScalarWhereWithAggregatesInput[]
    NOT?: CallSummaryScalarWhereWithAggregatesInput | CallSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallSummary"> | string
    callSessionId?: StringWithAggregatesFilter<"CallSummary"> | string
    summary?: StringWithAggregatesFilter<"CallSummary"> | string
    actionItems?: StringNullableListFilter<"CallSummary">
    keyPoints?: StringNullableListFilter<"CallSummary">
    createdAt?: DateTimeWithAggregatesFilter<"CallSummary"> | Date | string
  }

  export type DailyAnalyticsWhereInput = {
    AND?: DailyAnalyticsWhereInput | DailyAnalyticsWhereInput[]
    OR?: DailyAnalyticsWhereInput[]
    NOT?: DailyAnalyticsWhereInput | DailyAnalyticsWhereInput[]
    id?: StringFilter<"DailyAnalytics"> | string
    userId?: StringFilter<"DailyAnalytics"> | string
    date?: DateTimeFilter<"DailyAnalytics"> | Date | string
    totalCalls?: IntFilter<"DailyAnalytics"> | number
    completedCalls?: IntFilter<"DailyAnalytics"> | number
    missedCalls?: IntFilter<"DailyAnalytics"> | number
    totalDuration?: IntFilter<"DailyAnalytics"> | number
    avgDuration?: FloatFilter<"DailyAnalytics"> | number
    positiveSentiment?: IntFilter<"DailyAnalytics"> | number
    neutralSentiment?: IntFilter<"DailyAnalytics"> | number
    negativeSentiment?: IntFilter<"DailyAnalytics"> | number
    topTopics?: JsonNullableFilter<"DailyAnalytics">
    peakHours?: JsonNullableFilter<"DailyAnalytics">
    createdAt?: DateTimeFilter<"DailyAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"DailyAnalytics"> | Date | string
  }

  export type DailyAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    totalCalls?: SortOrder
    completedCalls?: SortOrder
    missedCalls?: SortOrder
    totalDuration?: SortOrder
    avgDuration?: SortOrder
    positiveSentiment?: SortOrder
    neutralSentiment?: SortOrder
    negativeSentiment?: SortOrder
    topTopics?: SortOrderInput | SortOrder
    peakHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: DailyAnalyticsUserIdDateCompoundUniqueInput
    AND?: DailyAnalyticsWhereInput | DailyAnalyticsWhereInput[]
    OR?: DailyAnalyticsWhereInput[]
    NOT?: DailyAnalyticsWhereInput | DailyAnalyticsWhereInput[]
    userId?: StringFilter<"DailyAnalytics"> | string
    date?: DateTimeFilter<"DailyAnalytics"> | Date | string
    totalCalls?: IntFilter<"DailyAnalytics"> | number
    completedCalls?: IntFilter<"DailyAnalytics"> | number
    missedCalls?: IntFilter<"DailyAnalytics"> | number
    totalDuration?: IntFilter<"DailyAnalytics"> | number
    avgDuration?: FloatFilter<"DailyAnalytics"> | number
    positiveSentiment?: IntFilter<"DailyAnalytics"> | number
    neutralSentiment?: IntFilter<"DailyAnalytics"> | number
    negativeSentiment?: IntFilter<"DailyAnalytics"> | number
    topTopics?: JsonNullableFilter<"DailyAnalytics">
    peakHours?: JsonNullableFilter<"DailyAnalytics">
    createdAt?: DateTimeFilter<"DailyAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"DailyAnalytics"> | Date | string
  }, "id" | "userId_date">

  export type DailyAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    totalCalls?: SortOrder
    completedCalls?: SortOrder
    missedCalls?: SortOrder
    totalDuration?: SortOrder
    avgDuration?: SortOrder
    positiveSentiment?: SortOrder
    neutralSentiment?: SortOrder
    negativeSentiment?: SortOrder
    topTopics?: SortOrderInput | SortOrder
    peakHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyAnalyticsCountOrderByAggregateInput
    _avg?: DailyAnalyticsAvgOrderByAggregateInput
    _max?: DailyAnalyticsMaxOrderByAggregateInput
    _min?: DailyAnalyticsMinOrderByAggregateInput
    _sum?: DailyAnalyticsSumOrderByAggregateInput
  }

  export type DailyAnalyticsScalarWhereWithAggregatesInput = {
    AND?: DailyAnalyticsScalarWhereWithAggregatesInput | DailyAnalyticsScalarWhereWithAggregatesInput[]
    OR?: DailyAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: DailyAnalyticsScalarWhereWithAggregatesInput | DailyAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyAnalytics"> | string
    userId?: StringWithAggregatesFilter<"DailyAnalytics"> | string
    date?: DateTimeWithAggregatesFilter<"DailyAnalytics"> | Date | string
    totalCalls?: IntWithAggregatesFilter<"DailyAnalytics"> | number
    completedCalls?: IntWithAggregatesFilter<"DailyAnalytics"> | number
    missedCalls?: IntWithAggregatesFilter<"DailyAnalytics"> | number
    totalDuration?: IntWithAggregatesFilter<"DailyAnalytics"> | number
    avgDuration?: FloatWithAggregatesFilter<"DailyAnalytics"> | number
    positiveSentiment?: IntWithAggregatesFilter<"DailyAnalytics"> | number
    neutralSentiment?: IntWithAggregatesFilter<"DailyAnalytics"> | number
    negativeSentiment?: IntWithAggregatesFilter<"DailyAnalytics"> | number
    topTopics?: JsonNullableWithAggregatesFilter<"DailyAnalytics">
    peakHours?: JsonNullableWithAggregatesFilter<"DailyAnalytics">
    createdAt?: DateTimeWithAggregatesFilter<"DailyAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyAnalytics"> | Date | string
  }

  export type BusinessWhereInput = {
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    id?: StringFilter<"Business"> | string
    userId?: StringFilter<"Business"> | string
    name?: StringFilter<"Business"> | string
    phone?: StringNullableFilter<"Business"> | string | null
    timezone?: StringFilter<"Business"> | string
    inboundConfig?: JsonNullableFilter<"Business">
    outboundConfig?: JsonNullableFilter<"Business">
    defaultVoiceId?: StringNullableFilter<"Business"> | string | null
    greeting?: StringNullableFilter<"Business"> | string | null
    voicemailPrompt?: StringNullableFilter<"Business"> | string | null
    holdMusicUrl?: StringNullableFilter<"Business"> | string | null
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    inboundCalls?: InboundCallListRelationFilter
    outboundCalls?: OutboundCallListRelationFilter
    routingRules?: CallRoutingRuleListRelationFilter
    campaigns?: OutboundCampaignListRelationFilter
    callQueue?: CallQueueListRelationFilter
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    timezone?: SortOrder
    inboundConfig?: SortOrderInput | SortOrder
    outboundConfig?: SortOrderInput | SortOrder
    defaultVoiceId?: SortOrderInput | SortOrder
    greeting?: SortOrderInput | SortOrder
    voicemailPrompt?: SortOrderInput | SortOrder
    holdMusicUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inboundCalls?: InboundCallOrderByRelationAggregateInput
    outboundCalls?: OutboundCallOrderByRelationAggregateInput
    routingRules?: CallRoutingRuleOrderByRelationAggregateInput
    campaigns?: OutboundCampaignOrderByRelationAggregateInput
    callQueue?: CallQueueOrderByRelationAggregateInput
  }

  export type BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    userId?: StringFilter<"Business"> | string
    name?: StringFilter<"Business"> | string
    phone?: StringNullableFilter<"Business"> | string | null
    timezone?: StringFilter<"Business"> | string
    inboundConfig?: JsonNullableFilter<"Business">
    outboundConfig?: JsonNullableFilter<"Business">
    defaultVoiceId?: StringNullableFilter<"Business"> | string | null
    greeting?: StringNullableFilter<"Business"> | string | null
    voicemailPrompt?: StringNullableFilter<"Business"> | string | null
    holdMusicUrl?: StringNullableFilter<"Business"> | string | null
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    inboundCalls?: InboundCallListRelationFilter
    outboundCalls?: OutboundCallListRelationFilter
    routingRules?: CallRoutingRuleListRelationFilter
    campaigns?: OutboundCampaignListRelationFilter
    callQueue?: CallQueueListRelationFilter
  }, "id">

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    timezone?: SortOrder
    inboundConfig?: SortOrderInput | SortOrder
    outboundConfig?: SortOrderInput | SortOrder
    defaultVoiceId?: SortOrderInput | SortOrder
    greeting?: SortOrderInput | SortOrder
    voicemailPrompt?: SortOrderInput | SortOrder
    holdMusicUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    OR?: BusinessScalarWhereWithAggregatesInput[]
    NOT?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Business"> | string
    userId?: StringWithAggregatesFilter<"Business"> | string
    name?: StringWithAggregatesFilter<"Business"> | string
    phone?: StringNullableWithAggregatesFilter<"Business"> | string | null
    timezone?: StringWithAggregatesFilter<"Business"> | string
    inboundConfig?: JsonNullableWithAggregatesFilter<"Business">
    outboundConfig?: JsonNullableWithAggregatesFilter<"Business">
    defaultVoiceId?: StringNullableWithAggregatesFilter<"Business"> | string | null
    greeting?: StringNullableWithAggregatesFilter<"Business"> | string | null
    voicemailPrompt?: StringNullableWithAggregatesFilter<"Business"> | string | null
    holdMusicUrl?: StringNullableWithAggregatesFilter<"Business"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
  }

  export type InboundCallWhereInput = {
    AND?: InboundCallWhereInput | InboundCallWhereInput[]
    OR?: InboundCallWhereInput[]
    NOT?: InboundCallWhereInput | InboundCallWhereInput[]
    id?: StringFilter<"InboundCall"> | string
    businessId?: StringFilter<"InboundCall"> | string
    callerNumber?: StringFilter<"InboundCall"> | string
    callerName?: StringNullableFilter<"InboundCall"> | string | null
    status?: EnumInboundCallStatusFilter<"InboundCall"> | $Enums.InboundCallStatus
    duration?: IntNullableFilter<"InboundCall"> | number | null
    waitTime?: IntNullableFilter<"InboundCall"> | number | null
    routedTo?: StringNullableFilter<"InboundCall"> | string | null
    routingRuleId?: StringNullableFilter<"InboundCall"> | string | null
    transcript?: StringNullableFilter<"InboundCall"> | string | null
    summary?: StringNullableFilter<"InboundCall"> | string | null
    sentiment?: EnumSentimentNullableFilter<"InboundCall"> | $Enums.Sentiment | null
    tags?: StringNullableListFilter<"InboundCall">
    externalCallId?: StringNullableFilter<"InboundCall"> | string | null
    recordingUrl?: StringNullableFilter<"InboundCall"> | string | null
    startedAt?: DateTimeFilter<"InboundCall"> | Date | string
    answeredAt?: DateTimeNullableFilter<"InboundCall"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"InboundCall"> | Date | string | null
    createdAt?: DateTimeFilter<"InboundCall"> | Date | string
    updatedAt?: DateTimeFilter<"InboundCall"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type InboundCallOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrderInput | SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    waitTime?: SortOrderInput | SortOrder
    routedTo?: SortOrderInput | SortOrder
    routingRuleId?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    tags?: SortOrder
    externalCallId?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    answeredAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type InboundCallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InboundCallWhereInput | InboundCallWhereInput[]
    OR?: InboundCallWhereInput[]
    NOT?: InboundCallWhereInput | InboundCallWhereInput[]
    businessId?: StringFilter<"InboundCall"> | string
    callerNumber?: StringFilter<"InboundCall"> | string
    callerName?: StringNullableFilter<"InboundCall"> | string | null
    status?: EnumInboundCallStatusFilter<"InboundCall"> | $Enums.InboundCallStatus
    duration?: IntNullableFilter<"InboundCall"> | number | null
    waitTime?: IntNullableFilter<"InboundCall"> | number | null
    routedTo?: StringNullableFilter<"InboundCall"> | string | null
    routingRuleId?: StringNullableFilter<"InboundCall"> | string | null
    transcript?: StringNullableFilter<"InboundCall"> | string | null
    summary?: StringNullableFilter<"InboundCall"> | string | null
    sentiment?: EnumSentimentNullableFilter<"InboundCall"> | $Enums.Sentiment | null
    tags?: StringNullableListFilter<"InboundCall">
    externalCallId?: StringNullableFilter<"InboundCall"> | string | null
    recordingUrl?: StringNullableFilter<"InboundCall"> | string | null
    startedAt?: DateTimeFilter<"InboundCall"> | Date | string
    answeredAt?: DateTimeNullableFilter<"InboundCall"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"InboundCall"> | Date | string | null
    createdAt?: DateTimeFilter<"InboundCall"> | Date | string
    updatedAt?: DateTimeFilter<"InboundCall"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }, "id">

  export type InboundCallOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrderInput | SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    waitTime?: SortOrderInput | SortOrder
    routedTo?: SortOrderInput | SortOrder
    routingRuleId?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    tags?: SortOrder
    externalCallId?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    answeredAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InboundCallCountOrderByAggregateInput
    _avg?: InboundCallAvgOrderByAggregateInput
    _max?: InboundCallMaxOrderByAggregateInput
    _min?: InboundCallMinOrderByAggregateInput
    _sum?: InboundCallSumOrderByAggregateInput
  }

  export type InboundCallScalarWhereWithAggregatesInput = {
    AND?: InboundCallScalarWhereWithAggregatesInput | InboundCallScalarWhereWithAggregatesInput[]
    OR?: InboundCallScalarWhereWithAggregatesInput[]
    NOT?: InboundCallScalarWhereWithAggregatesInput | InboundCallScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InboundCall"> | string
    businessId?: StringWithAggregatesFilter<"InboundCall"> | string
    callerNumber?: StringWithAggregatesFilter<"InboundCall"> | string
    callerName?: StringNullableWithAggregatesFilter<"InboundCall"> | string | null
    status?: EnumInboundCallStatusWithAggregatesFilter<"InboundCall"> | $Enums.InboundCallStatus
    duration?: IntNullableWithAggregatesFilter<"InboundCall"> | number | null
    waitTime?: IntNullableWithAggregatesFilter<"InboundCall"> | number | null
    routedTo?: StringNullableWithAggregatesFilter<"InboundCall"> | string | null
    routingRuleId?: StringNullableWithAggregatesFilter<"InboundCall"> | string | null
    transcript?: StringNullableWithAggregatesFilter<"InboundCall"> | string | null
    summary?: StringNullableWithAggregatesFilter<"InboundCall"> | string | null
    sentiment?: EnumSentimentNullableWithAggregatesFilter<"InboundCall"> | $Enums.Sentiment | null
    tags?: StringNullableListFilter<"InboundCall">
    externalCallId?: StringNullableWithAggregatesFilter<"InboundCall"> | string | null
    recordingUrl?: StringNullableWithAggregatesFilter<"InboundCall"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"InboundCall"> | Date | string
    answeredAt?: DateTimeNullableWithAggregatesFilter<"InboundCall"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"InboundCall"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InboundCall"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InboundCall"> | Date | string
  }

  export type OutboundCallWhereInput = {
    AND?: OutboundCallWhereInput | OutboundCallWhereInput[]
    OR?: OutboundCallWhereInput[]
    NOT?: OutboundCallWhereInput | OutboundCallWhereInput[]
    id?: StringFilter<"OutboundCall"> | string
    businessId?: StringFilter<"OutboundCall"> | string
    recipientNumber?: StringFilter<"OutboundCall"> | string
    recipientName?: StringNullableFilter<"OutboundCall"> | string | null
    campaignId?: StringNullableFilter<"OutboundCall"> | string | null
    status?: EnumOutboundCallStatusFilter<"OutboundCall"> | $Enums.OutboundCallStatus
    result?: EnumCallResultNullableFilter<"OutboundCall"> | $Enums.CallResult | null
    duration?: IntNullableFilter<"OutboundCall"> | number | null
    attempts?: IntFilter<"OutboundCall"> | number
    maxAttempts?: IntFilter<"OutboundCall"> | number
    scriptUsed?: StringNullableFilter<"OutboundCall"> | string | null
    transcript?: StringNullableFilter<"OutboundCall"> | string | null
    notes?: StringNullableFilter<"OutboundCall"> | string | null
    scheduledAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    externalCallId?: StringNullableFilter<"OutboundCall"> | string | null
    recordingUrl?: StringNullableFilter<"OutboundCall"> | string | null
    isCallback?: BoolFilter<"OutboundCall"> | boolean
    callbackReason?: StringNullableFilter<"OutboundCall"> | string | null
    createdAt?: DateTimeFilter<"OutboundCall"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundCall"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    campaign?: XOR<OutboundCampaignNullableRelationFilter, OutboundCampaignWhereInput> | null
  }

  export type OutboundCallOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    recipientNumber?: SortOrder
    recipientName?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scriptUsed?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    externalCallId?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    isCallback?: SortOrder
    callbackReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    campaign?: OutboundCampaignOrderByWithRelationInput
  }

  export type OutboundCallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutboundCallWhereInput | OutboundCallWhereInput[]
    OR?: OutboundCallWhereInput[]
    NOT?: OutboundCallWhereInput | OutboundCallWhereInput[]
    businessId?: StringFilter<"OutboundCall"> | string
    recipientNumber?: StringFilter<"OutboundCall"> | string
    recipientName?: StringNullableFilter<"OutboundCall"> | string | null
    campaignId?: StringNullableFilter<"OutboundCall"> | string | null
    status?: EnumOutboundCallStatusFilter<"OutboundCall"> | $Enums.OutboundCallStatus
    result?: EnumCallResultNullableFilter<"OutboundCall"> | $Enums.CallResult | null
    duration?: IntNullableFilter<"OutboundCall"> | number | null
    attempts?: IntFilter<"OutboundCall"> | number
    maxAttempts?: IntFilter<"OutboundCall"> | number
    scriptUsed?: StringNullableFilter<"OutboundCall"> | string | null
    transcript?: StringNullableFilter<"OutboundCall"> | string | null
    notes?: StringNullableFilter<"OutboundCall"> | string | null
    scheduledAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    externalCallId?: StringNullableFilter<"OutboundCall"> | string | null
    recordingUrl?: StringNullableFilter<"OutboundCall"> | string | null
    isCallback?: BoolFilter<"OutboundCall"> | boolean
    callbackReason?: StringNullableFilter<"OutboundCall"> | string | null
    createdAt?: DateTimeFilter<"OutboundCall"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundCall"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    campaign?: XOR<OutboundCampaignNullableRelationFilter, OutboundCampaignWhereInput> | null
  }, "id">

  export type OutboundCallOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    recipientNumber?: SortOrder
    recipientName?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scriptUsed?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    externalCallId?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    isCallback?: SortOrder
    callbackReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutboundCallCountOrderByAggregateInput
    _avg?: OutboundCallAvgOrderByAggregateInput
    _max?: OutboundCallMaxOrderByAggregateInput
    _min?: OutboundCallMinOrderByAggregateInput
    _sum?: OutboundCallSumOrderByAggregateInput
  }

  export type OutboundCallScalarWhereWithAggregatesInput = {
    AND?: OutboundCallScalarWhereWithAggregatesInput | OutboundCallScalarWhereWithAggregatesInput[]
    OR?: OutboundCallScalarWhereWithAggregatesInput[]
    NOT?: OutboundCallScalarWhereWithAggregatesInput | OutboundCallScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutboundCall"> | string
    businessId?: StringWithAggregatesFilter<"OutboundCall"> | string
    recipientNumber?: StringWithAggregatesFilter<"OutboundCall"> | string
    recipientName?: StringNullableWithAggregatesFilter<"OutboundCall"> | string | null
    campaignId?: StringNullableWithAggregatesFilter<"OutboundCall"> | string | null
    status?: EnumOutboundCallStatusWithAggregatesFilter<"OutboundCall"> | $Enums.OutboundCallStatus
    result?: EnumCallResultNullableWithAggregatesFilter<"OutboundCall"> | $Enums.CallResult | null
    duration?: IntNullableWithAggregatesFilter<"OutboundCall"> | number | null
    attempts?: IntWithAggregatesFilter<"OutboundCall"> | number
    maxAttempts?: IntWithAggregatesFilter<"OutboundCall"> | number
    scriptUsed?: StringNullableWithAggregatesFilter<"OutboundCall"> | string | null
    transcript?: StringNullableWithAggregatesFilter<"OutboundCall"> | string | null
    notes?: StringNullableWithAggregatesFilter<"OutboundCall"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"OutboundCall"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"OutboundCall"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"OutboundCall"> | Date | string | null
    externalCallId?: StringNullableWithAggregatesFilter<"OutboundCall"> | string | null
    recordingUrl?: StringNullableWithAggregatesFilter<"OutboundCall"> | string | null
    isCallback?: BoolWithAggregatesFilter<"OutboundCall"> | boolean
    callbackReason?: StringNullableWithAggregatesFilter<"OutboundCall"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OutboundCall"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutboundCall"> | Date | string
  }

  export type CallRoutingRuleWhereInput = {
    AND?: CallRoutingRuleWhereInput | CallRoutingRuleWhereInput[]
    OR?: CallRoutingRuleWhereInput[]
    NOT?: CallRoutingRuleWhereInput | CallRoutingRuleWhereInput[]
    id?: StringFilter<"CallRoutingRule"> | string
    businessId?: StringFilter<"CallRoutingRule"> | string
    name?: StringFilter<"CallRoutingRule"> | string
    priority?: IntFilter<"CallRoutingRule"> | number
    isActive?: BoolFilter<"CallRoutingRule"> | boolean
    conditionType?: EnumConditionTypeFilter<"CallRoutingRule"> | $Enums.ConditionType
    conditionValue?: JsonFilter<"CallRoutingRule">
    actionType?: EnumActionTypeFilter<"CallRoutingRule"> | $Enums.ActionType
    actionConfig?: JsonFilter<"CallRoutingRule">
    createdAt?: DateTimeFilter<"CallRoutingRule"> | Date | string
    updatedAt?: DateTimeFilter<"CallRoutingRule"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type CallRoutingRuleOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    conditionType?: SortOrder
    conditionValue?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type CallRoutingRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallRoutingRuleWhereInput | CallRoutingRuleWhereInput[]
    OR?: CallRoutingRuleWhereInput[]
    NOT?: CallRoutingRuleWhereInput | CallRoutingRuleWhereInput[]
    businessId?: StringFilter<"CallRoutingRule"> | string
    name?: StringFilter<"CallRoutingRule"> | string
    priority?: IntFilter<"CallRoutingRule"> | number
    isActive?: BoolFilter<"CallRoutingRule"> | boolean
    conditionType?: EnumConditionTypeFilter<"CallRoutingRule"> | $Enums.ConditionType
    conditionValue?: JsonFilter<"CallRoutingRule">
    actionType?: EnumActionTypeFilter<"CallRoutingRule"> | $Enums.ActionType
    actionConfig?: JsonFilter<"CallRoutingRule">
    createdAt?: DateTimeFilter<"CallRoutingRule"> | Date | string
    updatedAt?: DateTimeFilter<"CallRoutingRule"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }, "id">

  export type CallRoutingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    conditionType?: SortOrder
    conditionValue?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CallRoutingRuleCountOrderByAggregateInput
    _avg?: CallRoutingRuleAvgOrderByAggregateInput
    _max?: CallRoutingRuleMaxOrderByAggregateInput
    _min?: CallRoutingRuleMinOrderByAggregateInput
    _sum?: CallRoutingRuleSumOrderByAggregateInput
  }

  export type CallRoutingRuleScalarWhereWithAggregatesInput = {
    AND?: CallRoutingRuleScalarWhereWithAggregatesInput | CallRoutingRuleScalarWhereWithAggregatesInput[]
    OR?: CallRoutingRuleScalarWhereWithAggregatesInput[]
    NOT?: CallRoutingRuleScalarWhereWithAggregatesInput | CallRoutingRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallRoutingRule"> | string
    businessId?: StringWithAggregatesFilter<"CallRoutingRule"> | string
    name?: StringWithAggregatesFilter<"CallRoutingRule"> | string
    priority?: IntWithAggregatesFilter<"CallRoutingRule"> | number
    isActive?: BoolWithAggregatesFilter<"CallRoutingRule"> | boolean
    conditionType?: EnumConditionTypeWithAggregatesFilter<"CallRoutingRule"> | $Enums.ConditionType
    conditionValue?: JsonWithAggregatesFilter<"CallRoutingRule">
    actionType?: EnumActionTypeWithAggregatesFilter<"CallRoutingRule"> | $Enums.ActionType
    actionConfig?: JsonWithAggregatesFilter<"CallRoutingRule">
    createdAt?: DateTimeWithAggregatesFilter<"CallRoutingRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CallRoutingRule"> | Date | string
  }

  export type OutboundCampaignWhereInput = {
    AND?: OutboundCampaignWhereInput | OutboundCampaignWhereInput[]
    OR?: OutboundCampaignWhereInput[]
    NOT?: OutboundCampaignWhereInput | OutboundCampaignWhereInput[]
    id?: StringFilter<"OutboundCampaign"> | string
    businessId?: StringFilter<"OutboundCampaign"> | string
    name?: StringFilter<"OutboundCampaign"> | string
    description?: StringNullableFilter<"OutboundCampaign"> | string | null
    scriptTemplate?: StringFilter<"OutboundCampaign"> | string
    voiceId?: StringNullableFilter<"OutboundCampaign"> | string | null
    contactList?: JsonFilter<"OutboundCampaign">
    totalContacts?: IntFilter<"OutboundCampaign"> | number
    scheduleConfig?: JsonNullableFilter<"OutboundCampaign">
    startDate?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    callsPerMinute?: IntFilter<"OutboundCampaign"> | number
    maxConcurrent?: IntFilter<"OutboundCampaign"> | number
    status?: EnumCampaignStatusFilter<"OutboundCampaign"> | $Enums.CampaignStatus
    completedCalls?: IntFilter<"OutboundCampaign"> | number
    answeredCalls?: IntFilter<"OutboundCampaign"> | number
    voicemailCalls?: IntFilter<"OutboundCampaign"> | number
    failedCalls?: IntFilter<"OutboundCampaign"> | number
    createdAt?: DateTimeFilter<"OutboundCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundCampaign"> | Date | string
    startedAt?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    calls?: OutboundCallListRelationFilter
  }

  export type OutboundCampaignOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scriptTemplate?: SortOrder
    voiceId?: SortOrderInput | SortOrder
    contactList?: SortOrder
    totalContacts?: SortOrder
    scheduleConfig?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    callsPerMinute?: SortOrder
    maxConcurrent?: SortOrder
    status?: SortOrder
    completedCalls?: SortOrder
    answeredCalls?: SortOrder
    voicemailCalls?: SortOrder
    failedCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
    calls?: OutboundCallOrderByRelationAggregateInput
  }

  export type OutboundCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutboundCampaignWhereInput | OutboundCampaignWhereInput[]
    OR?: OutboundCampaignWhereInput[]
    NOT?: OutboundCampaignWhereInput | OutboundCampaignWhereInput[]
    businessId?: StringFilter<"OutboundCampaign"> | string
    name?: StringFilter<"OutboundCampaign"> | string
    description?: StringNullableFilter<"OutboundCampaign"> | string | null
    scriptTemplate?: StringFilter<"OutboundCampaign"> | string
    voiceId?: StringNullableFilter<"OutboundCampaign"> | string | null
    contactList?: JsonFilter<"OutboundCampaign">
    totalContacts?: IntFilter<"OutboundCampaign"> | number
    scheduleConfig?: JsonNullableFilter<"OutboundCampaign">
    startDate?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    callsPerMinute?: IntFilter<"OutboundCampaign"> | number
    maxConcurrent?: IntFilter<"OutboundCampaign"> | number
    status?: EnumCampaignStatusFilter<"OutboundCampaign"> | $Enums.CampaignStatus
    completedCalls?: IntFilter<"OutboundCampaign"> | number
    answeredCalls?: IntFilter<"OutboundCampaign"> | number
    voicemailCalls?: IntFilter<"OutboundCampaign"> | number
    failedCalls?: IntFilter<"OutboundCampaign"> | number
    createdAt?: DateTimeFilter<"OutboundCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundCampaign"> | Date | string
    startedAt?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    calls?: OutboundCallListRelationFilter
  }, "id">

  export type OutboundCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scriptTemplate?: SortOrder
    voiceId?: SortOrderInput | SortOrder
    contactList?: SortOrder
    totalContacts?: SortOrder
    scheduleConfig?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    callsPerMinute?: SortOrder
    maxConcurrent?: SortOrder
    status?: SortOrder
    completedCalls?: SortOrder
    answeredCalls?: SortOrder
    voicemailCalls?: SortOrder
    failedCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: OutboundCampaignCountOrderByAggregateInput
    _avg?: OutboundCampaignAvgOrderByAggregateInput
    _max?: OutboundCampaignMaxOrderByAggregateInput
    _min?: OutboundCampaignMinOrderByAggregateInput
    _sum?: OutboundCampaignSumOrderByAggregateInput
  }

  export type OutboundCampaignScalarWhereWithAggregatesInput = {
    AND?: OutboundCampaignScalarWhereWithAggregatesInput | OutboundCampaignScalarWhereWithAggregatesInput[]
    OR?: OutboundCampaignScalarWhereWithAggregatesInput[]
    NOT?: OutboundCampaignScalarWhereWithAggregatesInput | OutboundCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutboundCampaign"> | string
    businessId?: StringWithAggregatesFilter<"OutboundCampaign"> | string
    name?: StringWithAggregatesFilter<"OutboundCampaign"> | string
    description?: StringNullableWithAggregatesFilter<"OutboundCampaign"> | string | null
    scriptTemplate?: StringWithAggregatesFilter<"OutboundCampaign"> | string
    voiceId?: StringNullableWithAggregatesFilter<"OutboundCampaign"> | string | null
    contactList?: JsonWithAggregatesFilter<"OutboundCampaign">
    totalContacts?: IntWithAggregatesFilter<"OutboundCampaign"> | number
    scheduleConfig?: JsonNullableWithAggregatesFilter<"OutboundCampaign">
    startDate?: DateTimeNullableWithAggregatesFilter<"OutboundCampaign"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"OutboundCampaign"> | Date | string | null
    callsPerMinute?: IntWithAggregatesFilter<"OutboundCampaign"> | number
    maxConcurrent?: IntWithAggregatesFilter<"OutboundCampaign"> | number
    status?: EnumCampaignStatusWithAggregatesFilter<"OutboundCampaign"> | $Enums.CampaignStatus
    completedCalls?: IntWithAggregatesFilter<"OutboundCampaign"> | number
    answeredCalls?: IntWithAggregatesFilter<"OutboundCampaign"> | number
    voicemailCalls?: IntWithAggregatesFilter<"OutboundCampaign"> | number
    failedCalls?: IntWithAggregatesFilter<"OutboundCampaign"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OutboundCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutboundCampaign"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"OutboundCampaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"OutboundCampaign"> | Date | string | null
  }

  export type CallQueueWhereInput = {
    AND?: CallQueueWhereInput | CallQueueWhereInput[]
    OR?: CallQueueWhereInput[]
    NOT?: CallQueueWhereInput | CallQueueWhereInput[]
    id?: StringFilter<"CallQueue"> | string
    businessId?: StringFilter<"CallQueue"> | string
    callerNumber?: StringFilter<"CallQueue"> | string
    callerName?: StringNullableFilter<"CallQueue"> | string | null
    status?: EnumQueueStatusFilter<"CallQueue"> | $Enums.QueueStatus
    position?: IntFilter<"CallQueue"> | number
    priority?: IntFilter<"CallQueue"> | number
    estimatedWait?: IntNullableFilter<"CallQueue"> | number | null
    actualWait?: IntNullableFilter<"CallQueue"> | number | null
    externalCallId?: StringNullableFilter<"CallQueue"> | string | null
    enteredAt?: DateTimeFilter<"CallQueue"> | Date | string
    servedAt?: DateTimeNullableFilter<"CallQueue"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type CallQueueOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrderInput | SortOrder
    status?: SortOrder
    position?: SortOrder
    priority?: SortOrder
    estimatedWait?: SortOrderInput | SortOrder
    actualWait?: SortOrderInput | SortOrder
    externalCallId?: SortOrderInput | SortOrder
    enteredAt?: SortOrder
    servedAt?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type CallQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallQueueWhereInput | CallQueueWhereInput[]
    OR?: CallQueueWhereInput[]
    NOT?: CallQueueWhereInput | CallQueueWhereInput[]
    businessId?: StringFilter<"CallQueue"> | string
    callerNumber?: StringFilter<"CallQueue"> | string
    callerName?: StringNullableFilter<"CallQueue"> | string | null
    status?: EnumQueueStatusFilter<"CallQueue"> | $Enums.QueueStatus
    position?: IntFilter<"CallQueue"> | number
    priority?: IntFilter<"CallQueue"> | number
    estimatedWait?: IntNullableFilter<"CallQueue"> | number | null
    actualWait?: IntNullableFilter<"CallQueue"> | number | null
    externalCallId?: StringNullableFilter<"CallQueue"> | string | null
    enteredAt?: DateTimeFilter<"CallQueue"> | Date | string
    servedAt?: DateTimeNullableFilter<"CallQueue"> | Date | string | null
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }, "id">

  export type CallQueueOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrderInput | SortOrder
    status?: SortOrder
    position?: SortOrder
    priority?: SortOrder
    estimatedWait?: SortOrderInput | SortOrder
    actualWait?: SortOrderInput | SortOrder
    externalCallId?: SortOrderInput | SortOrder
    enteredAt?: SortOrder
    servedAt?: SortOrderInput | SortOrder
    _count?: CallQueueCountOrderByAggregateInput
    _avg?: CallQueueAvgOrderByAggregateInput
    _max?: CallQueueMaxOrderByAggregateInput
    _min?: CallQueueMinOrderByAggregateInput
    _sum?: CallQueueSumOrderByAggregateInput
  }

  export type CallQueueScalarWhereWithAggregatesInput = {
    AND?: CallQueueScalarWhereWithAggregatesInput | CallQueueScalarWhereWithAggregatesInput[]
    OR?: CallQueueScalarWhereWithAggregatesInput[]
    NOT?: CallQueueScalarWhereWithAggregatesInput | CallQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallQueue"> | string
    businessId?: StringWithAggregatesFilter<"CallQueue"> | string
    callerNumber?: StringWithAggregatesFilter<"CallQueue"> | string
    callerName?: StringNullableWithAggregatesFilter<"CallQueue"> | string | null
    status?: EnumQueueStatusWithAggregatesFilter<"CallQueue"> | $Enums.QueueStatus
    position?: IntWithAggregatesFilter<"CallQueue"> | number
    priority?: IntWithAggregatesFilter<"CallQueue"> | number
    estimatedWait?: IntNullableWithAggregatesFilter<"CallQueue"> | number | null
    actualWait?: IntNullableWithAggregatesFilter<"CallQueue"> | number | null
    externalCallId?: StringNullableWithAggregatesFilter<"CallQueue"> | string | null
    enteredAt?: DateTimeWithAggregatesFilter<"CallQueue"> | Date | string
    servedAt?: DateTimeNullableWithAggregatesFilter<"CallQueue"> | Date | string | null
  }

  export type CallbackRequestWhereInput = {
    AND?: CallbackRequestWhereInput | CallbackRequestWhereInput[]
    OR?: CallbackRequestWhereInput[]
    NOT?: CallbackRequestWhereInput | CallbackRequestWhereInput[]
    id?: StringFilter<"CallbackRequest"> | string
    businessId?: StringFilter<"CallbackRequest"> | string
    phoneNumber?: StringFilter<"CallbackRequest"> | string
    name?: StringNullableFilter<"CallbackRequest"> | string | null
    reason?: StringNullableFilter<"CallbackRequest"> | string | null
    preferredTime?: DateTimeNullableFilter<"CallbackRequest"> | Date | string | null
    status?: EnumCallbackStatusFilter<"CallbackRequest"> | $Enums.CallbackStatus
    outboundCallId?: StringNullableFilter<"CallbackRequest"> | string | null
    requestedAt?: DateTimeFilter<"CallbackRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"CallbackRequest"> | Date | string | null
  }

  export type CallbackRequestOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    preferredTime?: SortOrderInput | SortOrder
    status?: SortOrder
    outboundCallId?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
  }

  export type CallbackRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallbackRequestWhereInput | CallbackRequestWhereInput[]
    OR?: CallbackRequestWhereInput[]
    NOT?: CallbackRequestWhereInput | CallbackRequestWhereInput[]
    businessId?: StringFilter<"CallbackRequest"> | string
    phoneNumber?: StringFilter<"CallbackRequest"> | string
    name?: StringNullableFilter<"CallbackRequest"> | string | null
    reason?: StringNullableFilter<"CallbackRequest"> | string | null
    preferredTime?: DateTimeNullableFilter<"CallbackRequest"> | Date | string | null
    status?: EnumCallbackStatusFilter<"CallbackRequest"> | $Enums.CallbackStatus
    outboundCallId?: StringNullableFilter<"CallbackRequest"> | string | null
    requestedAt?: DateTimeFilter<"CallbackRequest"> | Date | string
    processedAt?: DateTimeNullableFilter<"CallbackRequest"> | Date | string | null
  }, "id">

  export type CallbackRequestOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    preferredTime?: SortOrderInput | SortOrder
    status?: SortOrder
    outboundCallId?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: CallbackRequestCountOrderByAggregateInput
    _max?: CallbackRequestMaxOrderByAggregateInput
    _min?: CallbackRequestMinOrderByAggregateInput
  }

  export type CallbackRequestScalarWhereWithAggregatesInput = {
    AND?: CallbackRequestScalarWhereWithAggregatesInput | CallbackRequestScalarWhereWithAggregatesInput[]
    OR?: CallbackRequestScalarWhereWithAggregatesInput[]
    NOT?: CallbackRequestScalarWhereWithAggregatesInput | CallbackRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallbackRequest"> | string
    businessId?: StringWithAggregatesFilter<"CallbackRequest"> | string
    phoneNumber?: StringWithAggregatesFilter<"CallbackRequest"> | string
    name?: StringNullableWithAggregatesFilter<"CallbackRequest"> | string | null
    reason?: StringNullableWithAggregatesFilter<"CallbackRequest"> | string | null
    preferredTime?: DateTimeNullableWithAggregatesFilter<"CallbackRequest"> | Date | string | null
    status?: EnumCallbackStatusWithAggregatesFilter<"CallbackRequest"> | $Enums.CallbackStatus
    outboundCallId?: StringNullableWithAggregatesFilter<"CallbackRequest"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"CallbackRequest"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"CallbackRequest"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelCreateNestedManyWithoutUserInput
    callSessions?: CallSessionCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelUncheckedCreateNestedManyWithoutUserInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUpdateManyWithoutUserNestedInput
    callSessions?: CallSessionUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUncheckedUpdateManyWithoutUserNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    callSummaries?: boolean
    weeklyReports?: boolean
    marketingEmails?: boolean
    companyName?: string | null
    industry?: string | null
    greeting?: string | null
    fallbackMessage?: string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    callSummaries?: boolean
    weeklyReports?: boolean
    marketingEmails?: boolean
    companyName?: string | null
    industry?: string | null
    greeting?: string | null
    fallbackMessage?: string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    callSummaries?: BoolFieldUpdateOperationsInput | boolean
    weeklyReports?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackMessage?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    callSummaries?: BoolFieldUpdateOperationsInput | boolean
    weeklyReports?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackMessage?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    callSummaries?: boolean
    weeklyReports?: boolean
    marketingEmails?: boolean
    companyName?: string | null
    industry?: string | null
    greeting?: string | null
    fallbackMessage?: string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    callSummaries?: BoolFieldUpdateOperationsInput | boolean
    weeklyReports?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackMessage?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    callSummaries?: BoolFieldUpdateOperationsInput | boolean
    weeklyReports?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackMessage?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    key: string
    name: string
    type?: $Enums.ApiKeyType
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    userId: string
    key: string
    name: string
    type?: $Enums.ApiKeyType
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumApiKeyTypeFieldUpdateOperationsInput | $Enums.ApiKeyType
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumApiKeyTypeFieldUpdateOperationsInput | $Enums.ApiKeyType
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    userId: string
    key: string
    name: string
    type?: $Enums.ApiKeyType
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumApiKeyTypeFieldUpdateOperationsInput | $Enums.ApiKeyType
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumApiKeyTypeFieldUpdateOperationsInput | $Enums.ApiKeyType
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceModelCreateInput = {
    id?: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVoiceModelsInput
    samples?: TrainingSampleCreateNestedManyWithoutVoiceModelInput
    callSessions?: CallSessionCreateNestedManyWithoutVoiceModelInput
  }

  export type VoiceModelUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: TrainingSampleUncheckedCreateNestedManyWithoutVoiceModelInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutVoiceModelInput
  }

  export type VoiceModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVoiceModelsNestedInput
    samples?: TrainingSampleUpdateManyWithoutVoiceModelNestedInput
    callSessions?: CallSessionUpdateManyWithoutVoiceModelNestedInput
  }

  export type VoiceModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: TrainingSampleUncheckedUpdateManyWithoutVoiceModelNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutVoiceModelNestedInput
  }

  export type VoiceModelCreateManyInput = {
    id?: string
    userId: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoiceModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSampleCreateInput = {
    id?: string
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrainingSamplesInput
    voiceModel?: VoiceModelCreateNestedOneWithoutSamplesInput
  }

  export type TrainingSampleUncheckedCreateInput = {
    id?: string
    userId: string
    voiceModelId?: string | null
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
  }

  export type TrainingSampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrainingSamplesNestedInput
    voiceModel?: VoiceModelUpdateOneWithoutSamplesNestedInput
  }

  export type TrainingSampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSampleCreateManyInput = {
    id?: string
    userId: string
    voiceModelId?: string | null
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
  }

  export type TrainingSampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionCreateInput = {
    id?: string
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCallSessionsInput
    voiceModel?: VoiceModelCreateNestedOneWithoutCallSessionsInput
    transcript?: TranscriptMessageCreateNestedManyWithoutCallSessionInput
    summary?: CallSummaryCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionUncheckedCreateInput = {
    id?: string
    userId: string
    voiceModelId?: string | null
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: TranscriptMessageUncheckedCreateNestedManyWithoutCallSessionInput
    summary?: CallSummaryUncheckedCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCallSessionsNestedInput
    voiceModel?: VoiceModelUpdateOneWithoutCallSessionsNestedInput
    transcript?: TranscriptMessageUpdateManyWithoutCallSessionNestedInput
    summary?: CallSummaryUpdateOneWithoutCallSessionNestedInput
  }

  export type CallSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: TranscriptMessageUncheckedUpdateManyWithoutCallSessionNestedInput
    summary?: CallSummaryUncheckedUpdateOneWithoutCallSessionNestedInput
  }

  export type CallSessionCreateManyInput = {
    id?: string
    userId: string
    voiceModelId?: string | null
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptMessageCreateInput = {
    id?: string
    speaker: $Enums.Speaker
    text: string
    confidence?: number | null
    timestamp?: Date | string
    callSession: CallSessionCreateNestedOneWithoutTranscriptInput
  }

  export type TranscriptMessageUncheckedCreateInput = {
    id?: string
    callSessionId: string
    speaker: $Enums.Speaker
    text: string
    confidence?: number | null
    timestamp?: Date | string
  }

  export type TranscriptMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: EnumSpeakerFieldUpdateOperationsInput | $Enums.Speaker
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    callSession?: CallSessionUpdateOneRequiredWithoutTranscriptNestedInput
  }

  export type TranscriptMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callSessionId?: StringFieldUpdateOperationsInput | string
    speaker?: EnumSpeakerFieldUpdateOperationsInput | $Enums.Speaker
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptMessageCreateManyInput = {
    id?: string
    callSessionId: string
    speaker: $Enums.Speaker
    text: string
    confidence?: number | null
    timestamp?: Date | string
  }

  export type TranscriptMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: EnumSpeakerFieldUpdateOperationsInput | $Enums.Speaker
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    callSessionId?: StringFieldUpdateOperationsInput | string
    speaker?: EnumSpeakerFieldUpdateOperationsInput | $Enums.Speaker
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSummaryCreateInput = {
    id?: string
    summary: string
    actionItems?: CallSummaryCreateactionItemsInput | string[]
    keyPoints?: CallSummaryCreatekeyPointsInput | string[]
    createdAt?: Date | string
    callSession: CallSessionCreateNestedOneWithoutSummaryInput
  }

  export type CallSummaryUncheckedCreateInput = {
    id?: string
    callSessionId: string
    summary: string
    actionItems?: CallSummaryCreateactionItemsInput | string[]
    keyPoints?: CallSummaryCreatekeyPointsInput | string[]
    createdAt?: Date | string
  }

  export type CallSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    actionItems?: CallSummaryUpdateactionItemsInput | string[]
    keyPoints?: CallSummaryUpdatekeyPointsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSession?: CallSessionUpdateOneRequiredWithoutSummaryNestedInput
  }

  export type CallSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callSessionId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    actionItems?: CallSummaryUpdateactionItemsInput | string[]
    keyPoints?: CallSummaryUpdatekeyPointsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSummaryCreateManyInput = {
    id?: string
    callSessionId: string
    summary: string
    actionItems?: CallSummaryCreateactionItemsInput | string[]
    keyPoints?: CallSummaryCreatekeyPointsInput | string[]
    createdAt?: Date | string
  }

  export type CallSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    actionItems?: CallSummaryUpdateactionItemsInput | string[]
    keyPoints?: CallSummaryUpdatekeyPointsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    callSessionId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    actionItems?: CallSummaryUpdateactionItemsInput | string[]
    keyPoints?: CallSummaryUpdatekeyPointsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyAnalyticsCreateInput = {
    id?: string
    userId: string
    date: Date | string
    totalCalls?: number
    completedCalls?: number
    missedCalls?: number
    totalDuration?: number
    avgDuration?: number
    positiveSentiment?: number
    neutralSentiment?: number
    negativeSentiment?: number
    topTopics?: NullableJsonNullValueInput | InputJsonValue
    peakHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyAnalyticsUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    totalCalls?: number
    completedCalls?: number
    missedCalls?: number
    totalDuration?: number
    avgDuration?: number
    positiveSentiment?: number
    neutralSentiment?: number
    negativeSentiment?: number
    topTopics?: NullableJsonNullValueInput | InputJsonValue
    peakHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCalls?: IntFieldUpdateOperationsInput | number
    completedCalls?: IntFieldUpdateOperationsInput | number
    missedCalls?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    avgDuration?: FloatFieldUpdateOperationsInput | number
    positiveSentiment?: IntFieldUpdateOperationsInput | number
    neutralSentiment?: IntFieldUpdateOperationsInput | number
    negativeSentiment?: IntFieldUpdateOperationsInput | number
    topTopics?: NullableJsonNullValueInput | InputJsonValue
    peakHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCalls?: IntFieldUpdateOperationsInput | number
    completedCalls?: IntFieldUpdateOperationsInput | number
    missedCalls?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    avgDuration?: FloatFieldUpdateOperationsInput | number
    positiveSentiment?: IntFieldUpdateOperationsInput | number
    neutralSentiment?: IntFieldUpdateOperationsInput | number
    negativeSentiment?: IntFieldUpdateOperationsInput | number
    topTopics?: NullableJsonNullValueInput | InputJsonValue
    peakHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyAnalyticsCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    totalCalls?: number
    completedCalls?: number
    missedCalls?: number
    totalDuration?: number
    avgDuration?: number
    positiveSentiment?: number
    neutralSentiment?: number
    negativeSentiment?: number
    topTopics?: NullableJsonNullValueInput | InputJsonValue
    peakHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCalls?: IntFieldUpdateOperationsInput | number
    completedCalls?: IntFieldUpdateOperationsInput | number
    missedCalls?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    avgDuration?: FloatFieldUpdateOperationsInput | number
    positiveSentiment?: IntFieldUpdateOperationsInput | number
    neutralSentiment?: IntFieldUpdateOperationsInput | number
    negativeSentiment?: IntFieldUpdateOperationsInput | number
    topTopics?: NullableJsonNullValueInput | InputJsonValue
    peakHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCalls?: IntFieldUpdateOperationsInput | number
    completedCalls?: IntFieldUpdateOperationsInput | number
    missedCalls?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    avgDuration?: FloatFieldUpdateOperationsInput | number
    positiveSentiment?: IntFieldUpdateOperationsInput | number
    neutralSentiment?: IntFieldUpdateOperationsInput | number
    negativeSentiment?: IntFieldUpdateOperationsInput | number
    topTopics?: NullableJsonNullValueInput | InputJsonValue
    peakHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCreateInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallCreateNestedManyWithoutBusinessInput
    outboundCalls?: OutboundCallCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallUncheckedCreateNestedManyWithoutBusinessInput
    outboundCalls?: OutboundCallUncheckedCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleUncheckedCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignUncheckedCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUpdateManyWithoutBusinessNestedInput
    outboundCalls?: OutboundCallUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    outboundCalls?: OutboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUncheckedUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUncheckedUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InboundCallCreateInput = {
    id?: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.InboundCallStatus
    duration?: number | null
    waitTime?: number | null
    routedTo?: string | null
    routingRuleId?: string | null
    transcript?: string | null
    summary?: string | null
    sentiment?: $Enums.Sentiment | null
    tags?: InboundCallCreatetagsInput | string[]
    externalCallId?: string | null
    recordingUrl?: string | null
    startedAt?: Date | string
    answeredAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutInboundCallsInput
  }

  export type InboundCallUncheckedCreateInput = {
    id?: string
    businessId: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.InboundCallStatus
    duration?: number | null
    waitTime?: number | null
    routedTo?: string | null
    routingRuleId?: string | null
    transcript?: string | null
    summary?: string | null
    sentiment?: $Enums.Sentiment | null
    tags?: InboundCallCreatetagsInput | string[]
    externalCallId?: string | null
    recordingUrl?: string | null
    startedAt?: Date | string
    answeredAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InboundCallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInboundCallStatusFieldUpdateOperationsInput | $Enums.InboundCallStatus
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    routedTo?: NullableStringFieldUpdateOperationsInput | string | null
    routingRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    tags?: InboundCallUpdatetagsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutInboundCallsNestedInput
  }

  export type InboundCallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInboundCallStatusFieldUpdateOperationsInput | $Enums.InboundCallStatus
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    routedTo?: NullableStringFieldUpdateOperationsInput | string | null
    routingRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    tags?: InboundCallUpdatetagsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InboundCallCreateManyInput = {
    id?: string
    businessId: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.InboundCallStatus
    duration?: number | null
    waitTime?: number | null
    routedTo?: string | null
    routingRuleId?: string | null
    transcript?: string | null
    summary?: string | null
    sentiment?: $Enums.Sentiment | null
    tags?: InboundCallCreatetagsInput | string[]
    externalCallId?: string | null
    recordingUrl?: string | null
    startedAt?: Date | string
    answeredAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InboundCallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInboundCallStatusFieldUpdateOperationsInput | $Enums.InboundCallStatus
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    routedTo?: NullableStringFieldUpdateOperationsInput | string | null
    routingRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    tags?: InboundCallUpdatetagsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InboundCallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInboundCallStatusFieldUpdateOperationsInput | $Enums.InboundCallStatus
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    routedTo?: NullableStringFieldUpdateOperationsInput | string | null
    routingRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    tags?: InboundCallUpdatetagsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundCallCreateInput = {
    id?: string
    recipientNumber: string
    recipientName?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutOutboundCallsInput
    campaign?: OutboundCampaignCreateNestedOneWithoutCallsInput
  }

  export type OutboundCallUncheckedCreateInput = {
    id?: string
    businessId: string
    recipientNumber: string
    recipientName?: string | null
    campaignId?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundCallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutOutboundCallsNestedInput
    campaign?: OutboundCampaignUpdateOneWithoutCallsNestedInput
  }

  export type OutboundCallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundCallCreateManyInput = {
    id?: string
    businessId: string
    recipientNumber: string
    recipientName?: string | null
    campaignId?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundCallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundCallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRoutingRuleCreateInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    conditionType: $Enums.ConditionType
    conditionValue: JsonNullValueInput | InputJsonValue
    actionType: $Enums.ActionType
    actionConfig: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutRoutingRulesInput
  }

  export type CallRoutingRuleUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    priority?: number
    isActive?: boolean
    conditionType: $Enums.ConditionType
    conditionValue: JsonNullValueInput | InputJsonValue
    actionType: $Enums.ActionType
    actionConfig: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRoutingRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conditionType?: EnumConditionTypeFieldUpdateOperationsInput | $Enums.ConditionType
    conditionValue?: JsonNullValueInput | InputJsonValue
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    actionConfig?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutRoutingRulesNestedInput
  }

  export type CallRoutingRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conditionType?: EnumConditionTypeFieldUpdateOperationsInput | $Enums.ConditionType
    conditionValue?: JsonNullValueInput | InputJsonValue
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    actionConfig?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRoutingRuleCreateManyInput = {
    id?: string
    businessId: string
    name: string
    priority?: number
    isActive?: boolean
    conditionType: $Enums.ConditionType
    conditionValue: JsonNullValueInput | InputJsonValue
    actionType: $Enums.ActionType
    actionConfig: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRoutingRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conditionType?: EnumConditionTypeFieldUpdateOperationsInput | $Enums.ConditionType
    conditionValue?: JsonNullValueInput | InputJsonValue
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    actionConfig?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRoutingRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conditionType?: EnumConditionTypeFieldUpdateOperationsInput | $Enums.ConditionType
    conditionValue?: JsonNullValueInput | InputJsonValue
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    actionConfig?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundCampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    scriptTemplate: string
    voiceId?: string | null
    contactList: JsonNullValueInput | InputJsonValue
    totalContacts?: number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    callsPerMinute?: number
    maxConcurrent?: number
    status?: $Enums.CampaignStatus
    completedCalls?: number
    answeredCalls?: number
    voicemailCalls?: number
    failedCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutCampaignsInput
    calls?: OutboundCallCreateNestedManyWithoutCampaignInput
  }

  export type OutboundCampaignUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    scriptTemplate: string
    voiceId?: string | null
    contactList: JsonNullValueInput | InputJsonValue
    totalContacts?: number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    callsPerMinute?: number
    maxConcurrent?: number
    status?: $Enums.CampaignStatus
    completedCalls?: number
    answeredCalls?: number
    voicemailCalls?: number
    failedCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    calls?: OutboundCallUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type OutboundCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutCampaignsNestedInput
    calls?: OutboundCallUpdateManyWithoutCampaignNestedInput
  }

  export type OutboundCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calls?: OutboundCallUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type OutboundCampaignCreateManyInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    scriptTemplate: string
    voiceId?: string | null
    contactList: JsonNullValueInput | InputJsonValue
    totalContacts?: number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    callsPerMinute?: number
    maxConcurrent?: number
    status?: $Enums.CampaignStatus
    completedCalls?: number
    answeredCalls?: number
    voicemailCalls?: number
    failedCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type OutboundCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutboundCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallQueueCreateInput = {
    id?: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.QueueStatus
    position: number
    priority?: number
    estimatedWait?: number | null
    actualWait?: number | null
    externalCallId?: string | null
    enteredAt?: Date | string
    servedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutCallQueueInput
  }

  export type CallQueueUncheckedCreateInput = {
    id?: string
    businessId: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.QueueStatus
    position: number
    priority?: number
    estimatedWait?: number | null
    actualWait?: number | null
    externalCallId?: string | null
    enteredAt?: Date | string
    servedAt?: Date | string | null
  }

  export type CallQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    estimatedWait?: NullableIntFieldUpdateOperationsInput | number | null
    actualWait?: NullableIntFieldUpdateOperationsInput | number | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutCallQueueNestedInput
  }

  export type CallQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    estimatedWait?: NullableIntFieldUpdateOperationsInput | number | null
    actualWait?: NullableIntFieldUpdateOperationsInput | number | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallQueueCreateManyInput = {
    id?: string
    businessId: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.QueueStatus
    position: number
    priority?: number
    estimatedWait?: number | null
    actualWait?: number | null
    externalCallId?: string | null
    enteredAt?: Date | string
    servedAt?: Date | string | null
  }

  export type CallQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    estimatedWait?: NullableIntFieldUpdateOperationsInput | number | null
    actualWait?: NullableIntFieldUpdateOperationsInput | number | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    estimatedWait?: NullableIntFieldUpdateOperationsInput | number | null
    actualWait?: NullableIntFieldUpdateOperationsInput | number | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallbackRequestCreateInput = {
    id?: string
    businessId: string
    phoneNumber: string
    name?: string | null
    reason?: string | null
    preferredTime?: Date | string | null
    status?: $Enums.CallbackStatus
    outboundCallId?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CallbackRequestUncheckedCreateInput = {
    id?: string
    businessId: string
    phoneNumber: string
    name?: string | null
    reason?: string | null
    preferredTime?: Date | string | null
    status?: $Enums.CallbackStatus
    outboundCallId?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CallbackRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCallbackStatusFieldUpdateOperationsInput | $Enums.CallbackStatus
    outboundCallId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallbackRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCallbackStatusFieldUpdateOperationsInput | $Enums.CallbackStatus
    outboundCallId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallbackRequestCreateManyInput = {
    id?: string
    businessId: string
    phoneNumber: string
    name?: string | null
    reason?: string | null
    preferredTime?: Date | string | null
    status?: $Enums.CallbackStatus
    outboundCallId?: string | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CallbackRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCallbackStatusFieldUpdateOperationsInput | $Enums.CallbackStatus
    outboundCallId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallbackRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCallbackStatusFieldUpdateOperationsInput | $Enums.CallbackStatus
    outboundCallId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanFilter<$PrismaModel> | $Enums.Plan
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type VoiceModelListRelationFilter = {
    every?: VoiceModelWhereInput
    some?: VoiceModelWhereInput
    none?: VoiceModelWhereInput
  }

  export type CallSessionListRelationFilter = {
    every?: CallSessionWhereInput
    some?: CallSessionWhereInput
    none?: CallSessionWhereInput
  }

  export type TrainingSampleListRelationFilter = {
    every?: TrainingSampleWhereInput
    some?: TrainingSampleWhereInput
    none?: TrainingSampleWhereInput
  }

  export type UserSettingsNullableRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VoiceModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingSampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    company?: SortOrder
    phone?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanWithAggregatesFilter<$PrismaModel> | $Enums.Plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanFilter<$PrismaModel>
    _max?: NestedEnumPlanFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    callSummaries?: SortOrder
    weeklyReports?: SortOrder
    marketingEmails?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    greeting?: SortOrder
    fallbackMessage?: SortOrder
    businessHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    callSummaries?: SortOrder
    weeklyReports?: SortOrder
    marketingEmails?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    greeting?: SortOrder
    fallbackMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    callSummaries?: SortOrder
    weeklyReports?: SortOrder
    marketingEmails?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    greeting?: SortOrder
    fallbackMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumApiKeyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiKeyType | EnumApiKeyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiKeyType[] | ListEnumApiKeyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiKeyType[] | ListEnumApiKeyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiKeyTypeFilter<$PrismaModel> | $Enums.ApiKeyType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    type?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    type?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    type?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumApiKeyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiKeyType | EnumApiKeyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiKeyType[] | ListEnumApiKeyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiKeyType[] | ListEnumApiKeyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiKeyTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApiKeyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiKeyTypeFilter<$PrismaModel>
    _max?: NestedEnumApiKeyTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumVoiceModelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VoiceModelStatus | EnumVoiceModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoiceModelStatus[] | ListEnumVoiceModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoiceModelStatus[] | ListEnumVoiceModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoiceModelStatusFilter<$PrismaModel> | $Enums.VoiceModelStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type VoiceModelCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    friendliness?: SortOrder
    professionalism?: SortOrder
    energy?: SortOrder
    formality?: SortOrder
    externalVoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoiceModelAvgOrderByAggregateInput = {
    friendliness?: SortOrder
    professionalism?: SortOrder
    energy?: SortOrder
    formality?: SortOrder
  }

  export type VoiceModelMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    friendliness?: SortOrder
    professionalism?: SortOrder
    energy?: SortOrder
    formality?: SortOrder
    externalVoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoiceModelMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    friendliness?: SortOrder
    professionalism?: SortOrder
    energy?: SortOrder
    formality?: SortOrder
    externalVoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoiceModelSumOrderByAggregateInput = {
    friendliness?: SortOrder
    professionalism?: SortOrder
    energy?: SortOrder
    formality?: SortOrder
  }

  export type EnumVoiceModelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoiceModelStatus | EnumVoiceModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoiceModelStatus[] | ListEnumVoiceModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoiceModelStatus[] | ListEnumVoiceModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoiceModelStatusWithAggregatesFilter<$PrismaModel> | $Enums.VoiceModelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoiceModelStatusFilter<$PrismaModel>
    _max?: NestedEnumVoiceModelStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VoiceModelNullableRelationFilter = {
    is?: VoiceModelWhereInput | null
    isNot?: VoiceModelWhereInput | null
  }

  export type TrainingSampleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingSampleAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
  }

  export type TrainingSampleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingSampleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingSampleSumOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumCallDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionFilter<$PrismaModel> | $Enums.CallDirection
  }

  export type EnumCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallStatusFilter<$PrismaModel> | $Enums.CallStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSentimentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sentiment | EnumSentimentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentNullableFilter<$PrismaModel> | $Enums.Sentiment | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TranscriptMessageListRelationFilter = {
    every?: TranscriptMessageWhereInput
    some?: TranscriptMessageWhereInput
    none?: TranscriptMessageWhereInput
  }

  export type CallSummaryNullableRelationFilter = {
    is?: CallSummaryWhereInput | null
    isNot?: CallSummaryWhereInput | null
  }

  export type TranscriptMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrder
    phoneNumber?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    sentiment?: SortOrder
    topics?: SortOrder
    externalCallId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CallSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrder
    phoneNumber?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    sentiment?: SortOrder
    externalCallId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voiceModelId?: SortOrder
    phoneNumber?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    sentiment?: SortOrder
    externalCallId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallSessionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumCallDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel> | $Enums.CallDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallDirectionFilter<$PrismaModel>
    _max?: NestedEnumCallDirectionFilter<$PrismaModel>
  }

  export type EnumCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.CallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallStatusFilter<$PrismaModel>
    _max?: NestedEnumCallStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSentimentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sentiment | EnumSentimentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sentiment | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSentimentNullableFilter<$PrismaModel>
    _max?: NestedEnumSentimentNullableFilter<$PrismaModel>
  }

  export type EnumSpeakerFilter<$PrismaModel = never> = {
    equals?: $Enums.Speaker | EnumSpeakerFieldRefInput<$PrismaModel>
    in?: $Enums.Speaker[] | ListEnumSpeakerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Speaker[] | ListEnumSpeakerFieldRefInput<$PrismaModel>
    not?: NestedEnumSpeakerFilter<$PrismaModel> | $Enums.Speaker
  }

  export type CallSessionRelationFilter = {
    is?: CallSessionWhereInput
    isNot?: CallSessionWhereInput
  }

  export type TranscriptMessageCountOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    speaker?: SortOrder
    text?: SortOrder
    confidence?: SortOrder
    timestamp?: SortOrder
  }

  export type TranscriptMessageAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type TranscriptMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    speaker?: SortOrder
    text?: SortOrder
    confidence?: SortOrder
    timestamp?: SortOrder
  }

  export type TranscriptMessageMinOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    speaker?: SortOrder
    text?: SortOrder
    confidence?: SortOrder
    timestamp?: SortOrder
  }

  export type TranscriptMessageSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumSpeakerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Speaker | EnumSpeakerFieldRefInput<$PrismaModel>
    in?: $Enums.Speaker[] | ListEnumSpeakerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Speaker[] | ListEnumSpeakerFieldRefInput<$PrismaModel>
    not?: NestedEnumSpeakerWithAggregatesFilter<$PrismaModel> | $Enums.Speaker
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpeakerFilter<$PrismaModel>
    _max?: NestedEnumSpeakerFilter<$PrismaModel>
  }

  export type CallSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    summary?: SortOrder
    actionItems?: SortOrder
    keyPoints?: SortOrder
    createdAt?: SortOrder
  }

  export type CallSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type CallSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DailyAnalyticsUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type DailyAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    totalCalls?: SortOrder
    completedCalls?: SortOrder
    missedCalls?: SortOrder
    totalDuration?: SortOrder
    avgDuration?: SortOrder
    positiveSentiment?: SortOrder
    neutralSentiment?: SortOrder
    negativeSentiment?: SortOrder
    topTopics?: SortOrder
    peakHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyAnalyticsAvgOrderByAggregateInput = {
    totalCalls?: SortOrder
    completedCalls?: SortOrder
    missedCalls?: SortOrder
    totalDuration?: SortOrder
    avgDuration?: SortOrder
    positiveSentiment?: SortOrder
    neutralSentiment?: SortOrder
    negativeSentiment?: SortOrder
  }

  export type DailyAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    totalCalls?: SortOrder
    completedCalls?: SortOrder
    missedCalls?: SortOrder
    totalDuration?: SortOrder
    avgDuration?: SortOrder
    positiveSentiment?: SortOrder
    neutralSentiment?: SortOrder
    negativeSentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    totalCalls?: SortOrder
    completedCalls?: SortOrder
    missedCalls?: SortOrder
    totalDuration?: SortOrder
    avgDuration?: SortOrder
    positiveSentiment?: SortOrder
    neutralSentiment?: SortOrder
    negativeSentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyAnalyticsSumOrderByAggregateInput = {
    totalCalls?: SortOrder
    completedCalls?: SortOrder
    missedCalls?: SortOrder
    totalDuration?: SortOrder
    avgDuration?: SortOrder
    positiveSentiment?: SortOrder
    neutralSentiment?: SortOrder
    negativeSentiment?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type InboundCallListRelationFilter = {
    every?: InboundCallWhereInput
    some?: InboundCallWhereInput
    none?: InboundCallWhereInput
  }

  export type OutboundCallListRelationFilter = {
    every?: OutboundCallWhereInput
    some?: OutboundCallWhereInput
    none?: OutboundCallWhereInput
  }

  export type CallRoutingRuleListRelationFilter = {
    every?: CallRoutingRuleWhereInput
    some?: CallRoutingRuleWhereInput
    none?: CallRoutingRuleWhereInput
  }

  export type OutboundCampaignListRelationFilter = {
    every?: OutboundCampaignWhereInput
    some?: OutboundCampaignWhereInput
    none?: OutboundCampaignWhereInput
  }

  export type CallQueueListRelationFilter = {
    every?: CallQueueWhereInput
    some?: CallQueueWhereInput
    none?: CallQueueWhereInput
  }

  export type InboundCallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutboundCallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallRoutingRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutboundCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    timezone?: SortOrder
    inboundConfig?: SortOrder
    outboundConfig?: SortOrder
    defaultVoiceId?: SortOrder
    greeting?: SortOrder
    voicemailPrompt?: SortOrder
    holdMusicUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    timezone?: SortOrder
    defaultVoiceId?: SortOrder
    greeting?: SortOrder
    voicemailPrompt?: SortOrder
    holdMusicUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    timezone?: SortOrder
    defaultVoiceId?: SortOrder
    greeting?: SortOrder
    voicemailPrompt?: SortOrder
    holdMusicUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInboundCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InboundCallStatus | EnumInboundCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InboundCallStatus[] | ListEnumInboundCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InboundCallStatus[] | ListEnumInboundCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInboundCallStatusFilter<$PrismaModel> | $Enums.InboundCallStatus
  }

  export type BusinessRelationFilter = {
    is?: BusinessWhereInput
    isNot?: BusinessWhereInput
  }

  export type InboundCallCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    waitTime?: SortOrder
    routedTo?: SortOrder
    routingRuleId?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    tags?: SortOrder
    externalCallId?: SortOrder
    recordingUrl?: SortOrder
    startedAt?: SortOrder
    answeredAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InboundCallAvgOrderByAggregateInput = {
    duration?: SortOrder
    waitTime?: SortOrder
  }

  export type InboundCallMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    waitTime?: SortOrder
    routedTo?: SortOrder
    routingRuleId?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    externalCallId?: SortOrder
    recordingUrl?: SortOrder
    startedAt?: SortOrder
    answeredAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InboundCallMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    waitTime?: SortOrder
    routedTo?: SortOrder
    routingRuleId?: SortOrder
    transcript?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    externalCallId?: SortOrder
    recordingUrl?: SortOrder
    startedAt?: SortOrder
    answeredAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InboundCallSumOrderByAggregateInput = {
    duration?: SortOrder
    waitTime?: SortOrder
  }

  export type EnumInboundCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InboundCallStatus | EnumInboundCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InboundCallStatus[] | ListEnumInboundCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InboundCallStatus[] | ListEnumInboundCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInboundCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.InboundCallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInboundCallStatusFilter<$PrismaModel>
    _max?: NestedEnumInboundCallStatusFilter<$PrismaModel>
  }

  export type EnumOutboundCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboundCallStatus | EnumOutboundCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboundCallStatus[] | ListEnumOutboundCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboundCallStatus[] | ListEnumOutboundCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboundCallStatusFilter<$PrismaModel> | $Enums.OutboundCallStatus
  }

  export type EnumCallResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CallResult | EnumCallResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallResult[] | ListEnumCallResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallResult[] | ListEnumCallResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallResultNullableFilter<$PrismaModel> | $Enums.CallResult | null
  }

  export type OutboundCampaignNullableRelationFilter = {
    is?: OutboundCampaignWhereInput | null
    isNot?: OutboundCampaignWhereInput | null
  }

  export type OutboundCallCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    recipientNumber?: SortOrder
    recipientName?: SortOrder
    campaignId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scriptUsed?: SortOrder
    transcript?: SortOrder
    notes?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    externalCallId?: SortOrder
    recordingUrl?: SortOrder
    isCallback?: SortOrder
    callbackReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboundCallAvgOrderByAggregateInput = {
    duration?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type OutboundCallMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    recipientNumber?: SortOrder
    recipientName?: SortOrder
    campaignId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scriptUsed?: SortOrder
    transcript?: SortOrder
    notes?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    externalCallId?: SortOrder
    recordingUrl?: SortOrder
    isCallback?: SortOrder
    callbackReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboundCallMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    recipientNumber?: SortOrder
    recipientName?: SortOrder
    campaignId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scriptUsed?: SortOrder
    transcript?: SortOrder
    notes?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    externalCallId?: SortOrder
    recordingUrl?: SortOrder
    isCallback?: SortOrder
    callbackReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboundCallSumOrderByAggregateInput = {
    duration?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EnumOutboundCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboundCallStatus | EnumOutboundCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboundCallStatus[] | ListEnumOutboundCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboundCallStatus[] | ListEnumOutboundCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboundCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.OutboundCallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOutboundCallStatusFilter<$PrismaModel>
    _max?: NestedEnumOutboundCallStatusFilter<$PrismaModel>
  }

  export type EnumCallResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallResult | EnumCallResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallResult[] | ListEnumCallResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallResult[] | ListEnumCallResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.CallResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCallResultNullableFilter<$PrismaModel>
    _max?: NestedEnumCallResultNullableFilter<$PrismaModel>
  }

  export type EnumConditionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConditionType | EnumConditionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConditionType[] | ListEnumConditionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConditionType[] | ListEnumConditionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConditionTypeFilter<$PrismaModel> | $Enums.ConditionType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type CallRoutingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    conditionType?: SortOrder
    conditionValue?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallRoutingRuleAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type CallRoutingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    conditionType?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallRoutingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    conditionType?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallRoutingRuleSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumConditionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConditionType | EnumConditionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConditionType[] | ListEnumConditionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConditionType[] | ListEnumConditionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConditionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConditionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConditionTypeFilter<$PrismaModel>
    _max?: NestedEnumConditionTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type OutboundCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scriptTemplate?: SortOrder
    voiceId?: SortOrder
    contactList?: SortOrder
    totalContacts?: SortOrder
    scheduleConfig?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    callsPerMinute?: SortOrder
    maxConcurrent?: SortOrder
    status?: SortOrder
    completedCalls?: SortOrder
    answeredCalls?: SortOrder
    voicemailCalls?: SortOrder
    failedCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type OutboundCampaignAvgOrderByAggregateInput = {
    totalContacts?: SortOrder
    callsPerMinute?: SortOrder
    maxConcurrent?: SortOrder
    completedCalls?: SortOrder
    answeredCalls?: SortOrder
    voicemailCalls?: SortOrder
    failedCalls?: SortOrder
  }

  export type OutboundCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scriptTemplate?: SortOrder
    voiceId?: SortOrder
    totalContacts?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    callsPerMinute?: SortOrder
    maxConcurrent?: SortOrder
    status?: SortOrder
    completedCalls?: SortOrder
    answeredCalls?: SortOrder
    voicemailCalls?: SortOrder
    failedCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type OutboundCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scriptTemplate?: SortOrder
    voiceId?: SortOrder
    totalContacts?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    callsPerMinute?: SortOrder
    maxConcurrent?: SortOrder
    status?: SortOrder
    completedCalls?: SortOrder
    answeredCalls?: SortOrder
    voicemailCalls?: SortOrder
    failedCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type OutboundCampaignSumOrderByAggregateInput = {
    totalContacts?: SortOrder
    callsPerMinute?: SortOrder
    maxConcurrent?: SortOrder
    completedCalls?: SortOrder
    answeredCalls?: SortOrder
    voicemailCalls?: SortOrder
    failedCalls?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type EnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type CallQueueCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrder
    status?: SortOrder
    position?: SortOrder
    priority?: SortOrder
    estimatedWait?: SortOrder
    actualWait?: SortOrder
    externalCallId?: SortOrder
    enteredAt?: SortOrder
    servedAt?: SortOrder
  }

  export type CallQueueAvgOrderByAggregateInput = {
    position?: SortOrder
    priority?: SortOrder
    estimatedWait?: SortOrder
    actualWait?: SortOrder
  }

  export type CallQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrder
    status?: SortOrder
    position?: SortOrder
    priority?: SortOrder
    estimatedWait?: SortOrder
    actualWait?: SortOrder
    externalCallId?: SortOrder
    enteredAt?: SortOrder
    servedAt?: SortOrder
  }

  export type CallQueueMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    callerNumber?: SortOrder
    callerName?: SortOrder
    status?: SortOrder
    position?: SortOrder
    priority?: SortOrder
    estimatedWait?: SortOrder
    actualWait?: SortOrder
    externalCallId?: SortOrder
    enteredAt?: SortOrder
    servedAt?: SortOrder
  }

  export type CallQueueSumOrderByAggregateInput = {
    position?: SortOrder
    priority?: SortOrder
    estimatedWait?: SortOrder
    actualWait?: SortOrder
  }

  export type EnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type EnumCallbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CallbackStatus | EnumCallbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallbackStatus[] | ListEnumCallbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallbackStatus[] | ListEnumCallbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallbackStatusFilter<$PrismaModel> | $Enums.CallbackStatus
  }

  export type CallbackRequestCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    preferredTime?: SortOrder
    status?: SortOrder
    outboundCallId?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type CallbackRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    preferredTime?: SortOrder
    status?: SortOrder
    outboundCallId?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type CallbackRequestMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    preferredTime?: SortOrder
    status?: SortOrder
    outboundCallId?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type EnumCallbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallbackStatus | EnumCallbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallbackStatus[] | ListEnumCallbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallbackStatus[] | ListEnumCallbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.CallbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallbackStatusFilter<$PrismaModel>
    _max?: NestedEnumCallbackStatusFilter<$PrismaModel>
  }

  export type VoiceModelCreateNestedManyWithoutUserInput = {
    create?: XOR<VoiceModelCreateWithoutUserInput, VoiceModelUncheckedCreateWithoutUserInput> | VoiceModelCreateWithoutUserInput[] | VoiceModelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoiceModelCreateOrConnectWithoutUserInput | VoiceModelCreateOrConnectWithoutUserInput[]
    createMany?: VoiceModelCreateManyUserInputEnvelope
    connect?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
  }

  export type CallSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<CallSessionCreateWithoutUserInput, CallSessionUncheckedCreateWithoutUserInput> | CallSessionCreateWithoutUserInput[] | CallSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CallSessionCreateOrConnectWithoutUserInput | CallSessionCreateOrConnectWithoutUserInput[]
    createMany?: CallSessionCreateManyUserInputEnvelope
    connect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
  }

  export type TrainingSampleCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingSampleCreateWithoutUserInput, TrainingSampleUncheckedCreateWithoutUserInput> | TrainingSampleCreateWithoutUserInput[] | TrainingSampleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingSampleCreateOrConnectWithoutUserInput | TrainingSampleCreateOrConnectWithoutUserInput[]
    createMany?: TrainingSampleCreateManyUserInputEnvelope
    connect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type VoiceModelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoiceModelCreateWithoutUserInput, VoiceModelUncheckedCreateWithoutUserInput> | VoiceModelCreateWithoutUserInput[] | VoiceModelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoiceModelCreateOrConnectWithoutUserInput | VoiceModelCreateOrConnectWithoutUserInput[]
    createMany?: VoiceModelCreateManyUserInputEnvelope
    connect?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
  }

  export type CallSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CallSessionCreateWithoutUserInput, CallSessionUncheckedCreateWithoutUserInput> | CallSessionCreateWithoutUserInput[] | CallSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CallSessionCreateOrConnectWithoutUserInput | CallSessionCreateOrConnectWithoutUserInput[]
    createMany?: CallSessionCreateManyUserInputEnvelope
    connect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
  }

  export type TrainingSampleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingSampleCreateWithoutUserInput, TrainingSampleUncheckedCreateWithoutUserInput> | TrainingSampleCreateWithoutUserInput[] | TrainingSampleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingSampleCreateOrConnectWithoutUserInput | TrainingSampleCreateOrConnectWithoutUserInput[]
    createMany?: TrainingSampleCreateManyUserInputEnvelope
    connect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumPlanFieldUpdateOperationsInput = {
    set?: $Enums.Plan
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type VoiceModelUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoiceModelCreateWithoutUserInput, VoiceModelUncheckedCreateWithoutUserInput> | VoiceModelCreateWithoutUserInput[] | VoiceModelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoiceModelCreateOrConnectWithoutUserInput | VoiceModelCreateOrConnectWithoutUserInput[]
    upsert?: VoiceModelUpsertWithWhereUniqueWithoutUserInput | VoiceModelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoiceModelCreateManyUserInputEnvelope
    set?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
    disconnect?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
    delete?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
    connect?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
    update?: VoiceModelUpdateWithWhereUniqueWithoutUserInput | VoiceModelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoiceModelUpdateManyWithWhereWithoutUserInput | VoiceModelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoiceModelScalarWhereInput | VoiceModelScalarWhereInput[]
  }

  export type CallSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CallSessionCreateWithoutUserInput, CallSessionUncheckedCreateWithoutUserInput> | CallSessionCreateWithoutUserInput[] | CallSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CallSessionCreateOrConnectWithoutUserInput | CallSessionCreateOrConnectWithoutUserInput[]
    upsert?: CallSessionUpsertWithWhereUniqueWithoutUserInput | CallSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CallSessionCreateManyUserInputEnvelope
    set?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    disconnect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    delete?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    connect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    update?: CallSessionUpdateWithWhereUniqueWithoutUserInput | CallSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CallSessionUpdateManyWithWhereWithoutUserInput | CallSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CallSessionScalarWhereInput | CallSessionScalarWhereInput[]
  }

  export type TrainingSampleUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingSampleCreateWithoutUserInput, TrainingSampleUncheckedCreateWithoutUserInput> | TrainingSampleCreateWithoutUserInput[] | TrainingSampleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingSampleCreateOrConnectWithoutUserInput | TrainingSampleCreateOrConnectWithoutUserInput[]
    upsert?: TrainingSampleUpsertWithWhereUniqueWithoutUserInput | TrainingSampleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingSampleCreateManyUserInputEnvelope
    set?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    disconnect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    delete?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    connect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    update?: TrainingSampleUpdateWithWhereUniqueWithoutUserInput | TrainingSampleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingSampleUpdateManyWithWhereWithoutUserInput | TrainingSampleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingSampleScalarWhereInput | TrainingSampleScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type VoiceModelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoiceModelCreateWithoutUserInput, VoiceModelUncheckedCreateWithoutUserInput> | VoiceModelCreateWithoutUserInput[] | VoiceModelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoiceModelCreateOrConnectWithoutUserInput | VoiceModelCreateOrConnectWithoutUserInput[]
    upsert?: VoiceModelUpsertWithWhereUniqueWithoutUserInput | VoiceModelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoiceModelCreateManyUserInputEnvelope
    set?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
    disconnect?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
    delete?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
    connect?: VoiceModelWhereUniqueInput | VoiceModelWhereUniqueInput[]
    update?: VoiceModelUpdateWithWhereUniqueWithoutUserInput | VoiceModelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoiceModelUpdateManyWithWhereWithoutUserInput | VoiceModelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoiceModelScalarWhereInput | VoiceModelScalarWhereInput[]
  }

  export type CallSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CallSessionCreateWithoutUserInput, CallSessionUncheckedCreateWithoutUserInput> | CallSessionCreateWithoutUserInput[] | CallSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CallSessionCreateOrConnectWithoutUserInput | CallSessionCreateOrConnectWithoutUserInput[]
    upsert?: CallSessionUpsertWithWhereUniqueWithoutUserInput | CallSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CallSessionCreateManyUserInputEnvelope
    set?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    disconnect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    delete?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    connect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    update?: CallSessionUpdateWithWhereUniqueWithoutUserInput | CallSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CallSessionUpdateManyWithWhereWithoutUserInput | CallSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CallSessionScalarWhereInput | CallSessionScalarWhereInput[]
  }

  export type TrainingSampleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingSampleCreateWithoutUserInput, TrainingSampleUncheckedCreateWithoutUserInput> | TrainingSampleCreateWithoutUserInput[] | TrainingSampleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingSampleCreateOrConnectWithoutUserInput | TrainingSampleCreateOrConnectWithoutUserInput[]
    upsert?: TrainingSampleUpsertWithWhereUniqueWithoutUserInput | TrainingSampleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingSampleCreateManyUserInputEnvelope
    set?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    disconnect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    delete?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    connect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    update?: TrainingSampleUpdateWithWhereUniqueWithoutUserInput | TrainingSampleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingSampleUpdateManyWithWhereWithoutUserInput | TrainingSampleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingSampleScalarWhereInput | TrainingSampleScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApiKeyTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApiKeyType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserCreateNestedOneWithoutVoiceModelsInput = {
    create?: XOR<UserCreateWithoutVoiceModelsInput, UserUncheckedCreateWithoutVoiceModelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoiceModelsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingSampleCreateNestedManyWithoutVoiceModelInput = {
    create?: XOR<TrainingSampleCreateWithoutVoiceModelInput, TrainingSampleUncheckedCreateWithoutVoiceModelInput> | TrainingSampleCreateWithoutVoiceModelInput[] | TrainingSampleUncheckedCreateWithoutVoiceModelInput[]
    connectOrCreate?: TrainingSampleCreateOrConnectWithoutVoiceModelInput | TrainingSampleCreateOrConnectWithoutVoiceModelInput[]
    createMany?: TrainingSampleCreateManyVoiceModelInputEnvelope
    connect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
  }

  export type CallSessionCreateNestedManyWithoutVoiceModelInput = {
    create?: XOR<CallSessionCreateWithoutVoiceModelInput, CallSessionUncheckedCreateWithoutVoiceModelInput> | CallSessionCreateWithoutVoiceModelInput[] | CallSessionUncheckedCreateWithoutVoiceModelInput[]
    connectOrCreate?: CallSessionCreateOrConnectWithoutVoiceModelInput | CallSessionCreateOrConnectWithoutVoiceModelInput[]
    createMany?: CallSessionCreateManyVoiceModelInputEnvelope
    connect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
  }

  export type TrainingSampleUncheckedCreateNestedManyWithoutVoiceModelInput = {
    create?: XOR<TrainingSampleCreateWithoutVoiceModelInput, TrainingSampleUncheckedCreateWithoutVoiceModelInput> | TrainingSampleCreateWithoutVoiceModelInput[] | TrainingSampleUncheckedCreateWithoutVoiceModelInput[]
    connectOrCreate?: TrainingSampleCreateOrConnectWithoutVoiceModelInput | TrainingSampleCreateOrConnectWithoutVoiceModelInput[]
    createMany?: TrainingSampleCreateManyVoiceModelInputEnvelope
    connect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
  }

  export type CallSessionUncheckedCreateNestedManyWithoutVoiceModelInput = {
    create?: XOR<CallSessionCreateWithoutVoiceModelInput, CallSessionUncheckedCreateWithoutVoiceModelInput> | CallSessionCreateWithoutVoiceModelInput[] | CallSessionUncheckedCreateWithoutVoiceModelInput[]
    connectOrCreate?: CallSessionCreateOrConnectWithoutVoiceModelInput | CallSessionCreateOrConnectWithoutVoiceModelInput[]
    createMany?: CallSessionCreateManyVoiceModelInputEnvelope
    connect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
  }

  export type EnumVoiceModelStatusFieldUpdateOperationsInput = {
    set?: $Enums.VoiceModelStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutVoiceModelsNestedInput = {
    create?: XOR<UserCreateWithoutVoiceModelsInput, UserUncheckedCreateWithoutVoiceModelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoiceModelsInput
    upsert?: UserUpsertWithoutVoiceModelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoiceModelsInput, UserUpdateWithoutVoiceModelsInput>, UserUncheckedUpdateWithoutVoiceModelsInput>
  }

  export type TrainingSampleUpdateManyWithoutVoiceModelNestedInput = {
    create?: XOR<TrainingSampleCreateWithoutVoiceModelInput, TrainingSampleUncheckedCreateWithoutVoiceModelInput> | TrainingSampleCreateWithoutVoiceModelInput[] | TrainingSampleUncheckedCreateWithoutVoiceModelInput[]
    connectOrCreate?: TrainingSampleCreateOrConnectWithoutVoiceModelInput | TrainingSampleCreateOrConnectWithoutVoiceModelInput[]
    upsert?: TrainingSampleUpsertWithWhereUniqueWithoutVoiceModelInput | TrainingSampleUpsertWithWhereUniqueWithoutVoiceModelInput[]
    createMany?: TrainingSampleCreateManyVoiceModelInputEnvelope
    set?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    disconnect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    delete?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    connect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    update?: TrainingSampleUpdateWithWhereUniqueWithoutVoiceModelInput | TrainingSampleUpdateWithWhereUniqueWithoutVoiceModelInput[]
    updateMany?: TrainingSampleUpdateManyWithWhereWithoutVoiceModelInput | TrainingSampleUpdateManyWithWhereWithoutVoiceModelInput[]
    deleteMany?: TrainingSampleScalarWhereInput | TrainingSampleScalarWhereInput[]
  }

  export type CallSessionUpdateManyWithoutVoiceModelNestedInput = {
    create?: XOR<CallSessionCreateWithoutVoiceModelInput, CallSessionUncheckedCreateWithoutVoiceModelInput> | CallSessionCreateWithoutVoiceModelInput[] | CallSessionUncheckedCreateWithoutVoiceModelInput[]
    connectOrCreate?: CallSessionCreateOrConnectWithoutVoiceModelInput | CallSessionCreateOrConnectWithoutVoiceModelInput[]
    upsert?: CallSessionUpsertWithWhereUniqueWithoutVoiceModelInput | CallSessionUpsertWithWhereUniqueWithoutVoiceModelInput[]
    createMany?: CallSessionCreateManyVoiceModelInputEnvelope
    set?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    disconnect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    delete?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    connect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    update?: CallSessionUpdateWithWhereUniqueWithoutVoiceModelInput | CallSessionUpdateWithWhereUniqueWithoutVoiceModelInput[]
    updateMany?: CallSessionUpdateManyWithWhereWithoutVoiceModelInput | CallSessionUpdateManyWithWhereWithoutVoiceModelInput[]
    deleteMany?: CallSessionScalarWhereInput | CallSessionScalarWhereInput[]
  }

  export type TrainingSampleUncheckedUpdateManyWithoutVoiceModelNestedInput = {
    create?: XOR<TrainingSampleCreateWithoutVoiceModelInput, TrainingSampleUncheckedCreateWithoutVoiceModelInput> | TrainingSampleCreateWithoutVoiceModelInput[] | TrainingSampleUncheckedCreateWithoutVoiceModelInput[]
    connectOrCreate?: TrainingSampleCreateOrConnectWithoutVoiceModelInput | TrainingSampleCreateOrConnectWithoutVoiceModelInput[]
    upsert?: TrainingSampleUpsertWithWhereUniqueWithoutVoiceModelInput | TrainingSampleUpsertWithWhereUniqueWithoutVoiceModelInput[]
    createMany?: TrainingSampleCreateManyVoiceModelInputEnvelope
    set?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    disconnect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    delete?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    connect?: TrainingSampleWhereUniqueInput | TrainingSampleWhereUniqueInput[]
    update?: TrainingSampleUpdateWithWhereUniqueWithoutVoiceModelInput | TrainingSampleUpdateWithWhereUniqueWithoutVoiceModelInput[]
    updateMany?: TrainingSampleUpdateManyWithWhereWithoutVoiceModelInput | TrainingSampleUpdateManyWithWhereWithoutVoiceModelInput[]
    deleteMany?: TrainingSampleScalarWhereInput | TrainingSampleScalarWhereInput[]
  }

  export type CallSessionUncheckedUpdateManyWithoutVoiceModelNestedInput = {
    create?: XOR<CallSessionCreateWithoutVoiceModelInput, CallSessionUncheckedCreateWithoutVoiceModelInput> | CallSessionCreateWithoutVoiceModelInput[] | CallSessionUncheckedCreateWithoutVoiceModelInput[]
    connectOrCreate?: CallSessionCreateOrConnectWithoutVoiceModelInput | CallSessionCreateOrConnectWithoutVoiceModelInput[]
    upsert?: CallSessionUpsertWithWhereUniqueWithoutVoiceModelInput | CallSessionUpsertWithWhereUniqueWithoutVoiceModelInput[]
    createMany?: CallSessionCreateManyVoiceModelInputEnvelope
    set?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    disconnect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    delete?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    connect?: CallSessionWhereUniqueInput | CallSessionWhereUniqueInput[]
    update?: CallSessionUpdateWithWhereUniqueWithoutVoiceModelInput | CallSessionUpdateWithWhereUniqueWithoutVoiceModelInput[]
    updateMany?: CallSessionUpdateManyWithWhereWithoutVoiceModelInput | CallSessionUpdateManyWithWhereWithoutVoiceModelInput[]
    deleteMany?: CallSessionScalarWhereInput | CallSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTrainingSamplesInput = {
    create?: XOR<UserCreateWithoutTrainingSamplesInput, UserUncheckedCreateWithoutTrainingSamplesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingSamplesInput
    connect?: UserWhereUniqueInput
  }

  export type VoiceModelCreateNestedOneWithoutSamplesInput = {
    create?: XOR<VoiceModelCreateWithoutSamplesInput, VoiceModelUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: VoiceModelCreateOrConnectWithoutSamplesInput
    connect?: VoiceModelWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTrainingSamplesNestedInput = {
    create?: XOR<UserCreateWithoutTrainingSamplesInput, UserUncheckedCreateWithoutTrainingSamplesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingSamplesInput
    upsert?: UserUpsertWithoutTrainingSamplesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainingSamplesInput, UserUpdateWithoutTrainingSamplesInput>, UserUncheckedUpdateWithoutTrainingSamplesInput>
  }

  export type VoiceModelUpdateOneWithoutSamplesNestedInput = {
    create?: XOR<VoiceModelCreateWithoutSamplesInput, VoiceModelUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: VoiceModelCreateOrConnectWithoutSamplesInput
    upsert?: VoiceModelUpsertWithoutSamplesInput
    disconnect?: VoiceModelWhereInput | boolean
    delete?: VoiceModelWhereInput | boolean
    connect?: VoiceModelWhereUniqueInput
    update?: XOR<XOR<VoiceModelUpdateToOneWithWhereWithoutSamplesInput, VoiceModelUpdateWithoutSamplesInput>, VoiceModelUncheckedUpdateWithoutSamplesInput>
  }

  export type CallSessionCreatetopicsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCallSessionsInput = {
    create?: XOR<UserCreateWithoutCallSessionsInput, UserUncheckedCreateWithoutCallSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCallSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type VoiceModelCreateNestedOneWithoutCallSessionsInput = {
    create?: XOR<VoiceModelCreateWithoutCallSessionsInput, VoiceModelUncheckedCreateWithoutCallSessionsInput>
    connectOrCreate?: VoiceModelCreateOrConnectWithoutCallSessionsInput
    connect?: VoiceModelWhereUniqueInput
  }

  export type TranscriptMessageCreateNestedManyWithoutCallSessionInput = {
    create?: XOR<TranscriptMessageCreateWithoutCallSessionInput, TranscriptMessageUncheckedCreateWithoutCallSessionInput> | TranscriptMessageCreateWithoutCallSessionInput[] | TranscriptMessageUncheckedCreateWithoutCallSessionInput[]
    connectOrCreate?: TranscriptMessageCreateOrConnectWithoutCallSessionInput | TranscriptMessageCreateOrConnectWithoutCallSessionInput[]
    createMany?: TranscriptMessageCreateManyCallSessionInputEnvelope
    connect?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
  }

  export type CallSummaryCreateNestedOneWithoutCallSessionInput = {
    create?: XOR<CallSummaryCreateWithoutCallSessionInput, CallSummaryUncheckedCreateWithoutCallSessionInput>
    connectOrCreate?: CallSummaryCreateOrConnectWithoutCallSessionInput
    connect?: CallSummaryWhereUniqueInput
  }

  export type TranscriptMessageUncheckedCreateNestedManyWithoutCallSessionInput = {
    create?: XOR<TranscriptMessageCreateWithoutCallSessionInput, TranscriptMessageUncheckedCreateWithoutCallSessionInput> | TranscriptMessageCreateWithoutCallSessionInput[] | TranscriptMessageUncheckedCreateWithoutCallSessionInput[]
    connectOrCreate?: TranscriptMessageCreateOrConnectWithoutCallSessionInput | TranscriptMessageCreateOrConnectWithoutCallSessionInput[]
    createMany?: TranscriptMessageCreateManyCallSessionInputEnvelope
    connect?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
  }

  export type CallSummaryUncheckedCreateNestedOneWithoutCallSessionInput = {
    create?: XOR<CallSummaryCreateWithoutCallSessionInput, CallSummaryUncheckedCreateWithoutCallSessionInput>
    connectOrCreate?: CallSummaryCreateOrConnectWithoutCallSessionInput
    connect?: CallSummaryWhereUniqueInput
  }

  export type EnumCallDirectionFieldUpdateOperationsInput = {
    set?: $Enums.CallDirection
  }

  export type EnumCallStatusFieldUpdateOperationsInput = {
    set?: $Enums.CallStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumSentimentFieldUpdateOperationsInput = {
    set?: $Enums.Sentiment | null
  }

  export type CallSessionUpdatetopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCallSessionsNestedInput = {
    create?: XOR<UserCreateWithoutCallSessionsInput, UserUncheckedCreateWithoutCallSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCallSessionsInput
    upsert?: UserUpsertWithoutCallSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCallSessionsInput, UserUpdateWithoutCallSessionsInput>, UserUncheckedUpdateWithoutCallSessionsInput>
  }

  export type VoiceModelUpdateOneWithoutCallSessionsNestedInput = {
    create?: XOR<VoiceModelCreateWithoutCallSessionsInput, VoiceModelUncheckedCreateWithoutCallSessionsInput>
    connectOrCreate?: VoiceModelCreateOrConnectWithoutCallSessionsInput
    upsert?: VoiceModelUpsertWithoutCallSessionsInput
    disconnect?: VoiceModelWhereInput | boolean
    delete?: VoiceModelWhereInput | boolean
    connect?: VoiceModelWhereUniqueInput
    update?: XOR<XOR<VoiceModelUpdateToOneWithWhereWithoutCallSessionsInput, VoiceModelUpdateWithoutCallSessionsInput>, VoiceModelUncheckedUpdateWithoutCallSessionsInput>
  }

  export type TranscriptMessageUpdateManyWithoutCallSessionNestedInput = {
    create?: XOR<TranscriptMessageCreateWithoutCallSessionInput, TranscriptMessageUncheckedCreateWithoutCallSessionInput> | TranscriptMessageCreateWithoutCallSessionInput[] | TranscriptMessageUncheckedCreateWithoutCallSessionInput[]
    connectOrCreate?: TranscriptMessageCreateOrConnectWithoutCallSessionInput | TranscriptMessageCreateOrConnectWithoutCallSessionInput[]
    upsert?: TranscriptMessageUpsertWithWhereUniqueWithoutCallSessionInput | TranscriptMessageUpsertWithWhereUniqueWithoutCallSessionInput[]
    createMany?: TranscriptMessageCreateManyCallSessionInputEnvelope
    set?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
    disconnect?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
    delete?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
    connect?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
    update?: TranscriptMessageUpdateWithWhereUniqueWithoutCallSessionInput | TranscriptMessageUpdateWithWhereUniqueWithoutCallSessionInput[]
    updateMany?: TranscriptMessageUpdateManyWithWhereWithoutCallSessionInput | TranscriptMessageUpdateManyWithWhereWithoutCallSessionInput[]
    deleteMany?: TranscriptMessageScalarWhereInput | TranscriptMessageScalarWhereInput[]
  }

  export type CallSummaryUpdateOneWithoutCallSessionNestedInput = {
    create?: XOR<CallSummaryCreateWithoutCallSessionInput, CallSummaryUncheckedCreateWithoutCallSessionInput>
    connectOrCreate?: CallSummaryCreateOrConnectWithoutCallSessionInput
    upsert?: CallSummaryUpsertWithoutCallSessionInput
    disconnect?: CallSummaryWhereInput | boolean
    delete?: CallSummaryWhereInput | boolean
    connect?: CallSummaryWhereUniqueInput
    update?: XOR<XOR<CallSummaryUpdateToOneWithWhereWithoutCallSessionInput, CallSummaryUpdateWithoutCallSessionInput>, CallSummaryUncheckedUpdateWithoutCallSessionInput>
  }

  export type TranscriptMessageUncheckedUpdateManyWithoutCallSessionNestedInput = {
    create?: XOR<TranscriptMessageCreateWithoutCallSessionInput, TranscriptMessageUncheckedCreateWithoutCallSessionInput> | TranscriptMessageCreateWithoutCallSessionInput[] | TranscriptMessageUncheckedCreateWithoutCallSessionInput[]
    connectOrCreate?: TranscriptMessageCreateOrConnectWithoutCallSessionInput | TranscriptMessageCreateOrConnectWithoutCallSessionInput[]
    upsert?: TranscriptMessageUpsertWithWhereUniqueWithoutCallSessionInput | TranscriptMessageUpsertWithWhereUniqueWithoutCallSessionInput[]
    createMany?: TranscriptMessageCreateManyCallSessionInputEnvelope
    set?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
    disconnect?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
    delete?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
    connect?: TranscriptMessageWhereUniqueInput | TranscriptMessageWhereUniqueInput[]
    update?: TranscriptMessageUpdateWithWhereUniqueWithoutCallSessionInput | TranscriptMessageUpdateWithWhereUniqueWithoutCallSessionInput[]
    updateMany?: TranscriptMessageUpdateManyWithWhereWithoutCallSessionInput | TranscriptMessageUpdateManyWithWhereWithoutCallSessionInput[]
    deleteMany?: TranscriptMessageScalarWhereInput | TranscriptMessageScalarWhereInput[]
  }

  export type CallSummaryUncheckedUpdateOneWithoutCallSessionNestedInput = {
    create?: XOR<CallSummaryCreateWithoutCallSessionInput, CallSummaryUncheckedCreateWithoutCallSessionInput>
    connectOrCreate?: CallSummaryCreateOrConnectWithoutCallSessionInput
    upsert?: CallSummaryUpsertWithoutCallSessionInput
    disconnect?: CallSummaryWhereInput | boolean
    delete?: CallSummaryWhereInput | boolean
    connect?: CallSummaryWhereUniqueInput
    update?: XOR<XOR<CallSummaryUpdateToOneWithWhereWithoutCallSessionInput, CallSummaryUpdateWithoutCallSessionInput>, CallSummaryUncheckedUpdateWithoutCallSessionInput>
  }

  export type CallSessionCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<CallSessionCreateWithoutTranscriptInput, CallSessionUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutTranscriptInput
    connect?: CallSessionWhereUniqueInput
  }

  export type EnumSpeakerFieldUpdateOperationsInput = {
    set?: $Enums.Speaker
  }

  export type CallSessionUpdateOneRequiredWithoutTranscriptNestedInput = {
    create?: XOR<CallSessionCreateWithoutTranscriptInput, CallSessionUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutTranscriptInput
    upsert?: CallSessionUpsertWithoutTranscriptInput
    connect?: CallSessionWhereUniqueInput
    update?: XOR<XOR<CallSessionUpdateToOneWithWhereWithoutTranscriptInput, CallSessionUpdateWithoutTranscriptInput>, CallSessionUncheckedUpdateWithoutTranscriptInput>
  }

  export type CallSummaryCreateactionItemsInput = {
    set: string[]
  }

  export type CallSummaryCreatekeyPointsInput = {
    set: string[]
  }

  export type CallSessionCreateNestedOneWithoutSummaryInput = {
    create?: XOR<CallSessionCreateWithoutSummaryInput, CallSessionUncheckedCreateWithoutSummaryInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutSummaryInput
    connect?: CallSessionWhereUniqueInput
  }

  export type CallSummaryUpdateactionItemsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CallSummaryUpdatekeyPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CallSessionUpdateOneRequiredWithoutSummaryNestedInput = {
    create?: XOR<CallSessionCreateWithoutSummaryInput, CallSessionUncheckedCreateWithoutSummaryInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutSummaryInput
    upsert?: CallSessionUpsertWithoutSummaryInput
    connect?: CallSessionWhereUniqueInput
    update?: XOR<XOR<CallSessionUpdateToOneWithWhereWithoutSummaryInput, CallSessionUpdateWithoutSummaryInput>, CallSessionUncheckedUpdateWithoutSummaryInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InboundCallCreateNestedManyWithoutBusinessInput = {
    create?: XOR<InboundCallCreateWithoutBusinessInput, InboundCallUncheckedCreateWithoutBusinessInput> | InboundCallCreateWithoutBusinessInput[] | InboundCallUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: InboundCallCreateOrConnectWithoutBusinessInput | InboundCallCreateOrConnectWithoutBusinessInput[]
    createMany?: InboundCallCreateManyBusinessInputEnvelope
    connect?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
  }

  export type OutboundCallCreateNestedManyWithoutBusinessInput = {
    create?: XOR<OutboundCallCreateWithoutBusinessInput, OutboundCallUncheckedCreateWithoutBusinessInput> | OutboundCallCreateWithoutBusinessInput[] | OutboundCallUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OutboundCallCreateOrConnectWithoutBusinessInput | OutboundCallCreateOrConnectWithoutBusinessInput[]
    createMany?: OutboundCallCreateManyBusinessInputEnvelope
    connect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
  }

  export type CallRoutingRuleCreateNestedManyWithoutBusinessInput = {
    create?: XOR<CallRoutingRuleCreateWithoutBusinessInput, CallRoutingRuleUncheckedCreateWithoutBusinessInput> | CallRoutingRuleCreateWithoutBusinessInput[] | CallRoutingRuleUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CallRoutingRuleCreateOrConnectWithoutBusinessInput | CallRoutingRuleCreateOrConnectWithoutBusinessInput[]
    createMany?: CallRoutingRuleCreateManyBusinessInputEnvelope
    connect?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
  }

  export type OutboundCampaignCreateNestedManyWithoutBusinessInput = {
    create?: XOR<OutboundCampaignCreateWithoutBusinessInput, OutboundCampaignUncheckedCreateWithoutBusinessInput> | OutboundCampaignCreateWithoutBusinessInput[] | OutboundCampaignUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OutboundCampaignCreateOrConnectWithoutBusinessInput | OutboundCampaignCreateOrConnectWithoutBusinessInput[]
    createMany?: OutboundCampaignCreateManyBusinessInputEnvelope
    connect?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
  }

  export type CallQueueCreateNestedManyWithoutBusinessInput = {
    create?: XOR<CallQueueCreateWithoutBusinessInput, CallQueueUncheckedCreateWithoutBusinessInput> | CallQueueCreateWithoutBusinessInput[] | CallQueueUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CallQueueCreateOrConnectWithoutBusinessInput | CallQueueCreateOrConnectWithoutBusinessInput[]
    createMany?: CallQueueCreateManyBusinessInputEnvelope
    connect?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
  }

  export type InboundCallUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<InboundCallCreateWithoutBusinessInput, InboundCallUncheckedCreateWithoutBusinessInput> | InboundCallCreateWithoutBusinessInput[] | InboundCallUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: InboundCallCreateOrConnectWithoutBusinessInput | InboundCallCreateOrConnectWithoutBusinessInput[]
    createMany?: InboundCallCreateManyBusinessInputEnvelope
    connect?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
  }

  export type OutboundCallUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<OutboundCallCreateWithoutBusinessInput, OutboundCallUncheckedCreateWithoutBusinessInput> | OutboundCallCreateWithoutBusinessInput[] | OutboundCallUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OutboundCallCreateOrConnectWithoutBusinessInput | OutboundCallCreateOrConnectWithoutBusinessInput[]
    createMany?: OutboundCallCreateManyBusinessInputEnvelope
    connect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
  }

  export type CallRoutingRuleUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<CallRoutingRuleCreateWithoutBusinessInput, CallRoutingRuleUncheckedCreateWithoutBusinessInput> | CallRoutingRuleCreateWithoutBusinessInput[] | CallRoutingRuleUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CallRoutingRuleCreateOrConnectWithoutBusinessInput | CallRoutingRuleCreateOrConnectWithoutBusinessInput[]
    createMany?: CallRoutingRuleCreateManyBusinessInputEnvelope
    connect?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
  }

  export type OutboundCampaignUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<OutboundCampaignCreateWithoutBusinessInput, OutboundCampaignUncheckedCreateWithoutBusinessInput> | OutboundCampaignCreateWithoutBusinessInput[] | OutboundCampaignUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OutboundCampaignCreateOrConnectWithoutBusinessInput | OutboundCampaignCreateOrConnectWithoutBusinessInput[]
    createMany?: OutboundCampaignCreateManyBusinessInputEnvelope
    connect?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
  }

  export type CallQueueUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<CallQueueCreateWithoutBusinessInput, CallQueueUncheckedCreateWithoutBusinessInput> | CallQueueCreateWithoutBusinessInput[] | CallQueueUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CallQueueCreateOrConnectWithoutBusinessInput | CallQueueCreateOrConnectWithoutBusinessInput[]
    createMany?: CallQueueCreateManyBusinessInputEnvelope
    connect?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
  }

  export type InboundCallUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<InboundCallCreateWithoutBusinessInput, InboundCallUncheckedCreateWithoutBusinessInput> | InboundCallCreateWithoutBusinessInput[] | InboundCallUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: InboundCallCreateOrConnectWithoutBusinessInput | InboundCallCreateOrConnectWithoutBusinessInput[]
    upsert?: InboundCallUpsertWithWhereUniqueWithoutBusinessInput | InboundCallUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: InboundCallCreateManyBusinessInputEnvelope
    set?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
    disconnect?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
    delete?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
    connect?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
    update?: InboundCallUpdateWithWhereUniqueWithoutBusinessInput | InboundCallUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: InboundCallUpdateManyWithWhereWithoutBusinessInput | InboundCallUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: InboundCallScalarWhereInput | InboundCallScalarWhereInput[]
  }

  export type OutboundCallUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<OutboundCallCreateWithoutBusinessInput, OutboundCallUncheckedCreateWithoutBusinessInput> | OutboundCallCreateWithoutBusinessInput[] | OutboundCallUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OutboundCallCreateOrConnectWithoutBusinessInput | OutboundCallCreateOrConnectWithoutBusinessInput[]
    upsert?: OutboundCallUpsertWithWhereUniqueWithoutBusinessInput | OutboundCallUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: OutboundCallCreateManyBusinessInputEnvelope
    set?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    disconnect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    delete?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    connect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    update?: OutboundCallUpdateWithWhereUniqueWithoutBusinessInput | OutboundCallUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: OutboundCallUpdateManyWithWhereWithoutBusinessInput | OutboundCallUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: OutboundCallScalarWhereInput | OutboundCallScalarWhereInput[]
  }

  export type CallRoutingRuleUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<CallRoutingRuleCreateWithoutBusinessInput, CallRoutingRuleUncheckedCreateWithoutBusinessInput> | CallRoutingRuleCreateWithoutBusinessInput[] | CallRoutingRuleUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CallRoutingRuleCreateOrConnectWithoutBusinessInput | CallRoutingRuleCreateOrConnectWithoutBusinessInput[]
    upsert?: CallRoutingRuleUpsertWithWhereUniqueWithoutBusinessInput | CallRoutingRuleUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: CallRoutingRuleCreateManyBusinessInputEnvelope
    set?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
    disconnect?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
    delete?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
    connect?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
    update?: CallRoutingRuleUpdateWithWhereUniqueWithoutBusinessInput | CallRoutingRuleUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: CallRoutingRuleUpdateManyWithWhereWithoutBusinessInput | CallRoutingRuleUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: CallRoutingRuleScalarWhereInput | CallRoutingRuleScalarWhereInput[]
  }

  export type OutboundCampaignUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<OutboundCampaignCreateWithoutBusinessInput, OutboundCampaignUncheckedCreateWithoutBusinessInput> | OutboundCampaignCreateWithoutBusinessInput[] | OutboundCampaignUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OutboundCampaignCreateOrConnectWithoutBusinessInput | OutboundCampaignCreateOrConnectWithoutBusinessInput[]
    upsert?: OutboundCampaignUpsertWithWhereUniqueWithoutBusinessInput | OutboundCampaignUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: OutboundCampaignCreateManyBusinessInputEnvelope
    set?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
    disconnect?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
    delete?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
    connect?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
    update?: OutboundCampaignUpdateWithWhereUniqueWithoutBusinessInput | OutboundCampaignUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: OutboundCampaignUpdateManyWithWhereWithoutBusinessInput | OutboundCampaignUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: OutboundCampaignScalarWhereInput | OutboundCampaignScalarWhereInput[]
  }

  export type CallQueueUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<CallQueueCreateWithoutBusinessInput, CallQueueUncheckedCreateWithoutBusinessInput> | CallQueueCreateWithoutBusinessInput[] | CallQueueUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CallQueueCreateOrConnectWithoutBusinessInput | CallQueueCreateOrConnectWithoutBusinessInput[]
    upsert?: CallQueueUpsertWithWhereUniqueWithoutBusinessInput | CallQueueUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: CallQueueCreateManyBusinessInputEnvelope
    set?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
    disconnect?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
    delete?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
    connect?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
    update?: CallQueueUpdateWithWhereUniqueWithoutBusinessInput | CallQueueUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: CallQueueUpdateManyWithWhereWithoutBusinessInput | CallQueueUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: CallQueueScalarWhereInput | CallQueueScalarWhereInput[]
  }

  export type InboundCallUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<InboundCallCreateWithoutBusinessInput, InboundCallUncheckedCreateWithoutBusinessInput> | InboundCallCreateWithoutBusinessInput[] | InboundCallUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: InboundCallCreateOrConnectWithoutBusinessInput | InboundCallCreateOrConnectWithoutBusinessInput[]
    upsert?: InboundCallUpsertWithWhereUniqueWithoutBusinessInput | InboundCallUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: InboundCallCreateManyBusinessInputEnvelope
    set?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
    disconnect?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
    delete?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
    connect?: InboundCallWhereUniqueInput | InboundCallWhereUniqueInput[]
    update?: InboundCallUpdateWithWhereUniqueWithoutBusinessInput | InboundCallUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: InboundCallUpdateManyWithWhereWithoutBusinessInput | InboundCallUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: InboundCallScalarWhereInput | InboundCallScalarWhereInput[]
  }

  export type OutboundCallUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<OutboundCallCreateWithoutBusinessInput, OutboundCallUncheckedCreateWithoutBusinessInput> | OutboundCallCreateWithoutBusinessInput[] | OutboundCallUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OutboundCallCreateOrConnectWithoutBusinessInput | OutboundCallCreateOrConnectWithoutBusinessInput[]
    upsert?: OutboundCallUpsertWithWhereUniqueWithoutBusinessInput | OutboundCallUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: OutboundCallCreateManyBusinessInputEnvelope
    set?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    disconnect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    delete?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    connect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    update?: OutboundCallUpdateWithWhereUniqueWithoutBusinessInput | OutboundCallUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: OutboundCallUpdateManyWithWhereWithoutBusinessInput | OutboundCallUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: OutboundCallScalarWhereInput | OutboundCallScalarWhereInput[]
  }

  export type CallRoutingRuleUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<CallRoutingRuleCreateWithoutBusinessInput, CallRoutingRuleUncheckedCreateWithoutBusinessInput> | CallRoutingRuleCreateWithoutBusinessInput[] | CallRoutingRuleUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CallRoutingRuleCreateOrConnectWithoutBusinessInput | CallRoutingRuleCreateOrConnectWithoutBusinessInput[]
    upsert?: CallRoutingRuleUpsertWithWhereUniqueWithoutBusinessInput | CallRoutingRuleUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: CallRoutingRuleCreateManyBusinessInputEnvelope
    set?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
    disconnect?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
    delete?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
    connect?: CallRoutingRuleWhereUniqueInput | CallRoutingRuleWhereUniqueInput[]
    update?: CallRoutingRuleUpdateWithWhereUniqueWithoutBusinessInput | CallRoutingRuleUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: CallRoutingRuleUpdateManyWithWhereWithoutBusinessInput | CallRoutingRuleUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: CallRoutingRuleScalarWhereInput | CallRoutingRuleScalarWhereInput[]
  }

  export type OutboundCampaignUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<OutboundCampaignCreateWithoutBusinessInput, OutboundCampaignUncheckedCreateWithoutBusinessInput> | OutboundCampaignCreateWithoutBusinessInput[] | OutboundCampaignUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OutboundCampaignCreateOrConnectWithoutBusinessInput | OutboundCampaignCreateOrConnectWithoutBusinessInput[]
    upsert?: OutboundCampaignUpsertWithWhereUniqueWithoutBusinessInput | OutboundCampaignUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: OutboundCampaignCreateManyBusinessInputEnvelope
    set?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
    disconnect?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
    delete?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
    connect?: OutboundCampaignWhereUniqueInput | OutboundCampaignWhereUniqueInput[]
    update?: OutboundCampaignUpdateWithWhereUniqueWithoutBusinessInput | OutboundCampaignUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: OutboundCampaignUpdateManyWithWhereWithoutBusinessInput | OutboundCampaignUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: OutboundCampaignScalarWhereInput | OutboundCampaignScalarWhereInput[]
  }

  export type CallQueueUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<CallQueueCreateWithoutBusinessInput, CallQueueUncheckedCreateWithoutBusinessInput> | CallQueueCreateWithoutBusinessInput[] | CallQueueUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CallQueueCreateOrConnectWithoutBusinessInput | CallQueueCreateOrConnectWithoutBusinessInput[]
    upsert?: CallQueueUpsertWithWhereUniqueWithoutBusinessInput | CallQueueUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: CallQueueCreateManyBusinessInputEnvelope
    set?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
    disconnect?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
    delete?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
    connect?: CallQueueWhereUniqueInput | CallQueueWhereUniqueInput[]
    update?: CallQueueUpdateWithWhereUniqueWithoutBusinessInput | CallQueueUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: CallQueueUpdateManyWithWhereWithoutBusinessInput | CallQueueUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: CallQueueScalarWhereInput | CallQueueScalarWhereInput[]
  }

  export type InboundCallCreatetagsInput = {
    set: string[]
  }

  export type BusinessCreateNestedOneWithoutInboundCallsInput = {
    create?: XOR<BusinessCreateWithoutInboundCallsInput, BusinessUncheckedCreateWithoutInboundCallsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutInboundCallsInput
    connect?: BusinessWhereUniqueInput
  }

  export type EnumInboundCallStatusFieldUpdateOperationsInput = {
    set?: $Enums.InboundCallStatus
  }

  export type InboundCallUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BusinessUpdateOneRequiredWithoutInboundCallsNestedInput = {
    create?: XOR<BusinessCreateWithoutInboundCallsInput, BusinessUncheckedCreateWithoutInboundCallsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutInboundCallsInput
    upsert?: BusinessUpsertWithoutInboundCallsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutInboundCallsInput, BusinessUpdateWithoutInboundCallsInput>, BusinessUncheckedUpdateWithoutInboundCallsInput>
  }

  export type BusinessCreateNestedOneWithoutOutboundCallsInput = {
    create?: XOR<BusinessCreateWithoutOutboundCallsInput, BusinessUncheckedCreateWithoutOutboundCallsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutOutboundCallsInput
    connect?: BusinessWhereUniqueInput
  }

  export type OutboundCampaignCreateNestedOneWithoutCallsInput = {
    create?: XOR<OutboundCampaignCreateWithoutCallsInput, OutboundCampaignUncheckedCreateWithoutCallsInput>
    connectOrCreate?: OutboundCampaignCreateOrConnectWithoutCallsInput
    connect?: OutboundCampaignWhereUniqueInput
  }

  export type EnumOutboundCallStatusFieldUpdateOperationsInput = {
    set?: $Enums.OutboundCallStatus
  }

  export type NullableEnumCallResultFieldUpdateOperationsInput = {
    set?: $Enums.CallResult | null
  }

  export type BusinessUpdateOneRequiredWithoutOutboundCallsNestedInput = {
    create?: XOR<BusinessCreateWithoutOutboundCallsInput, BusinessUncheckedCreateWithoutOutboundCallsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutOutboundCallsInput
    upsert?: BusinessUpsertWithoutOutboundCallsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutOutboundCallsInput, BusinessUpdateWithoutOutboundCallsInput>, BusinessUncheckedUpdateWithoutOutboundCallsInput>
  }

  export type OutboundCampaignUpdateOneWithoutCallsNestedInput = {
    create?: XOR<OutboundCampaignCreateWithoutCallsInput, OutboundCampaignUncheckedCreateWithoutCallsInput>
    connectOrCreate?: OutboundCampaignCreateOrConnectWithoutCallsInput
    upsert?: OutboundCampaignUpsertWithoutCallsInput
    disconnect?: OutboundCampaignWhereInput | boolean
    delete?: OutboundCampaignWhereInput | boolean
    connect?: OutboundCampaignWhereUniqueInput
    update?: XOR<XOR<OutboundCampaignUpdateToOneWithWhereWithoutCallsInput, OutboundCampaignUpdateWithoutCallsInput>, OutboundCampaignUncheckedUpdateWithoutCallsInput>
  }

  export type BusinessCreateNestedOneWithoutRoutingRulesInput = {
    create?: XOR<BusinessCreateWithoutRoutingRulesInput, BusinessUncheckedCreateWithoutRoutingRulesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRoutingRulesInput
    connect?: BusinessWhereUniqueInput
  }

  export type EnumConditionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConditionType
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type BusinessUpdateOneRequiredWithoutRoutingRulesNestedInput = {
    create?: XOR<BusinessCreateWithoutRoutingRulesInput, BusinessUncheckedCreateWithoutRoutingRulesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRoutingRulesInput
    upsert?: BusinessUpsertWithoutRoutingRulesInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutRoutingRulesInput, BusinessUpdateWithoutRoutingRulesInput>, BusinessUncheckedUpdateWithoutRoutingRulesInput>
  }

  export type BusinessCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<BusinessCreateWithoutCampaignsInput, BusinessUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutCampaignsInput
    connect?: BusinessWhereUniqueInput
  }

  export type OutboundCallCreateNestedManyWithoutCampaignInput = {
    create?: XOR<OutboundCallCreateWithoutCampaignInput, OutboundCallUncheckedCreateWithoutCampaignInput> | OutboundCallCreateWithoutCampaignInput[] | OutboundCallUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: OutboundCallCreateOrConnectWithoutCampaignInput | OutboundCallCreateOrConnectWithoutCampaignInput[]
    createMany?: OutboundCallCreateManyCampaignInputEnvelope
    connect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
  }

  export type OutboundCallUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<OutboundCallCreateWithoutCampaignInput, OutboundCallUncheckedCreateWithoutCampaignInput> | OutboundCallCreateWithoutCampaignInput[] | OutboundCallUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: OutboundCallCreateOrConnectWithoutCampaignInput | OutboundCallCreateOrConnectWithoutCampaignInput[]
    createMany?: OutboundCallCreateManyCampaignInputEnvelope
    connect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type BusinessUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<BusinessCreateWithoutCampaignsInput, BusinessUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutCampaignsInput
    upsert?: BusinessUpsertWithoutCampaignsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutCampaignsInput, BusinessUpdateWithoutCampaignsInput>, BusinessUncheckedUpdateWithoutCampaignsInput>
  }

  export type OutboundCallUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<OutboundCallCreateWithoutCampaignInput, OutboundCallUncheckedCreateWithoutCampaignInput> | OutboundCallCreateWithoutCampaignInput[] | OutboundCallUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: OutboundCallCreateOrConnectWithoutCampaignInput | OutboundCallCreateOrConnectWithoutCampaignInput[]
    upsert?: OutboundCallUpsertWithWhereUniqueWithoutCampaignInput | OutboundCallUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: OutboundCallCreateManyCampaignInputEnvelope
    set?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    disconnect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    delete?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    connect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    update?: OutboundCallUpdateWithWhereUniqueWithoutCampaignInput | OutboundCallUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: OutboundCallUpdateManyWithWhereWithoutCampaignInput | OutboundCallUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: OutboundCallScalarWhereInput | OutboundCallScalarWhereInput[]
  }

  export type OutboundCallUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<OutboundCallCreateWithoutCampaignInput, OutboundCallUncheckedCreateWithoutCampaignInput> | OutboundCallCreateWithoutCampaignInput[] | OutboundCallUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: OutboundCallCreateOrConnectWithoutCampaignInput | OutboundCallCreateOrConnectWithoutCampaignInput[]
    upsert?: OutboundCallUpsertWithWhereUniqueWithoutCampaignInput | OutboundCallUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: OutboundCallCreateManyCampaignInputEnvelope
    set?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    disconnect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    delete?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    connect?: OutboundCallWhereUniqueInput | OutboundCallWhereUniqueInput[]
    update?: OutboundCallUpdateWithWhereUniqueWithoutCampaignInput | OutboundCallUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: OutboundCallUpdateManyWithWhereWithoutCampaignInput | OutboundCallUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: OutboundCallScalarWhereInput | OutboundCallScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutCallQueueInput = {
    create?: XOR<BusinessCreateWithoutCallQueueInput, BusinessUncheckedCreateWithoutCallQueueInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutCallQueueInput
    connect?: BusinessWhereUniqueInput
  }

  export type EnumQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueueStatus
  }

  export type BusinessUpdateOneRequiredWithoutCallQueueNestedInput = {
    create?: XOR<BusinessCreateWithoutCallQueueInput, BusinessUncheckedCreateWithoutCallQueueInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutCallQueueInput
    upsert?: BusinessUpsertWithoutCallQueueInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutCallQueueInput, BusinessUpdateWithoutCallQueueInput>, BusinessUncheckedUpdateWithoutCallQueueInput>
  }

  export type EnumCallbackStatusFieldUpdateOperationsInput = {
    set?: $Enums.CallbackStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanFilter<$PrismaModel> | $Enums.Plan
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel>
    in?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.Plan[] | ListEnumPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanWithAggregatesFilter<$PrismaModel> | $Enums.Plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanFilter<$PrismaModel>
    _max?: NestedEnumPlanFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumApiKeyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiKeyType | EnumApiKeyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiKeyType[] | ListEnumApiKeyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiKeyType[] | ListEnumApiKeyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiKeyTypeFilter<$PrismaModel> | $Enums.ApiKeyType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumApiKeyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiKeyType | EnumApiKeyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiKeyType[] | ListEnumApiKeyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiKeyType[] | ListEnumApiKeyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiKeyTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApiKeyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiKeyTypeFilter<$PrismaModel>
    _max?: NestedEnumApiKeyTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumVoiceModelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VoiceModelStatus | EnumVoiceModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoiceModelStatus[] | ListEnumVoiceModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoiceModelStatus[] | ListEnumVoiceModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoiceModelStatusFilter<$PrismaModel> | $Enums.VoiceModelStatus
  }

  export type NestedEnumVoiceModelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoiceModelStatus | EnumVoiceModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoiceModelStatus[] | ListEnumVoiceModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoiceModelStatus[] | ListEnumVoiceModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoiceModelStatusWithAggregatesFilter<$PrismaModel> | $Enums.VoiceModelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoiceModelStatusFilter<$PrismaModel>
    _max?: NestedEnumVoiceModelStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCallDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionFilter<$PrismaModel> | $Enums.CallDirection
  }

  export type NestedEnumCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallStatusFilter<$PrismaModel> | $Enums.CallStatus
  }

  export type NestedEnumSentimentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sentiment | EnumSentimentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentNullableFilter<$PrismaModel> | $Enums.Sentiment | null
  }

  export type NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel> | $Enums.CallDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallDirectionFilter<$PrismaModel>
    _max?: NestedEnumCallDirectionFilter<$PrismaModel>
  }

  export type NestedEnumCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallStatus | EnumCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallStatus[] | ListEnumCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.CallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallStatusFilter<$PrismaModel>
    _max?: NestedEnumCallStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumSentimentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sentiment | EnumSentimentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sentiment[] | ListEnumSentimentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSentimentNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sentiment | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSentimentNullableFilter<$PrismaModel>
    _max?: NestedEnumSentimentNullableFilter<$PrismaModel>
  }

  export type NestedEnumSpeakerFilter<$PrismaModel = never> = {
    equals?: $Enums.Speaker | EnumSpeakerFieldRefInput<$PrismaModel>
    in?: $Enums.Speaker[] | ListEnumSpeakerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Speaker[] | ListEnumSpeakerFieldRefInput<$PrismaModel>
    not?: NestedEnumSpeakerFilter<$PrismaModel> | $Enums.Speaker
  }

  export type NestedEnumSpeakerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Speaker | EnumSpeakerFieldRefInput<$PrismaModel>
    in?: $Enums.Speaker[] | ListEnumSpeakerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Speaker[] | ListEnumSpeakerFieldRefInput<$PrismaModel>
    not?: NestedEnumSpeakerWithAggregatesFilter<$PrismaModel> | $Enums.Speaker
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpeakerFilter<$PrismaModel>
    _max?: NestedEnumSpeakerFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumInboundCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InboundCallStatus | EnumInboundCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InboundCallStatus[] | ListEnumInboundCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InboundCallStatus[] | ListEnumInboundCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInboundCallStatusFilter<$PrismaModel> | $Enums.InboundCallStatus
  }

  export type NestedEnumInboundCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InboundCallStatus | EnumInboundCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InboundCallStatus[] | ListEnumInboundCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InboundCallStatus[] | ListEnumInboundCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInboundCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.InboundCallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInboundCallStatusFilter<$PrismaModel>
    _max?: NestedEnumInboundCallStatusFilter<$PrismaModel>
  }

  export type NestedEnumOutboundCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboundCallStatus | EnumOutboundCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboundCallStatus[] | ListEnumOutboundCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboundCallStatus[] | ListEnumOutboundCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboundCallStatusFilter<$PrismaModel> | $Enums.OutboundCallStatus
  }

  export type NestedEnumCallResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CallResult | EnumCallResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallResult[] | ListEnumCallResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallResult[] | ListEnumCallResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallResultNullableFilter<$PrismaModel> | $Enums.CallResult | null
  }

  export type NestedEnumOutboundCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboundCallStatus | EnumOutboundCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboundCallStatus[] | ListEnumOutboundCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboundCallStatus[] | ListEnumOutboundCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboundCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.OutboundCallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOutboundCallStatusFilter<$PrismaModel>
    _max?: NestedEnumOutboundCallStatusFilter<$PrismaModel>
  }

  export type NestedEnumCallResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallResult | EnumCallResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.CallResult[] | ListEnumCallResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CallResult[] | ListEnumCallResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCallResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.CallResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCallResultNullableFilter<$PrismaModel>
    _max?: NestedEnumCallResultNullableFilter<$PrismaModel>
  }

  export type NestedEnumConditionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConditionType | EnumConditionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConditionType[] | ListEnumConditionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConditionType[] | ListEnumConditionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConditionTypeFilter<$PrismaModel> | $Enums.ConditionType
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumConditionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConditionType | EnumConditionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConditionType[] | ListEnumConditionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConditionType[] | ListEnumConditionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConditionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConditionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConditionTypeFilter<$PrismaModel>
    _max?: NestedEnumConditionTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type NestedEnumCallbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CallbackStatus | EnumCallbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallbackStatus[] | ListEnumCallbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallbackStatus[] | ListEnumCallbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallbackStatusFilter<$PrismaModel> | $Enums.CallbackStatus
  }

  export type NestedEnumCallbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallbackStatus | EnumCallbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CallbackStatus[] | ListEnumCallbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallbackStatus[] | ListEnumCallbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCallbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.CallbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallbackStatusFilter<$PrismaModel>
    _max?: NestedEnumCallbackStatusFilter<$PrismaModel>
  }

  export type VoiceModelCreateWithoutUserInput = {
    id?: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: TrainingSampleCreateNestedManyWithoutVoiceModelInput
    callSessions?: CallSessionCreateNestedManyWithoutVoiceModelInput
  }

  export type VoiceModelUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: TrainingSampleUncheckedCreateNestedManyWithoutVoiceModelInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutVoiceModelInput
  }

  export type VoiceModelCreateOrConnectWithoutUserInput = {
    where: VoiceModelWhereUniqueInput
    create: XOR<VoiceModelCreateWithoutUserInput, VoiceModelUncheckedCreateWithoutUserInput>
  }

  export type VoiceModelCreateManyUserInputEnvelope = {
    data: VoiceModelCreateManyUserInput | VoiceModelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CallSessionCreateWithoutUserInput = {
    id?: string
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModel?: VoiceModelCreateNestedOneWithoutCallSessionsInput
    transcript?: TranscriptMessageCreateNestedManyWithoutCallSessionInput
    summary?: CallSummaryCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionUncheckedCreateWithoutUserInput = {
    id?: string
    voiceModelId?: string | null
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: TranscriptMessageUncheckedCreateNestedManyWithoutCallSessionInput
    summary?: CallSummaryUncheckedCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionCreateOrConnectWithoutUserInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutUserInput, CallSessionUncheckedCreateWithoutUserInput>
  }

  export type CallSessionCreateManyUserInputEnvelope = {
    data: CallSessionCreateManyUserInput | CallSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TrainingSampleCreateWithoutUserInput = {
    id?: string
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
    voiceModel?: VoiceModelCreateNestedOneWithoutSamplesInput
  }

  export type TrainingSampleUncheckedCreateWithoutUserInput = {
    id?: string
    voiceModelId?: string | null
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
  }

  export type TrainingSampleCreateOrConnectWithoutUserInput = {
    where: TrainingSampleWhereUniqueInput
    create: XOR<TrainingSampleCreateWithoutUserInput, TrainingSampleUncheckedCreateWithoutUserInput>
  }

  export type TrainingSampleCreateManyUserInputEnvelope = {
    data: TrainingSampleCreateManyUserInput | TrainingSampleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    callSummaries?: boolean
    weeklyReports?: boolean
    marketingEmails?: boolean
    companyName?: string | null
    industry?: string | null
    greeting?: string | null
    fallbackMessage?: string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    callSummaries?: boolean
    weeklyReports?: boolean
    marketingEmails?: boolean
    companyName?: string | null
    industry?: string | null
    greeting?: string | null
    fallbackMessage?: string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    key: string
    name: string
    type?: $Enums.ApiKeyType
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    key: string
    name: string
    type?: $Enums.ApiKeyType
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoiceModelUpsertWithWhereUniqueWithoutUserInput = {
    where: VoiceModelWhereUniqueInput
    update: XOR<VoiceModelUpdateWithoutUserInput, VoiceModelUncheckedUpdateWithoutUserInput>
    create: XOR<VoiceModelCreateWithoutUserInput, VoiceModelUncheckedCreateWithoutUserInput>
  }

  export type VoiceModelUpdateWithWhereUniqueWithoutUserInput = {
    where: VoiceModelWhereUniqueInput
    data: XOR<VoiceModelUpdateWithoutUserInput, VoiceModelUncheckedUpdateWithoutUserInput>
  }

  export type VoiceModelUpdateManyWithWhereWithoutUserInput = {
    where: VoiceModelScalarWhereInput
    data: XOR<VoiceModelUpdateManyMutationInput, VoiceModelUncheckedUpdateManyWithoutUserInput>
  }

  export type VoiceModelScalarWhereInput = {
    AND?: VoiceModelScalarWhereInput | VoiceModelScalarWhereInput[]
    OR?: VoiceModelScalarWhereInput[]
    NOT?: VoiceModelScalarWhereInput | VoiceModelScalarWhereInput[]
    id?: StringFilter<"VoiceModel"> | string
    userId?: StringFilter<"VoiceModel"> | string
    name?: StringFilter<"VoiceModel"> | string
    status?: EnumVoiceModelStatusFilter<"VoiceModel"> | $Enums.VoiceModelStatus
    friendliness?: IntFilter<"VoiceModel"> | number
    professionalism?: IntFilter<"VoiceModel"> | number
    energy?: IntFilter<"VoiceModel"> | number
    formality?: IntFilter<"VoiceModel"> | number
    externalVoiceId?: StringNullableFilter<"VoiceModel"> | string | null
    createdAt?: DateTimeFilter<"VoiceModel"> | Date | string
    updatedAt?: DateTimeFilter<"VoiceModel"> | Date | string
  }

  export type CallSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: CallSessionWhereUniqueInput
    update: XOR<CallSessionUpdateWithoutUserInput, CallSessionUncheckedUpdateWithoutUserInput>
    create: XOR<CallSessionCreateWithoutUserInput, CallSessionUncheckedCreateWithoutUserInput>
  }

  export type CallSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: CallSessionWhereUniqueInput
    data: XOR<CallSessionUpdateWithoutUserInput, CallSessionUncheckedUpdateWithoutUserInput>
  }

  export type CallSessionUpdateManyWithWhereWithoutUserInput = {
    where: CallSessionScalarWhereInput
    data: XOR<CallSessionUpdateManyMutationInput, CallSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type CallSessionScalarWhereInput = {
    AND?: CallSessionScalarWhereInput | CallSessionScalarWhereInput[]
    OR?: CallSessionScalarWhereInput[]
    NOT?: CallSessionScalarWhereInput | CallSessionScalarWhereInput[]
    id?: StringFilter<"CallSession"> | string
    userId?: StringFilter<"CallSession"> | string
    voiceModelId?: StringNullableFilter<"CallSession"> | string | null
    phoneNumber?: StringFilter<"CallSession"> | string
    direction?: EnumCallDirectionFilter<"CallSession"> | $Enums.CallDirection
    status?: EnumCallStatusFilter<"CallSession"> | $Enums.CallStatus
    startTime?: DateTimeFilter<"CallSession"> | Date | string
    endTime?: DateTimeNullableFilter<"CallSession"> | Date | string | null
    duration?: IntNullableFilter<"CallSession"> | number | null
    sentiment?: EnumSentimentNullableFilter<"CallSession"> | $Enums.Sentiment | null
    topics?: StringNullableListFilter<"CallSession">
    externalCallId?: StringNullableFilter<"CallSession"> | string | null
    createdAt?: DateTimeFilter<"CallSession"> | Date | string
    updatedAt?: DateTimeFilter<"CallSession"> | Date | string
  }

  export type TrainingSampleUpsertWithWhereUniqueWithoutUserInput = {
    where: TrainingSampleWhereUniqueInput
    update: XOR<TrainingSampleUpdateWithoutUserInput, TrainingSampleUncheckedUpdateWithoutUserInput>
    create: XOR<TrainingSampleCreateWithoutUserInput, TrainingSampleUncheckedCreateWithoutUserInput>
  }

  export type TrainingSampleUpdateWithWhereUniqueWithoutUserInput = {
    where: TrainingSampleWhereUniqueInput
    data: XOR<TrainingSampleUpdateWithoutUserInput, TrainingSampleUncheckedUpdateWithoutUserInput>
  }

  export type TrainingSampleUpdateManyWithWhereWithoutUserInput = {
    where: TrainingSampleScalarWhereInput
    data: XOR<TrainingSampleUpdateManyMutationInput, TrainingSampleUncheckedUpdateManyWithoutUserInput>
  }

  export type TrainingSampleScalarWhereInput = {
    AND?: TrainingSampleScalarWhereInput | TrainingSampleScalarWhereInput[]
    OR?: TrainingSampleScalarWhereInput[]
    NOT?: TrainingSampleScalarWhereInput | TrainingSampleScalarWhereInput[]
    id?: StringFilter<"TrainingSample"> | string
    userId?: StringFilter<"TrainingSample"> | string
    voiceModelId?: StringNullableFilter<"TrainingSample"> | string | null
    filename?: StringFilter<"TrainingSample"> | string
    originalName?: StringFilter<"TrainingSample"> | string
    fileSize?: IntFilter<"TrainingSample"> | number
    duration?: FloatNullableFilter<"TrainingSample"> | number | null
    mimeType?: StringFilter<"TrainingSample"> | string
    createdAt?: DateTimeFilter<"TrainingSample"> | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    callSummaries?: BoolFieldUpdateOperationsInput | boolean
    weeklyReports?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackMessage?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    callSummaries?: BoolFieldUpdateOperationsInput | boolean
    weeklyReports?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackMessage?: NullableStringFieldUpdateOperationsInput | string | null
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    type?: EnumApiKeyTypeFilter<"ApiKey"> | $Enums.ApiKeyType
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelCreateNestedManyWithoutUserInput
    callSessions?: CallSessionCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelUncheckedCreateNestedManyWithoutUserInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUpdateManyWithoutUserNestedInput
    callSessions?: CallSessionUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUncheckedUpdateManyWithoutUserNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelCreateNestedManyWithoutUserInput
    callSessions?: CallSessionCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelUncheckedCreateNestedManyWithoutUserInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUpdateManyWithoutUserNestedInput
    callSessions?: CallSessionUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUncheckedUpdateManyWithoutUserNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutVoiceModelsInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    callSessions?: CallSessionCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVoiceModelsInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVoiceModelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoiceModelsInput, UserUncheckedCreateWithoutVoiceModelsInput>
  }

  export type TrainingSampleCreateWithoutVoiceModelInput = {
    id?: string
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrainingSamplesInput
  }

  export type TrainingSampleUncheckedCreateWithoutVoiceModelInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
  }

  export type TrainingSampleCreateOrConnectWithoutVoiceModelInput = {
    where: TrainingSampleWhereUniqueInput
    create: XOR<TrainingSampleCreateWithoutVoiceModelInput, TrainingSampleUncheckedCreateWithoutVoiceModelInput>
  }

  export type TrainingSampleCreateManyVoiceModelInputEnvelope = {
    data: TrainingSampleCreateManyVoiceModelInput | TrainingSampleCreateManyVoiceModelInput[]
    skipDuplicates?: boolean
  }

  export type CallSessionCreateWithoutVoiceModelInput = {
    id?: string
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCallSessionsInput
    transcript?: TranscriptMessageCreateNestedManyWithoutCallSessionInput
    summary?: CallSummaryCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionUncheckedCreateWithoutVoiceModelInput = {
    id?: string
    userId: string
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: TranscriptMessageUncheckedCreateNestedManyWithoutCallSessionInput
    summary?: CallSummaryUncheckedCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionCreateOrConnectWithoutVoiceModelInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutVoiceModelInput, CallSessionUncheckedCreateWithoutVoiceModelInput>
  }

  export type CallSessionCreateManyVoiceModelInputEnvelope = {
    data: CallSessionCreateManyVoiceModelInput | CallSessionCreateManyVoiceModelInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVoiceModelsInput = {
    update: XOR<UserUpdateWithoutVoiceModelsInput, UserUncheckedUpdateWithoutVoiceModelsInput>
    create: XOR<UserCreateWithoutVoiceModelsInput, UserUncheckedCreateWithoutVoiceModelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoiceModelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoiceModelsInput, UserUncheckedUpdateWithoutVoiceModelsInput>
  }

  export type UserUpdateWithoutVoiceModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSessions?: CallSessionUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVoiceModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSessions?: CallSessionUncheckedUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingSampleUpsertWithWhereUniqueWithoutVoiceModelInput = {
    where: TrainingSampleWhereUniqueInput
    update: XOR<TrainingSampleUpdateWithoutVoiceModelInput, TrainingSampleUncheckedUpdateWithoutVoiceModelInput>
    create: XOR<TrainingSampleCreateWithoutVoiceModelInput, TrainingSampleUncheckedCreateWithoutVoiceModelInput>
  }

  export type TrainingSampleUpdateWithWhereUniqueWithoutVoiceModelInput = {
    where: TrainingSampleWhereUniqueInput
    data: XOR<TrainingSampleUpdateWithoutVoiceModelInput, TrainingSampleUncheckedUpdateWithoutVoiceModelInput>
  }

  export type TrainingSampleUpdateManyWithWhereWithoutVoiceModelInput = {
    where: TrainingSampleScalarWhereInput
    data: XOR<TrainingSampleUpdateManyMutationInput, TrainingSampleUncheckedUpdateManyWithoutVoiceModelInput>
  }

  export type CallSessionUpsertWithWhereUniqueWithoutVoiceModelInput = {
    where: CallSessionWhereUniqueInput
    update: XOR<CallSessionUpdateWithoutVoiceModelInput, CallSessionUncheckedUpdateWithoutVoiceModelInput>
    create: XOR<CallSessionCreateWithoutVoiceModelInput, CallSessionUncheckedCreateWithoutVoiceModelInput>
  }

  export type CallSessionUpdateWithWhereUniqueWithoutVoiceModelInput = {
    where: CallSessionWhereUniqueInput
    data: XOR<CallSessionUpdateWithoutVoiceModelInput, CallSessionUncheckedUpdateWithoutVoiceModelInput>
  }

  export type CallSessionUpdateManyWithWhereWithoutVoiceModelInput = {
    where: CallSessionScalarWhereInput
    data: XOR<CallSessionUpdateManyMutationInput, CallSessionUncheckedUpdateManyWithoutVoiceModelInput>
  }

  export type UserCreateWithoutTrainingSamplesInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelCreateNestedManyWithoutUserInput
    callSessions?: CallSessionCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTrainingSamplesInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelUncheckedCreateNestedManyWithoutUserInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTrainingSamplesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainingSamplesInput, UserUncheckedCreateWithoutTrainingSamplesInput>
  }

  export type VoiceModelCreateWithoutSamplesInput = {
    id?: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVoiceModelsInput
    callSessions?: CallSessionCreateNestedManyWithoutVoiceModelInput
  }

  export type VoiceModelUncheckedCreateWithoutSamplesInput = {
    id?: string
    userId: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutVoiceModelInput
  }

  export type VoiceModelCreateOrConnectWithoutSamplesInput = {
    where: VoiceModelWhereUniqueInput
    create: XOR<VoiceModelCreateWithoutSamplesInput, VoiceModelUncheckedCreateWithoutSamplesInput>
  }

  export type UserUpsertWithoutTrainingSamplesInput = {
    update: XOR<UserUpdateWithoutTrainingSamplesInput, UserUncheckedUpdateWithoutTrainingSamplesInput>
    create: XOR<UserCreateWithoutTrainingSamplesInput, UserUncheckedCreateWithoutTrainingSamplesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainingSamplesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainingSamplesInput, UserUncheckedUpdateWithoutTrainingSamplesInput>
  }

  export type UserUpdateWithoutTrainingSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUpdateManyWithoutUserNestedInput
    callSessions?: CallSessionUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainingSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUncheckedUpdateManyWithoutUserNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoiceModelUpsertWithoutSamplesInput = {
    update: XOR<VoiceModelUpdateWithoutSamplesInput, VoiceModelUncheckedUpdateWithoutSamplesInput>
    create: XOR<VoiceModelCreateWithoutSamplesInput, VoiceModelUncheckedCreateWithoutSamplesInput>
    where?: VoiceModelWhereInput
  }

  export type VoiceModelUpdateToOneWithWhereWithoutSamplesInput = {
    where?: VoiceModelWhereInput
    data: XOR<VoiceModelUpdateWithoutSamplesInput, VoiceModelUncheckedUpdateWithoutSamplesInput>
  }

  export type VoiceModelUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVoiceModelsNestedInput
    callSessions?: CallSessionUpdateManyWithoutVoiceModelNestedInput
  }

  export type VoiceModelUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSessions?: CallSessionUncheckedUpdateManyWithoutVoiceModelNestedInput
  }

  export type UserCreateWithoutCallSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCallSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    company?: string | null
    phone?: string | null
    plan?: $Enums.Plan
    createdAt?: Date | string
    updatedAt?: Date | string
    voiceModels?: VoiceModelUncheckedCreateNestedManyWithoutUserInput
    trainingSamples?: TrainingSampleUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCallSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCallSessionsInput, UserUncheckedCreateWithoutCallSessionsInput>
  }

  export type VoiceModelCreateWithoutCallSessionsInput = {
    id?: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVoiceModelsInput
    samples?: TrainingSampleCreateNestedManyWithoutVoiceModelInput
  }

  export type VoiceModelUncheckedCreateWithoutCallSessionsInput = {
    id?: string
    userId: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: TrainingSampleUncheckedCreateNestedManyWithoutVoiceModelInput
  }

  export type VoiceModelCreateOrConnectWithoutCallSessionsInput = {
    where: VoiceModelWhereUniqueInput
    create: XOR<VoiceModelCreateWithoutCallSessionsInput, VoiceModelUncheckedCreateWithoutCallSessionsInput>
  }

  export type TranscriptMessageCreateWithoutCallSessionInput = {
    id?: string
    speaker: $Enums.Speaker
    text: string
    confidence?: number | null
    timestamp?: Date | string
  }

  export type TranscriptMessageUncheckedCreateWithoutCallSessionInput = {
    id?: string
    speaker: $Enums.Speaker
    text: string
    confidence?: number | null
    timestamp?: Date | string
  }

  export type TranscriptMessageCreateOrConnectWithoutCallSessionInput = {
    where: TranscriptMessageWhereUniqueInput
    create: XOR<TranscriptMessageCreateWithoutCallSessionInput, TranscriptMessageUncheckedCreateWithoutCallSessionInput>
  }

  export type TranscriptMessageCreateManyCallSessionInputEnvelope = {
    data: TranscriptMessageCreateManyCallSessionInput | TranscriptMessageCreateManyCallSessionInput[]
    skipDuplicates?: boolean
  }

  export type CallSummaryCreateWithoutCallSessionInput = {
    id?: string
    summary: string
    actionItems?: CallSummaryCreateactionItemsInput | string[]
    keyPoints?: CallSummaryCreatekeyPointsInput | string[]
    createdAt?: Date | string
  }

  export type CallSummaryUncheckedCreateWithoutCallSessionInput = {
    id?: string
    summary: string
    actionItems?: CallSummaryCreateactionItemsInput | string[]
    keyPoints?: CallSummaryCreatekeyPointsInput | string[]
    createdAt?: Date | string
  }

  export type CallSummaryCreateOrConnectWithoutCallSessionInput = {
    where: CallSummaryWhereUniqueInput
    create: XOR<CallSummaryCreateWithoutCallSessionInput, CallSummaryUncheckedCreateWithoutCallSessionInput>
  }

  export type UserUpsertWithoutCallSessionsInput = {
    update: XOR<UserUpdateWithoutCallSessionsInput, UserUncheckedUpdateWithoutCallSessionsInput>
    create: XOR<UserCreateWithoutCallSessionsInput, UserUncheckedCreateWithoutCallSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCallSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCallSessionsInput, UserUncheckedUpdateWithoutCallSessionsInput>
  }

  export type UserUpdateWithoutCallSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCallSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumPlanFieldUpdateOperationsInput | $Enums.Plan
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModels?: VoiceModelUncheckedUpdateManyWithoutUserNestedInput
    trainingSamples?: TrainingSampleUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoiceModelUpsertWithoutCallSessionsInput = {
    update: XOR<VoiceModelUpdateWithoutCallSessionsInput, VoiceModelUncheckedUpdateWithoutCallSessionsInput>
    create: XOR<VoiceModelCreateWithoutCallSessionsInput, VoiceModelUncheckedCreateWithoutCallSessionsInput>
    where?: VoiceModelWhereInput
  }

  export type VoiceModelUpdateToOneWithWhereWithoutCallSessionsInput = {
    where?: VoiceModelWhereInput
    data: XOR<VoiceModelUpdateWithoutCallSessionsInput, VoiceModelUncheckedUpdateWithoutCallSessionsInput>
  }

  export type VoiceModelUpdateWithoutCallSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVoiceModelsNestedInput
    samples?: TrainingSampleUpdateManyWithoutVoiceModelNestedInput
  }

  export type VoiceModelUncheckedUpdateWithoutCallSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: TrainingSampleUncheckedUpdateManyWithoutVoiceModelNestedInput
  }

  export type TranscriptMessageUpsertWithWhereUniqueWithoutCallSessionInput = {
    where: TranscriptMessageWhereUniqueInput
    update: XOR<TranscriptMessageUpdateWithoutCallSessionInput, TranscriptMessageUncheckedUpdateWithoutCallSessionInput>
    create: XOR<TranscriptMessageCreateWithoutCallSessionInput, TranscriptMessageUncheckedCreateWithoutCallSessionInput>
  }

  export type TranscriptMessageUpdateWithWhereUniqueWithoutCallSessionInput = {
    where: TranscriptMessageWhereUniqueInput
    data: XOR<TranscriptMessageUpdateWithoutCallSessionInput, TranscriptMessageUncheckedUpdateWithoutCallSessionInput>
  }

  export type TranscriptMessageUpdateManyWithWhereWithoutCallSessionInput = {
    where: TranscriptMessageScalarWhereInput
    data: XOR<TranscriptMessageUpdateManyMutationInput, TranscriptMessageUncheckedUpdateManyWithoutCallSessionInput>
  }

  export type TranscriptMessageScalarWhereInput = {
    AND?: TranscriptMessageScalarWhereInput | TranscriptMessageScalarWhereInput[]
    OR?: TranscriptMessageScalarWhereInput[]
    NOT?: TranscriptMessageScalarWhereInput | TranscriptMessageScalarWhereInput[]
    id?: StringFilter<"TranscriptMessage"> | string
    callSessionId?: StringFilter<"TranscriptMessage"> | string
    speaker?: EnumSpeakerFilter<"TranscriptMessage"> | $Enums.Speaker
    text?: StringFilter<"TranscriptMessage"> | string
    confidence?: FloatNullableFilter<"TranscriptMessage"> | number | null
    timestamp?: DateTimeFilter<"TranscriptMessage"> | Date | string
  }

  export type CallSummaryUpsertWithoutCallSessionInput = {
    update: XOR<CallSummaryUpdateWithoutCallSessionInput, CallSummaryUncheckedUpdateWithoutCallSessionInput>
    create: XOR<CallSummaryCreateWithoutCallSessionInput, CallSummaryUncheckedCreateWithoutCallSessionInput>
    where?: CallSummaryWhereInput
  }

  export type CallSummaryUpdateToOneWithWhereWithoutCallSessionInput = {
    where?: CallSummaryWhereInput
    data: XOR<CallSummaryUpdateWithoutCallSessionInput, CallSummaryUncheckedUpdateWithoutCallSessionInput>
  }

  export type CallSummaryUpdateWithoutCallSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    actionItems?: CallSummaryUpdateactionItemsInput | string[]
    keyPoints?: CallSummaryUpdatekeyPointsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSummaryUncheckedUpdateWithoutCallSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    actionItems?: CallSummaryUpdateactionItemsInput | string[]
    keyPoints?: CallSummaryUpdatekeyPointsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionCreateWithoutTranscriptInput = {
    id?: string
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCallSessionsInput
    voiceModel?: VoiceModelCreateNestedOneWithoutCallSessionsInput
    summary?: CallSummaryCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionUncheckedCreateWithoutTranscriptInput = {
    id?: string
    userId: string
    voiceModelId?: string | null
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    summary?: CallSummaryUncheckedCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionCreateOrConnectWithoutTranscriptInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutTranscriptInput, CallSessionUncheckedCreateWithoutTranscriptInput>
  }

  export type CallSessionUpsertWithoutTranscriptInput = {
    update: XOR<CallSessionUpdateWithoutTranscriptInput, CallSessionUncheckedUpdateWithoutTranscriptInput>
    create: XOR<CallSessionCreateWithoutTranscriptInput, CallSessionUncheckedCreateWithoutTranscriptInput>
    where?: CallSessionWhereInput
  }

  export type CallSessionUpdateToOneWithWhereWithoutTranscriptInput = {
    where?: CallSessionWhereInput
    data: XOR<CallSessionUpdateWithoutTranscriptInput, CallSessionUncheckedUpdateWithoutTranscriptInput>
  }

  export type CallSessionUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCallSessionsNestedInput
    voiceModel?: VoiceModelUpdateOneWithoutCallSessionsNestedInput
    summary?: CallSummaryUpdateOneWithoutCallSessionNestedInput
  }

  export type CallSessionUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: CallSummaryUncheckedUpdateOneWithoutCallSessionNestedInput
  }

  export type CallSessionCreateWithoutSummaryInput = {
    id?: string
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCallSessionsInput
    voiceModel?: VoiceModelCreateNestedOneWithoutCallSessionsInput
    transcript?: TranscriptMessageCreateNestedManyWithoutCallSessionInput
  }

  export type CallSessionUncheckedCreateWithoutSummaryInput = {
    id?: string
    userId: string
    voiceModelId?: string | null
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: TranscriptMessageUncheckedCreateNestedManyWithoutCallSessionInput
  }

  export type CallSessionCreateOrConnectWithoutSummaryInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutSummaryInput, CallSessionUncheckedCreateWithoutSummaryInput>
  }

  export type CallSessionUpsertWithoutSummaryInput = {
    update: XOR<CallSessionUpdateWithoutSummaryInput, CallSessionUncheckedUpdateWithoutSummaryInput>
    create: XOR<CallSessionCreateWithoutSummaryInput, CallSessionUncheckedCreateWithoutSummaryInput>
    where?: CallSessionWhereInput
  }

  export type CallSessionUpdateToOneWithWhereWithoutSummaryInput = {
    where?: CallSessionWhereInput
    data: XOR<CallSessionUpdateWithoutSummaryInput, CallSessionUncheckedUpdateWithoutSummaryInput>
  }

  export type CallSessionUpdateWithoutSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCallSessionsNestedInput
    voiceModel?: VoiceModelUpdateOneWithoutCallSessionsNestedInput
    transcript?: TranscriptMessageUpdateManyWithoutCallSessionNestedInput
  }

  export type CallSessionUncheckedUpdateWithoutSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: TranscriptMessageUncheckedUpdateManyWithoutCallSessionNestedInput
  }

  export type InboundCallCreateWithoutBusinessInput = {
    id?: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.InboundCallStatus
    duration?: number | null
    waitTime?: number | null
    routedTo?: string | null
    routingRuleId?: string | null
    transcript?: string | null
    summary?: string | null
    sentiment?: $Enums.Sentiment | null
    tags?: InboundCallCreatetagsInput | string[]
    externalCallId?: string | null
    recordingUrl?: string | null
    startedAt?: Date | string
    answeredAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InboundCallUncheckedCreateWithoutBusinessInput = {
    id?: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.InboundCallStatus
    duration?: number | null
    waitTime?: number | null
    routedTo?: string | null
    routingRuleId?: string | null
    transcript?: string | null
    summary?: string | null
    sentiment?: $Enums.Sentiment | null
    tags?: InboundCallCreatetagsInput | string[]
    externalCallId?: string | null
    recordingUrl?: string | null
    startedAt?: Date | string
    answeredAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InboundCallCreateOrConnectWithoutBusinessInput = {
    where: InboundCallWhereUniqueInput
    create: XOR<InboundCallCreateWithoutBusinessInput, InboundCallUncheckedCreateWithoutBusinessInput>
  }

  export type InboundCallCreateManyBusinessInputEnvelope = {
    data: InboundCallCreateManyBusinessInput | InboundCallCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type OutboundCallCreateWithoutBusinessInput = {
    id?: string
    recipientNumber: string
    recipientName?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: OutboundCampaignCreateNestedOneWithoutCallsInput
  }

  export type OutboundCallUncheckedCreateWithoutBusinessInput = {
    id?: string
    recipientNumber: string
    recipientName?: string | null
    campaignId?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundCallCreateOrConnectWithoutBusinessInput = {
    where: OutboundCallWhereUniqueInput
    create: XOR<OutboundCallCreateWithoutBusinessInput, OutboundCallUncheckedCreateWithoutBusinessInput>
  }

  export type OutboundCallCreateManyBusinessInputEnvelope = {
    data: OutboundCallCreateManyBusinessInput | OutboundCallCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type CallRoutingRuleCreateWithoutBusinessInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    conditionType: $Enums.ConditionType
    conditionValue: JsonNullValueInput | InputJsonValue
    actionType: $Enums.ActionType
    actionConfig: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRoutingRuleUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    conditionType: $Enums.ConditionType
    conditionValue: JsonNullValueInput | InputJsonValue
    actionType: $Enums.ActionType
    actionConfig: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRoutingRuleCreateOrConnectWithoutBusinessInput = {
    where: CallRoutingRuleWhereUniqueInput
    create: XOR<CallRoutingRuleCreateWithoutBusinessInput, CallRoutingRuleUncheckedCreateWithoutBusinessInput>
  }

  export type CallRoutingRuleCreateManyBusinessInputEnvelope = {
    data: CallRoutingRuleCreateManyBusinessInput | CallRoutingRuleCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type OutboundCampaignCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    scriptTemplate: string
    voiceId?: string | null
    contactList: JsonNullValueInput | InputJsonValue
    totalContacts?: number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    callsPerMinute?: number
    maxConcurrent?: number
    status?: $Enums.CampaignStatus
    completedCalls?: number
    answeredCalls?: number
    voicemailCalls?: number
    failedCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    calls?: OutboundCallCreateNestedManyWithoutCampaignInput
  }

  export type OutboundCampaignUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    scriptTemplate: string
    voiceId?: string | null
    contactList: JsonNullValueInput | InputJsonValue
    totalContacts?: number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    callsPerMinute?: number
    maxConcurrent?: number
    status?: $Enums.CampaignStatus
    completedCalls?: number
    answeredCalls?: number
    voicemailCalls?: number
    failedCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    calls?: OutboundCallUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type OutboundCampaignCreateOrConnectWithoutBusinessInput = {
    where: OutboundCampaignWhereUniqueInput
    create: XOR<OutboundCampaignCreateWithoutBusinessInput, OutboundCampaignUncheckedCreateWithoutBusinessInput>
  }

  export type OutboundCampaignCreateManyBusinessInputEnvelope = {
    data: OutboundCampaignCreateManyBusinessInput | OutboundCampaignCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type CallQueueCreateWithoutBusinessInput = {
    id?: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.QueueStatus
    position: number
    priority?: number
    estimatedWait?: number | null
    actualWait?: number | null
    externalCallId?: string | null
    enteredAt?: Date | string
    servedAt?: Date | string | null
  }

  export type CallQueueUncheckedCreateWithoutBusinessInput = {
    id?: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.QueueStatus
    position: number
    priority?: number
    estimatedWait?: number | null
    actualWait?: number | null
    externalCallId?: string | null
    enteredAt?: Date | string
    servedAt?: Date | string | null
  }

  export type CallQueueCreateOrConnectWithoutBusinessInput = {
    where: CallQueueWhereUniqueInput
    create: XOR<CallQueueCreateWithoutBusinessInput, CallQueueUncheckedCreateWithoutBusinessInput>
  }

  export type CallQueueCreateManyBusinessInputEnvelope = {
    data: CallQueueCreateManyBusinessInput | CallQueueCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type InboundCallUpsertWithWhereUniqueWithoutBusinessInput = {
    where: InboundCallWhereUniqueInput
    update: XOR<InboundCallUpdateWithoutBusinessInput, InboundCallUncheckedUpdateWithoutBusinessInput>
    create: XOR<InboundCallCreateWithoutBusinessInput, InboundCallUncheckedCreateWithoutBusinessInput>
  }

  export type InboundCallUpdateWithWhereUniqueWithoutBusinessInput = {
    where: InboundCallWhereUniqueInput
    data: XOR<InboundCallUpdateWithoutBusinessInput, InboundCallUncheckedUpdateWithoutBusinessInput>
  }

  export type InboundCallUpdateManyWithWhereWithoutBusinessInput = {
    where: InboundCallScalarWhereInput
    data: XOR<InboundCallUpdateManyMutationInput, InboundCallUncheckedUpdateManyWithoutBusinessInput>
  }

  export type InboundCallScalarWhereInput = {
    AND?: InboundCallScalarWhereInput | InboundCallScalarWhereInput[]
    OR?: InboundCallScalarWhereInput[]
    NOT?: InboundCallScalarWhereInput | InboundCallScalarWhereInput[]
    id?: StringFilter<"InboundCall"> | string
    businessId?: StringFilter<"InboundCall"> | string
    callerNumber?: StringFilter<"InboundCall"> | string
    callerName?: StringNullableFilter<"InboundCall"> | string | null
    status?: EnumInboundCallStatusFilter<"InboundCall"> | $Enums.InboundCallStatus
    duration?: IntNullableFilter<"InboundCall"> | number | null
    waitTime?: IntNullableFilter<"InboundCall"> | number | null
    routedTo?: StringNullableFilter<"InboundCall"> | string | null
    routingRuleId?: StringNullableFilter<"InboundCall"> | string | null
    transcript?: StringNullableFilter<"InboundCall"> | string | null
    summary?: StringNullableFilter<"InboundCall"> | string | null
    sentiment?: EnumSentimentNullableFilter<"InboundCall"> | $Enums.Sentiment | null
    tags?: StringNullableListFilter<"InboundCall">
    externalCallId?: StringNullableFilter<"InboundCall"> | string | null
    recordingUrl?: StringNullableFilter<"InboundCall"> | string | null
    startedAt?: DateTimeFilter<"InboundCall"> | Date | string
    answeredAt?: DateTimeNullableFilter<"InboundCall"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"InboundCall"> | Date | string | null
    createdAt?: DateTimeFilter<"InboundCall"> | Date | string
    updatedAt?: DateTimeFilter<"InboundCall"> | Date | string
  }

  export type OutboundCallUpsertWithWhereUniqueWithoutBusinessInput = {
    where: OutboundCallWhereUniqueInput
    update: XOR<OutboundCallUpdateWithoutBusinessInput, OutboundCallUncheckedUpdateWithoutBusinessInput>
    create: XOR<OutboundCallCreateWithoutBusinessInput, OutboundCallUncheckedCreateWithoutBusinessInput>
  }

  export type OutboundCallUpdateWithWhereUniqueWithoutBusinessInput = {
    where: OutboundCallWhereUniqueInput
    data: XOR<OutboundCallUpdateWithoutBusinessInput, OutboundCallUncheckedUpdateWithoutBusinessInput>
  }

  export type OutboundCallUpdateManyWithWhereWithoutBusinessInput = {
    where: OutboundCallScalarWhereInput
    data: XOR<OutboundCallUpdateManyMutationInput, OutboundCallUncheckedUpdateManyWithoutBusinessInput>
  }

  export type OutboundCallScalarWhereInput = {
    AND?: OutboundCallScalarWhereInput | OutboundCallScalarWhereInput[]
    OR?: OutboundCallScalarWhereInput[]
    NOT?: OutboundCallScalarWhereInput | OutboundCallScalarWhereInput[]
    id?: StringFilter<"OutboundCall"> | string
    businessId?: StringFilter<"OutboundCall"> | string
    recipientNumber?: StringFilter<"OutboundCall"> | string
    recipientName?: StringNullableFilter<"OutboundCall"> | string | null
    campaignId?: StringNullableFilter<"OutboundCall"> | string | null
    status?: EnumOutboundCallStatusFilter<"OutboundCall"> | $Enums.OutboundCallStatus
    result?: EnumCallResultNullableFilter<"OutboundCall"> | $Enums.CallResult | null
    duration?: IntNullableFilter<"OutboundCall"> | number | null
    attempts?: IntFilter<"OutboundCall"> | number
    maxAttempts?: IntFilter<"OutboundCall"> | number
    scriptUsed?: StringNullableFilter<"OutboundCall"> | string | null
    transcript?: StringNullableFilter<"OutboundCall"> | string | null
    notes?: StringNullableFilter<"OutboundCall"> | string | null
    scheduledAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"OutboundCall"> | Date | string | null
    externalCallId?: StringNullableFilter<"OutboundCall"> | string | null
    recordingUrl?: StringNullableFilter<"OutboundCall"> | string | null
    isCallback?: BoolFilter<"OutboundCall"> | boolean
    callbackReason?: StringNullableFilter<"OutboundCall"> | string | null
    createdAt?: DateTimeFilter<"OutboundCall"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundCall"> | Date | string
  }

  export type CallRoutingRuleUpsertWithWhereUniqueWithoutBusinessInput = {
    where: CallRoutingRuleWhereUniqueInput
    update: XOR<CallRoutingRuleUpdateWithoutBusinessInput, CallRoutingRuleUncheckedUpdateWithoutBusinessInput>
    create: XOR<CallRoutingRuleCreateWithoutBusinessInput, CallRoutingRuleUncheckedCreateWithoutBusinessInput>
  }

  export type CallRoutingRuleUpdateWithWhereUniqueWithoutBusinessInput = {
    where: CallRoutingRuleWhereUniqueInput
    data: XOR<CallRoutingRuleUpdateWithoutBusinessInput, CallRoutingRuleUncheckedUpdateWithoutBusinessInput>
  }

  export type CallRoutingRuleUpdateManyWithWhereWithoutBusinessInput = {
    where: CallRoutingRuleScalarWhereInput
    data: XOR<CallRoutingRuleUpdateManyMutationInput, CallRoutingRuleUncheckedUpdateManyWithoutBusinessInput>
  }

  export type CallRoutingRuleScalarWhereInput = {
    AND?: CallRoutingRuleScalarWhereInput | CallRoutingRuleScalarWhereInput[]
    OR?: CallRoutingRuleScalarWhereInput[]
    NOT?: CallRoutingRuleScalarWhereInput | CallRoutingRuleScalarWhereInput[]
    id?: StringFilter<"CallRoutingRule"> | string
    businessId?: StringFilter<"CallRoutingRule"> | string
    name?: StringFilter<"CallRoutingRule"> | string
    priority?: IntFilter<"CallRoutingRule"> | number
    isActive?: BoolFilter<"CallRoutingRule"> | boolean
    conditionType?: EnumConditionTypeFilter<"CallRoutingRule"> | $Enums.ConditionType
    conditionValue?: JsonFilter<"CallRoutingRule">
    actionType?: EnumActionTypeFilter<"CallRoutingRule"> | $Enums.ActionType
    actionConfig?: JsonFilter<"CallRoutingRule">
    createdAt?: DateTimeFilter<"CallRoutingRule"> | Date | string
    updatedAt?: DateTimeFilter<"CallRoutingRule"> | Date | string
  }

  export type OutboundCampaignUpsertWithWhereUniqueWithoutBusinessInput = {
    where: OutboundCampaignWhereUniqueInput
    update: XOR<OutboundCampaignUpdateWithoutBusinessInput, OutboundCampaignUncheckedUpdateWithoutBusinessInput>
    create: XOR<OutboundCampaignCreateWithoutBusinessInput, OutboundCampaignUncheckedCreateWithoutBusinessInput>
  }

  export type OutboundCampaignUpdateWithWhereUniqueWithoutBusinessInput = {
    where: OutboundCampaignWhereUniqueInput
    data: XOR<OutboundCampaignUpdateWithoutBusinessInput, OutboundCampaignUncheckedUpdateWithoutBusinessInput>
  }

  export type OutboundCampaignUpdateManyWithWhereWithoutBusinessInput = {
    where: OutboundCampaignScalarWhereInput
    data: XOR<OutboundCampaignUpdateManyMutationInput, OutboundCampaignUncheckedUpdateManyWithoutBusinessInput>
  }

  export type OutboundCampaignScalarWhereInput = {
    AND?: OutboundCampaignScalarWhereInput | OutboundCampaignScalarWhereInput[]
    OR?: OutboundCampaignScalarWhereInput[]
    NOT?: OutboundCampaignScalarWhereInput | OutboundCampaignScalarWhereInput[]
    id?: StringFilter<"OutboundCampaign"> | string
    businessId?: StringFilter<"OutboundCampaign"> | string
    name?: StringFilter<"OutboundCampaign"> | string
    description?: StringNullableFilter<"OutboundCampaign"> | string | null
    scriptTemplate?: StringFilter<"OutboundCampaign"> | string
    voiceId?: StringNullableFilter<"OutboundCampaign"> | string | null
    contactList?: JsonFilter<"OutboundCampaign">
    totalContacts?: IntFilter<"OutboundCampaign"> | number
    scheduleConfig?: JsonNullableFilter<"OutboundCampaign">
    startDate?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    callsPerMinute?: IntFilter<"OutboundCampaign"> | number
    maxConcurrent?: IntFilter<"OutboundCampaign"> | number
    status?: EnumCampaignStatusFilter<"OutboundCampaign"> | $Enums.CampaignStatus
    completedCalls?: IntFilter<"OutboundCampaign"> | number
    answeredCalls?: IntFilter<"OutboundCampaign"> | number
    voicemailCalls?: IntFilter<"OutboundCampaign"> | number
    failedCalls?: IntFilter<"OutboundCampaign"> | number
    createdAt?: DateTimeFilter<"OutboundCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"OutboundCampaign"> | Date | string
    startedAt?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"OutboundCampaign"> | Date | string | null
  }

  export type CallQueueUpsertWithWhereUniqueWithoutBusinessInput = {
    where: CallQueueWhereUniqueInput
    update: XOR<CallQueueUpdateWithoutBusinessInput, CallQueueUncheckedUpdateWithoutBusinessInput>
    create: XOR<CallQueueCreateWithoutBusinessInput, CallQueueUncheckedCreateWithoutBusinessInput>
  }

  export type CallQueueUpdateWithWhereUniqueWithoutBusinessInput = {
    where: CallQueueWhereUniqueInput
    data: XOR<CallQueueUpdateWithoutBusinessInput, CallQueueUncheckedUpdateWithoutBusinessInput>
  }

  export type CallQueueUpdateManyWithWhereWithoutBusinessInput = {
    where: CallQueueScalarWhereInput
    data: XOR<CallQueueUpdateManyMutationInput, CallQueueUncheckedUpdateManyWithoutBusinessInput>
  }

  export type CallQueueScalarWhereInput = {
    AND?: CallQueueScalarWhereInput | CallQueueScalarWhereInput[]
    OR?: CallQueueScalarWhereInput[]
    NOT?: CallQueueScalarWhereInput | CallQueueScalarWhereInput[]
    id?: StringFilter<"CallQueue"> | string
    businessId?: StringFilter<"CallQueue"> | string
    callerNumber?: StringFilter<"CallQueue"> | string
    callerName?: StringNullableFilter<"CallQueue"> | string | null
    status?: EnumQueueStatusFilter<"CallQueue"> | $Enums.QueueStatus
    position?: IntFilter<"CallQueue"> | number
    priority?: IntFilter<"CallQueue"> | number
    estimatedWait?: IntNullableFilter<"CallQueue"> | number | null
    actualWait?: IntNullableFilter<"CallQueue"> | number | null
    externalCallId?: StringNullableFilter<"CallQueue"> | string | null
    enteredAt?: DateTimeFilter<"CallQueue"> | Date | string
    servedAt?: DateTimeNullableFilter<"CallQueue"> | Date | string | null
  }

  export type BusinessCreateWithoutInboundCallsInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outboundCalls?: OutboundCallCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutInboundCallsInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outboundCalls?: OutboundCallUncheckedCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleUncheckedCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignUncheckedCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutInboundCallsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutInboundCallsInput, BusinessUncheckedCreateWithoutInboundCallsInput>
  }

  export type BusinessUpsertWithoutInboundCallsInput = {
    update: XOR<BusinessUpdateWithoutInboundCallsInput, BusinessUncheckedUpdateWithoutInboundCallsInput>
    create: XOR<BusinessCreateWithoutInboundCallsInput, BusinessUncheckedCreateWithoutInboundCallsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutInboundCallsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutInboundCallsInput, BusinessUncheckedUpdateWithoutInboundCallsInput>
  }

  export type BusinessUpdateWithoutInboundCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outboundCalls?: OutboundCallUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutInboundCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outboundCalls?: OutboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUncheckedUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUncheckedUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateWithoutOutboundCallsInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutOutboundCallsInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallUncheckedCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleUncheckedCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignUncheckedCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutOutboundCallsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutOutboundCallsInput, BusinessUncheckedCreateWithoutOutboundCallsInput>
  }

  export type OutboundCampaignCreateWithoutCallsInput = {
    id?: string
    name: string
    description?: string | null
    scriptTemplate: string
    voiceId?: string | null
    contactList: JsonNullValueInput | InputJsonValue
    totalContacts?: number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    callsPerMinute?: number
    maxConcurrent?: number
    status?: $Enums.CampaignStatus
    completedCalls?: number
    answeredCalls?: number
    voicemailCalls?: number
    failedCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutCampaignsInput
  }

  export type OutboundCampaignUncheckedCreateWithoutCallsInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    scriptTemplate: string
    voiceId?: string | null
    contactList: JsonNullValueInput | InputJsonValue
    totalContacts?: number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    callsPerMinute?: number
    maxConcurrent?: number
    status?: $Enums.CampaignStatus
    completedCalls?: number
    answeredCalls?: number
    voicemailCalls?: number
    failedCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type OutboundCampaignCreateOrConnectWithoutCallsInput = {
    where: OutboundCampaignWhereUniqueInput
    create: XOR<OutboundCampaignCreateWithoutCallsInput, OutboundCampaignUncheckedCreateWithoutCallsInput>
  }

  export type BusinessUpsertWithoutOutboundCallsInput = {
    update: XOR<BusinessUpdateWithoutOutboundCallsInput, BusinessUncheckedUpdateWithoutOutboundCallsInput>
    create: XOR<BusinessCreateWithoutOutboundCallsInput, BusinessUncheckedCreateWithoutOutboundCallsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutOutboundCallsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutOutboundCallsInput, BusinessUncheckedUpdateWithoutOutboundCallsInput>
  }

  export type BusinessUpdateWithoutOutboundCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutOutboundCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUncheckedUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUncheckedUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type OutboundCampaignUpsertWithoutCallsInput = {
    update: XOR<OutboundCampaignUpdateWithoutCallsInput, OutboundCampaignUncheckedUpdateWithoutCallsInput>
    create: XOR<OutboundCampaignCreateWithoutCallsInput, OutboundCampaignUncheckedCreateWithoutCallsInput>
    where?: OutboundCampaignWhereInput
  }

  export type OutboundCampaignUpdateToOneWithWhereWithoutCallsInput = {
    where?: OutboundCampaignWhereInput
    data: XOR<OutboundCampaignUpdateWithoutCallsInput, OutboundCampaignUncheckedUpdateWithoutCallsInput>
  }

  export type OutboundCampaignUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type OutboundCampaignUncheckedUpdateWithoutCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BusinessCreateWithoutRoutingRulesInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallCreateNestedManyWithoutBusinessInput
    outboundCalls?: OutboundCallCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutRoutingRulesInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallUncheckedCreateNestedManyWithoutBusinessInput
    outboundCalls?: OutboundCallUncheckedCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignUncheckedCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutRoutingRulesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutRoutingRulesInput, BusinessUncheckedCreateWithoutRoutingRulesInput>
  }

  export type BusinessUpsertWithoutRoutingRulesInput = {
    update: XOR<BusinessUpdateWithoutRoutingRulesInput, BusinessUncheckedUpdateWithoutRoutingRulesInput>
    create: XOR<BusinessCreateWithoutRoutingRulesInput, BusinessUncheckedCreateWithoutRoutingRulesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutRoutingRulesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutRoutingRulesInput, BusinessUncheckedUpdateWithoutRoutingRulesInput>
  }

  export type BusinessUpdateWithoutRoutingRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUpdateManyWithoutBusinessNestedInput
    outboundCalls?: OutboundCallUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutRoutingRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    outboundCalls?: OutboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUncheckedUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallCreateNestedManyWithoutBusinessInput
    outboundCalls?: OutboundCallCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallUncheckedCreateNestedManyWithoutBusinessInput
    outboundCalls?: OutboundCallUncheckedCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleUncheckedCreateNestedManyWithoutBusinessInput
    callQueue?: CallQueueUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutCampaignsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutCampaignsInput, BusinessUncheckedCreateWithoutCampaignsInput>
  }

  export type OutboundCallCreateWithoutCampaignInput = {
    id?: string
    recipientNumber: string
    recipientName?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutOutboundCallsInput
  }

  export type OutboundCallUncheckedCreateWithoutCampaignInput = {
    id?: string
    businessId: string
    recipientNumber: string
    recipientName?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundCallCreateOrConnectWithoutCampaignInput = {
    where: OutboundCallWhereUniqueInput
    create: XOR<OutboundCallCreateWithoutCampaignInput, OutboundCallUncheckedCreateWithoutCampaignInput>
  }

  export type OutboundCallCreateManyCampaignInputEnvelope = {
    data: OutboundCallCreateManyCampaignInput | OutboundCallCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutCampaignsInput = {
    update: XOR<BusinessUpdateWithoutCampaignsInput, BusinessUncheckedUpdateWithoutCampaignsInput>
    create: XOR<BusinessCreateWithoutCampaignsInput, BusinessUncheckedCreateWithoutCampaignsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutCampaignsInput, BusinessUncheckedUpdateWithoutCampaignsInput>
  }

  export type BusinessUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUpdateManyWithoutBusinessNestedInput
    outboundCalls?: OutboundCallUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    outboundCalls?: OutboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUncheckedUpdateManyWithoutBusinessNestedInput
    callQueue?: CallQueueUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type OutboundCallUpsertWithWhereUniqueWithoutCampaignInput = {
    where: OutboundCallWhereUniqueInput
    update: XOR<OutboundCallUpdateWithoutCampaignInput, OutboundCallUncheckedUpdateWithoutCampaignInput>
    create: XOR<OutboundCallCreateWithoutCampaignInput, OutboundCallUncheckedCreateWithoutCampaignInput>
  }

  export type OutboundCallUpdateWithWhereUniqueWithoutCampaignInput = {
    where: OutboundCallWhereUniqueInput
    data: XOR<OutboundCallUpdateWithoutCampaignInput, OutboundCallUncheckedUpdateWithoutCampaignInput>
  }

  export type OutboundCallUpdateManyWithWhereWithoutCampaignInput = {
    where: OutboundCallScalarWhereInput
    data: XOR<OutboundCallUpdateManyMutationInput, OutboundCallUncheckedUpdateManyWithoutCampaignInput>
  }

  export type BusinessCreateWithoutCallQueueInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallCreateNestedManyWithoutBusinessInput
    outboundCalls?: OutboundCallCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutCallQueueInput = {
    id?: string
    userId: string
    name: string
    phone?: string | null
    timezone?: string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: string | null
    greeting?: string | null
    voicemailPrompt?: string | null
    holdMusicUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inboundCalls?: InboundCallUncheckedCreateNestedManyWithoutBusinessInput
    outboundCalls?: OutboundCallUncheckedCreateNestedManyWithoutBusinessInput
    routingRules?: CallRoutingRuleUncheckedCreateNestedManyWithoutBusinessInput
    campaigns?: OutboundCampaignUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutCallQueueInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutCallQueueInput, BusinessUncheckedCreateWithoutCallQueueInput>
  }

  export type BusinessUpsertWithoutCallQueueInput = {
    update: XOR<BusinessUpdateWithoutCallQueueInput, BusinessUncheckedUpdateWithoutCallQueueInput>
    create: XOR<BusinessCreateWithoutCallQueueInput, BusinessUncheckedCreateWithoutCallQueueInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutCallQueueInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutCallQueueInput, BusinessUncheckedUpdateWithoutCallQueueInput>
  }

  export type BusinessUpdateWithoutCallQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUpdateManyWithoutBusinessNestedInput
    outboundCalls?: OutboundCallUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutCallQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    inboundConfig?: NullableJsonNullValueInput | InputJsonValue
    outboundConfig?: NullableJsonNullValueInput | InputJsonValue
    defaultVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    greeting?: NullableStringFieldUpdateOperationsInput | string | null
    voicemailPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    holdMusicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inboundCalls?: InboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    outboundCalls?: OutboundCallUncheckedUpdateManyWithoutBusinessNestedInput
    routingRules?: CallRoutingRuleUncheckedUpdateManyWithoutBusinessNestedInput
    campaigns?: OutboundCampaignUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type VoiceModelCreateManyUserInput = {
    id?: string
    name: string
    status?: $Enums.VoiceModelStatus
    friendliness?: number
    professionalism?: number
    energy?: number
    formality?: number
    externalVoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallSessionCreateManyUserInput = {
    id?: string
    voiceModelId?: string | null
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingSampleCreateManyUserInput = {
    id?: string
    voiceModelId?: string | null
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    key: string
    name: string
    type?: $Enums.ApiKeyType
    lastUsed?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VoiceModelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: TrainingSampleUpdateManyWithoutVoiceModelNestedInput
    callSessions?: CallSessionUpdateManyWithoutVoiceModelNestedInput
  }

  export type VoiceModelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: TrainingSampleUncheckedUpdateManyWithoutVoiceModelNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutVoiceModelNestedInput
  }

  export type VoiceModelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumVoiceModelStatusFieldUpdateOperationsInput | $Enums.VoiceModelStatus
    friendliness?: IntFieldUpdateOperationsInput | number
    professionalism?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    formality?: IntFieldUpdateOperationsInput | number
    externalVoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModel?: VoiceModelUpdateOneWithoutCallSessionsNestedInput
    transcript?: TranscriptMessageUpdateManyWithoutCallSessionNestedInput
    summary?: CallSummaryUpdateOneWithoutCallSessionNestedInput
  }

  export type CallSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: TranscriptMessageUncheckedUpdateManyWithoutCallSessionNestedInput
    summary?: CallSummaryUncheckedUpdateOneWithoutCallSessionNestedInput
  }

  export type CallSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSampleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceModel?: VoiceModelUpdateOneWithoutSamplesNestedInput
  }

  export type TrainingSampleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSampleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceModelId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumApiKeyTypeFieldUpdateOperationsInput | $Enums.ApiKeyType
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumApiKeyTypeFieldUpdateOperationsInput | $Enums.ApiKeyType
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumApiKeyTypeFieldUpdateOperationsInput | $Enums.ApiKeyType
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSampleCreateManyVoiceModelInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    fileSize: number
    duration?: number | null
    mimeType: string
    createdAt?: Date | string
  }

  export type CallSessionCreateManyVoiceModelInput = {
    id?: string
    userId: string
    phoneNumber: string
    direction?: $Enums.CallDirection
    status?: $Enums.CallStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    sentiment?: $Enums.Sentiment | null
    topics?: CallSessionCreatetopicsInput | string[]
    externalCallId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingSampleUpdateWithoutVoiceModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrainingSamplesNestedInput
  }

  export type TrainingSampleUncheckedUpdateWithoutVoiceModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSampleUncheckedUpdateManyWithoutVoiceModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionUpdateWithoutVoiceModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCallSessionsNestedInput
    transcript?: TranscriptMessageUpdateManyWithoutCallSessionNestedInput
    summary?: CallSummaryUpdateOneWithoutCallSessionNestedInput
  }

  export type CallSessionUncheckedUpdateWithoutVoiceModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: TranscriptMessageUncheckedUpdateManyWithoutCallSessionNestedInput
    summary?: CallSummaryUncheckedUpdateOneWithoutCallSessionNestedInput
  }

  export type CallSessionUncheckedUpdateManyWithoutVoiceModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: EnumCallStatusFieldUpdateOperationsInput | $Enums.CallStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    topics?: CallSessionUpdatetopicsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptMessageCreateManyCallSessionInput = {
    id?: string
    speaker: $Enums.Speaker
    text: string
    confidence?: number | null
    timestamp?: Date | string
  }

  export type TranscriptMessageUpdateWithoutCallSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: EnumSpeakerFieldUpdateOperationsInput | $Enums.Speaker
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptMessageUncheckedUpdateWithoutCallSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: EnumSpeakerFieldUpdateOperationsInput | $Enums.Speaker
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptMessageUncheckedUpdateManyWithoutCallSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    speaker?: EnumSpeakerFieldUpdateOperationsInput | $Enums.Speaker
    text?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InboundCallCreateManyBusinessInput = {
    id?: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.InboundCallStatus
    duration?: number | null
    waitTime?: number | null
    routedTo?: string | null
    routingRuleId?: string | null
    transcript?: string | null
    summary?: string | null
    sentiment?: $Enums.Sentiment | null
    tags?: InboundCallCreatetagsInput | string[]
    externalCallId?: string | null
    recordingUrl?: string | null
    startedAt?: Date | string
    answeredAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundCallCreateManyBusinessInput = {
    id?: string
    recipientNumber: string
    recipientName?: string | null
    campaignId?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRoutingRuleCreateManyBusinessInput = {
    id?: string
    name: string
    priority?: number
    isActive?: boolean
    conditionType: $Enums.ConditionType
    conditionValue: JsonNullValueInput | InputJsonValue
    actionType: $Enums.ActionType
    actionConfig: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundCampaignCreateManyBusinessInput = {
    id?: string
    name: string
    description?: string | null
    scriptTemplate: string
    voiceId?: string | null
    contactList: JsonNullValueInput | InputJsonValue
    totalContacts?: number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    callsPerMinute?: number
    maxConcurrent?: number
    status?: $Enums.CampaignStatus
    completedCalls?: number
    answeredCalls?: number
    voicemailCalls?: number
    failedCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CallQueueCreateManyBusinessInput = {
    id?: string
    callerNumber: string
    callerName?: string | null
    status?: $Enums.QueueStatus
    position: number
    priority?: number
    estimatedWait?: number | null
    actualWait?: number | null
    externalCallId?: string | null
    enteredAt?: Date | string
    servedAt?: Date | string | null
  }

  export type InboundCallUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInboundCallStatusFieldUpdateOperationsInput | $Enums.InboundCallStatus
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    routedTo?: NullableStringFieldUpdateOperationsInput | string | null
    routingRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    tags?: InboundCallUpdatetagsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InboundCallUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInboundCallStatusFieldUpdateOperationsInput | $Enums.InboundCallStatus
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    routedTo?: NullableStringFieldUpdateOperationsInput | string | null
    routingRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    tags?: InboundCallUpdatetagsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InboundCallUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInboundCallStatusFieldUpdateOperationsInput | $Enums.InboundCallStatus
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    routedTo?: NullableStringFieldUpdateOperationsInput | string | null
    routingRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: NullableEnumSentimentFieldUpdateOperationsInput | $Enums.Sentiment | null
    tags?: InboundCallUpdatetagsInput | string[]
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundCallUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: OutboundCampaignUpdateOneWithoutCallsNestedInput
  }

  export type OutboundCallUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundCallUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRoutingRuleUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conditionType?: EnumConditionTypeFieldUpdateOperationsInput | $Enums.ConditionType
    conditionValue?: JsonNullValueInput | InputJsonValue
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    actionConfig?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRoutingRuleUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conditionType?: EnumConditionTypeFieldUpdateOperationsInput | $Enums.ConditionType
    conditionValue?: JsonNullValueInput | InputJsonValue
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    actionConfig?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRoutingRuleUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    conditionType?: EnumConditionTypeFieldUpdateOperationsInput | $Enums.ConditionType
    conditionValue?: JsonNullValueInput | InputJsonValue
    actionType?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    actionConfig?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundCampaignUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calls?: OutboundCallUpdateManyWithoutCampaignNestedInput
  }

  export type OutboundCampaignUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calls?: OutboundCallUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type OutboundCampaignUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scriptTemplate?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    contactList?: JsonNullValueInput | InputJsonValue
    totalContacts?: IntFieldUpdateOperationsInput | number
    scheduleConfig?: NullableJsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    callsPerMinute?: IntFieldUpdateOperationsInput | number
    maxConcurrent?: IntFieldUpdateOperationsInput | number
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    completedCalls?: IntFieldUpdateOperationsInput | number
    answeredCalls?: IntFieldUpdateOperationsInput | number
    voicemailCalls?: IntFieldUpdateOperationsInput | number
    failedCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallQueueUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    estimatedWait?: NullableIntFieldUpdateOperationsInput | number | null
    actualWait?: NullableIntFieldUpdateOperationsInput | number | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallQueueUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    estimatedWait?: NullableIntFieldUpdateOperationsInput | number | null
    actualWait?: NullableIntFieldUpdateOperationsInput | number | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CallQueueUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerNumber?: StringFieldUpdateOperationsInput | string
    callerName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    estimatedWait?: NullableIntFieldUpdateOperationsInput | number | null
    actualWait?: NullableIntFieldUpdateOperationsInput | number | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OutboundCallCreateManyCampaignInput = {
    id?: string
    businessId: string
    recipientNumber: string
    recipientName?: string | null
    status?: $Enums.OutboundCallStatus
    result?: $Enums.CallResult | null
    duration?: number | null
    attempts?: number
    maxAttempts?: number
    scriptUsed?: string | null
    transcript?: string | null
    notes?: string | null
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    externalCallId?: string | null
    recordingUrl?: string | null
    isCallback?: boolean
    callbackReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboundCallUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutOutboundCallsNestedInput
  }

  export type OutboundCallUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboundCallUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    recipientNumber?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOutboundCallStatusFieldUpdateOperationsInput | $Enums.OutboundCallStatus
    result?: NullableEnumCallResultFieldUpdateOperationsInput | $Enums.CallResult | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scriptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalCallId?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isCallback?: BoolFieldUpdateOperationsInput | boolean
    callbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoiceModelCountOutputTypeDefaultArgs instead
     */
    export type VoiceModelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoiceModelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CallSessionCountOutputTypeDefaultArgs instead
     */
    export type CallSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CallSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessCountOutputTypeDefaultArgs instead
     */
    export type BusinessCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutboundCampaignCountOutputTypeDefaultArgs instead
     */
    export type OutboundCampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutboundCampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingsDefaultArgs instead
     */
    export type UserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoiceModelDefaultArgs instead
     */
    export type VoiceModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoiceModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingSampleDefaultArgs instead
     */
    export type TrainingSampleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingSampleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CallSessionDefaultArgs instead
     */
    export type CallSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CallSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranscriptMessageDefaultArgs instead
     */
    export type TranscriptMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranscriptMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CallSummaryDefaultArgs instead
     */
    export type CallSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CallSummaryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyAnalyticsDefaultArgs instead
     */
    export type DailyAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessDefaultArgs instead
     */
    export type BusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InboundCallDefaultArgs instead
     */
    export type InboundCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InboundCallDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutboundCallDefaultArgs instead
     */
    export type OutboundCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutboundCallDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CallRoutingRuleDefaultArgs instead
     */
    export type CallRoutingRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CallRoutingRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutboundCampaignDefaultArgs instead
     */
    export type OutboundCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutboundCampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CallQueueDefaultArgs instead
     */
    export type CallQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CallQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CallbackRequestDefaultArgs instead
     */
    export type CallbackRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CallbackRequestDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}